// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `service/rpc.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
pub struct SignRequest {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub signer: ::std::string::String,
    pub armored: bool,
    pub detached: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignRequest {
    fn default() -> &'a SignRequest {
        <SignRequest as ::protobuf::Message>::default_instance()
    }
}

impl SignRequest {
    pub fn new() -> SignRequest {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // string signer = 5;


    pub fn get_signer(&self) -> &str {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::string::String) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::string::String {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signer, ::std::string::String::new())
    }

    // bool armored = 10;


    pub fn get_armored(&self) -> bool {
        self.armored
    }
    pub fn clear_armored(&mut self) {
        self.armored = false;
    }

    // Param is passed by value, moved
    pub fn set_armored(&mut self, v: bool) {
        self.armored = v;
    }

    // bool detached = 11;


    pub fn get_detached(&self) -> bool {
        self.detached
    }
    pub fn clear_detached(&mut self) {
        self.detached = false;
    }

    // Param is passed by value, moved
    pub fn set_detached(&mut self, v: bool) {
        self.detached = v;
    }
}

impl ::protobuf::Message for SignRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signer)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.armored = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.detached = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.signer);
        }
        if self.armored != false {
            my_size += 2;
        }
        if self.detached != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if !self.signer.is_empty() {
            os.write_string(5, &self.signer)?;
        }
        if self.armored != false {
            os.write_bool(10, self.armored)?;
        }
        if self.detached != false {
            os.write_bool(11, self.detached)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignRequest {
        SignRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &SignRequest| { &m.data },
                |m: &mut SignRequest| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signer",
                |m: &SignRequest| { &m.signer },
                |m: &mut SignRequest| { &mut m.signer },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "armored",
                |m: &SignRequest| { &m.armored },
                |m: &mut SignRequest| { &mut m.armored },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "detached",
                |m: &SignRequest| { &m.detached },
                |m: &mut SignRequest| { &mut m.detached },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignRequest>(
                "SignRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignRequest {
        static instance: ::protobuf::rt::LazyV2<SignRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SignRequest::new)
    }
}

impl ::protobuf::Clear for SignRequest {
    fn clear(&mut self) {
        self.data.clear();
        self.signer.clear();
        self.armored = false;
        self.detached = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignResponse {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub kid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignResponse {
    fn default() -> &'a SignResponse {
        <SignResponse as ::protobuf::Message>::default_instance()
    }
}

impl SignResponse {
    pub fn new() -> SignResponse {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // string kid = 2;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SignResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.kid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if !self.kid.is_empty() {
            os.write_string(2, &self.kid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignResponse {
        SignResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &SignResponse| { &m.data },
                |m: &mut SignResponse| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kid",
                |m: &SignResponse| { &m.kid },
                |m: &mut SignResponse| { &mut m.kid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignResponse>(
                "SignResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignResponse {
        static instance: ::protobuf::rt::LazyV2<SignResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SignResponse::new)
    }
}

impl ::protobuf::Clear for SignResponse {
    fn clear(&mut self) {
        self.data.clear();
        self.kid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignFileInput {
    // message fields
    pub field_in: ::std::string::String,
    pub out: ::std::string::String,
    pub signer: ::std::string::String,
    pub armored: bool,
    pub detached: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignFileInput {
    fn default() -> &'a SignFileInput {
        <SignFileInput as ::protobuf::Message>::default_instance()
    }
}

impl SignFileInput {
    pub fn new() -> SignFileInput {
        ::std::default::Default::default()
    }

    // string in = 1;


    pub fn get_field_in(&self) -> &str {
        &self.field_in
    }
    pub fn clear_field_in(&mut self) {
        self.field_in.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_in(&mut self, v: ::std::string::String) {
        self.field_in = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_in(&mut self) -> &mut ::std::string::String {
        &mut self.field_in
    }

    // Take field
    pub fn take_field_in(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_in, ::std::string::String::new())
    }

    // string out = 2;


    pub fn get_out(&self) -> &str {
        &self.out
    }
    pub fn clear_out(&mut self) {
        self.out.clear();
    }

    // Param is passed by value, moved
    pub fn set_out(&mut self, v: ::std::string::String) {
        self.out = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out(&mut self) -> &mut ::std::string::String {
        &mut self.out
    }

    // Take field
    pub fn take_out(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.out, ::std::string::String::new())
    }

    // string signer = 5;


    pub fn get_signer(&self) -> &str {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::string::String) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::string::String {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signer, ::std::string::String::new())
    }

    // bool armored = 10;


    pub fn get_armored(&self) -> bool {
        self.armored
    }
    pub fn clear_armored(&mut self) {
        self.armored = false;
    }

    // Param is passed by value, moved
    pub fn set_armored(&mut self, v: bool) {
        self.armored = v;
    }

    // bool detached = 11;


    pub fn get_detached(&self) -> bool {
        self.detached
    }
    pub fn clear_detached(&mut self) {
        self.detached = false;
    }

    // Param is passed by value, moved
    pub fn set_detached(&mut self, v: bool) {
        self.detached = v;
    }
}

impl ::protobuf::Message for SignFileInput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_in)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.out)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signer)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.armored = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.detached = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_in.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_in);
        }
        if !self.out.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.out);
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.signer);
        }
        if self.armored != false {
            my_size += 2;
        }
        if self.detached != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_in.is_empty() {
            os.write_string(1, &self.field_in)?;
        }
        if !self.out.is_empty() {
            os.write_string(2, &self.out)?;
        }
        if !self.signer.is_empty() {
            os.write_string(5, &self.signer)?;
        }
        if self.armored != false {
            os.write_bool(10, self.armored)?;
        }
        if self.detached != false {
            os.write_bool(11, self.detached)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignFileInput {
        SignFileInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "in",
                |m: &SignFileInput| { &m.field_in },
                |m: &mut SignFileInput| { &mut m.field_in },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "out",
                |m: &SignFileInput| { &m.out },
                |m: &mut SignFileInput| { &mut m.out },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signer",
                |m: &SignFileInput| { &m.signer },
                |m: &mut SignFileInput| { &mut m.signer },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "armored",
                |m: &SignFileInput| { &m.armored },
                |m: &mut SignFileInput| { &mut m.armored },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "detached",
                |m: &SignFileInput| { &m.detached },
                |m: &mut SignFileInput| { &mut m.detached },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignFileInput>(
                "SignFileInput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignFileInput {
        static instance: ::protobuf::rt::LazyV2<SignFileInput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SignFileInput::new)
    }
}

impl ::protobuf::Clear for SignFileInput {
    fn clear(&mut self) {
        self.field_in.clear();
        self.out.clear();
        self.signer.clear();
        self.armored = false;
        self.detached = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignFileInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignFileInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignFileOutput {
    // message fields
    pub kid: ::std::string::String,
    pub out: ::std::string::String,
    pub bytes: i32,
    pub total: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignFileOutput {
    fn default() -> &'a SignFileOutput {
        <SignFileOutput as ::protobuf::Message>::default_instance()
    }
}

impl SignFileOutput {
    pub fn new() -> SignFileOutput {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // string out = 2;


    pub fn get_out(&self) -> &str {
        &self.out
    }
    pub fn clear_out(&mut self) {
        self.out.clear();
    }

    // Param is passed by value, moved
    pub fn set_out(&mut self, v: ::std::string::String) {
        self.out = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out(&mut self) -> &mut ::std::string::String {
        &mut self.out
    }

    // Take field
    pub fn take_out(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.out, ::std::string::String::new())
    }

    // int32 bytes = 10;


    pub fn get_bytes(&self) -> i32 {
        self.bytes
    }
    pub fn clear_bytes(&mut self) {
        self.bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: i32) {
        self.bytes = v;
    }

    // int32 total = 11;


    pub fn get_total(&self) -> i32 {
        self.total
    }
    pub fn clear_total(&mut self) {
        self.total = 0;
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: i32) {
        self.total = v;
    }
}

impl ::protobuf::Message for SignFileOutput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.out)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bytes = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.total = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        if !self.out.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.out);
        }
        if self.bytes != 0 {
            my_size += ::protobuf::rt::value_size(10, self.bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total != 0 {
            my_size += ::protobuf::rt::value_size(11, self.total, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        if !self.out.is_empty() {
            os.write_string(2, &self.out)?;
        }
        if self.bytes != 0 {
            os.write_int32(10, self.bytes)?;
        }
        if self.total != 0 {
            os.write_int32(11, self.total)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignFileOutput {
        SignFileOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kid",
                |m: &SignFileOutput| { &m.kid },
                |m: &mut SignFileOutput| { &mut m.kid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "out",
                |m: &SignFileOutput| { &m.out },
                |m: &mut SignFileOutput| { &mut m.out },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bytes",
                |m: &SignFileOutput| { &m.bytes },
                |m: &mut SignFileOutput| { &mut m.bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "total",
                |m: &SignFileOutput| { &m.total },
                |m: &mut SignFileOutput| { &mut m.total },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignFileOutput>(
                "SignFileOutput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignFileOutput {
        static instance: ::protobuf::rt::LazyV2<SignFileOutput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SignFileOutput::new)
    }
}

impl ::protobuf::Clear for SignFileOutput {
    fn clear(&mut self) {
        self.kid.clear();
        self.out.clear();
        self.bytes = 0;
        self.total = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignFileOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignFileOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyRequest {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyRequest {
    fn default() -> &'a VerifyRequest {
        <VerifyRequest as ::protobuf::Message>::default_instance()
    }
}

impl VerifyRequest {
    pub fn new() -> VerifyRequest {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for VerifyRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyRequest {
        VerifyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &VerifyRequest| { &m.data },
                |m: &mut VerifyRequest| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyRequest>(
                "VerifyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VerifyRequest {
        static instance: ::protobuf::rt::LazyV2<VerifyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VerifyRequest::new)
    }
}

impl ::protobuf::Clear for VerifyRequest {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyResponse {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub signer: ::protobuf::SingularPtrField<Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyResponse {
    fn default() -> &'a VerifyResponse {
        <VerifyResponse as ::protobuf::Message>::default_instance()
    }
}

impl VerifyResponse {
    pub fn new() -> VerifyResponse {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // .service.Key signer = 2;


    pub fn get_signer(&self) -> &Key {
        self.signer.as_ref().unwrap_or_else(|| <Key as ::protobuf::Message>::default_instance())
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    pub fn has_signer(&self) -> bool {
        self.signer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: Key) {
        self.signer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut Key {
        if self.signer.is_none() {
            self.signer.set_default();
        }
        self.signer.as_mut().unwrap()
    }

    // Take field
    pub fn take_signer(&mut self) -> Key {
        self.signer.take().unwrap_or_else(|| Key::new())
    }
}

impl ::protobuf::Message for VerifyResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.signer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if let Some(ref v) = self.signer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if let Some(ref v) = self.signer.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyResponse {
        VerifyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &VerifyResponse| { &m.data },
                |m: &mut VerifyResponse| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                "signer",
                |m: &VerifyResponse| { &m.signer },
                |m: &mut VerifyResponse| { &mut m.signer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyResponse>(
                "VerifyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VerifyResponse {
        static instance: ::protobuf::rt::LazyV2<VerifyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VerifyResponse::new)
    }
}

impl ::protobuf::Clear for VerifyResponse {
    fn clear(&mut self) {
        self.data.clear();
        self.signer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyDetachedRequest {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub sig: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyDetachedRequest {
    fn default() -> &'a VerifyDetachedRequest {
        <VerifyDetachedRequest as ::protobuf::Message>::default_instance()
    }
}

impl VerifyDetachedRequest {
    pub fn new() -> VerifyDetachedRequest {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // bytes sig = 2;


    pub fn get_sig(&self) -> &[u8] {
        &self.sig
    }
    pub fn clear_sig(&mut self) {
        self.sig.clear();
    }

    // Param is passed by value, moved
    pub fn set_sig(&mut self, v: ::std::vec::Vec<u8>) {
        self.sig = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sig(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.sig
    }

    // Take field
    pub fn take_sig(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.sig, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for VerifyDetachedRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.sig)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if !self.sig.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.sig);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if !self.sig.is_empty() {
            os.write_bytes(2, &self.sig)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyDetachedRequest {
        VerifyDetachedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &VerifyDetachedRequest| { &m.data },
                |m: &mut VerifyDetachedRequest| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sig",
                |m: &VerifyDetachedRequest| { &m.sig },
                |m: &mut VerifyDetachedRequest| { &mut m.sig },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyDetachedRequest>(
                "VerifyDetachedRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VerifyDetachedRequest {
        static instance: ::protobuf::rt::LazyV2<VerifyDetachedRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VerifyDetachedRequest::new)
    }
}

impl ::protobuf::Clear for VerifyDetachedRequest {
    fn clear(&mut self) {
        self.data.clear();
        self.sig.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyDetachedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyDetachedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyDetachedResponse {
    // message fields
    pub signer: ::protobuf::SingularPtrField<Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyDetachedResponse {
    fn default() -> &'a VerifyDetachedResponse {
        <VerifyDetachedResponse as ::protobuf::Message>::default_instance()
    }
}

impl VerifyDetachedResponse {
    pub fn new() -> VerifyDetachedResponse {
        ::std::default::Default::default()
    }

    // .service.Key signer = 1;


    pub fn get_signer(&self) -> &Key {
        self.signer.as_ref().unwrap_or_else(|| <Key as ::protobuf::Message>::default_instance())
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    pub fn has_signer(&self) -> bool {
        self.signer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: Key) {
        self.signer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut Key {
        if self.signer.is_none() {
            self.signer.set_default();
        }
        self.signer.as_mut().unwrap()
    }

    // Take field
    pub fn take_signer(&mut self) -> Key {
        self.signer.take().unwrap_or_else(|| Key::new())
    }
}

impl ::protobuf::Message for VerifyDetachedResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.signer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.signer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.signer.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyDetachedResponse {
        VerifyDetachedResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                "signer",
                |m: &VerifyDetachedResponse| { &m.signer },
                |m: &mut VerifyDetachedResponse| { &mut m.signer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyDetachedResponse>(
                "VerifyDetachedResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VerifyDetachedResponse {
        static instance: ::protobuf::rt::LazyV2<VerifyDetachedResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VerifyDetachedResponse::new)
    }
}

impl ::protobuf::Clear for VerifyDetachedResponse {
    fn clear(&mut self) {
        self.signer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyDetachedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyDetachedResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyInput {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyInput {
    fn default() -> &'a VerifyInput {
        <VerifyInput as ::protobuf::Message>::default_instance()
    }
}

impl VerifyInput {
    pub fn new() -> VerifyInput {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for VerifyInput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyInput {
        VerifyInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &VerifyInput| { &m.data },
                |m: &mut VerifyInput| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyInput>(
                "VerifyInput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VerifyInput {
        static instance: ::protobuf::rt::LazyV2<VerifyInput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VerifyInput::new)
    }
}

impl ::protobuf::Clear for VerifyInput {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyOutput {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub signer: ::protobuf::SingularPtrField<Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyOutput {
    fn default() -> &'a VerifyOutput {
        <VerifyOutput as ::protobuf::Message>::default_instance()
    }
}

impl VerifyOutput {
    pub fn new() -> VerifyOutput {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // .service.Key signer = 2;


    pub fn get_signer(&self) -> &Key {
        self.signer.as_ref().unwrap_or_else(|| <Key as ::protobuf::Message>::default_instance())
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    pub fn has_signer(&self) -> bool {
        self.signer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: Key) {
        self.signer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut Key {
        if self.signer.is_none() {
            self.signer.set_default();
        }
        self.signer.as_mut().unwrap()
    }

    // Take field
    pub fn take_signer(&mut self) -> Key {
        self.signer.take().unwrap_or_else(|| Key::new())
    }
}

impl ::protobuf::Message for VerifyOutput {
    fn is_initialized(&self) -> bool {
        for v in &self.signer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if let Some(ref v) = self.signer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if let Some(ref v) = self.signer.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyOutput {
        VerifyOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &VerifyOutput| { &m.data },
                |m: &mut VerifyOutput| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                "signer",
                |m: &VerifyOutput| { &m.signer },
                |m: &mut VerifyOutput| { &mut m.signer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyOutput>(
                "VerifyOutput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VerifyOutput {
        static instance: ::protobuf::rt::LazyV2<VerifyOutput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VerifyOutput::new)
    }
}

impl ::protobuf::Clear for VerifyOutput {
    fn clear(&mut self) {
        self.data.clear();
        self.signer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyFileInput {
    // message fields
    pub field_in: ::std::string::String,
    pub out: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyFileInput {
    fn default() -> &'a VerifyFileInput {
        <VerifyFileInput as ::protobuf::Message>::default_instance()
    }
}

impl VerifyFileInput {
    pub fn new() -> VerifyFileInput {
        ::std::default::Default::default()
    }

    // string in = 1;


    pub fn get_field_in(&self) -> &str {
        &self.field_in
    }
    pub fn clear_field_in(&mut self) {
        self.field_in.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_in(&mut self, v: ::std::string::String) {
        self.field_in = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_in(&mut self) -> &mut ::std::string::String {
        &mut self.field_in
    }

    // Take field
    pub fn take_field_in(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_in, ::std::string::String::new())
    }

    // string out = 2;


    pub fn get_out(&self) -> &str {
        &self.out
    }
    pub fn clear_out(&mut self) {
        self.out.clear();
    }

    // Param is passed by value, moved
    pub fn set_out(&mut self, v: ::std::string::String) {
        self.out = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out(&mut self) -> &mut ::std::string::String {
        &mut self.out
    }

    // Take field
    pub fn take_out(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.out, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VerifyFileInput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_in)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.out)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_in.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_in);
        }
        if !self.out.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.out);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_in.is_empty() {
            os.write_string(1, &self.field_in)?;
        }
        if !self.out.is_empty() {
            os.write_string(2, &self.out)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyFileInput {
        VerifyFileInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "in",
                |m: &VerifyFileInput| { &m.field_in },
                |m: &mut VerifyFileInput| { &mut m.field_in },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "out",
                |m: &VerifyFileInput| { &m.out },
                |m: &mut VerifyFileInput| { &mut m.out },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyFileInput>(
                "VerifyFileInput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VerifyFileInput {
        static instance: ::protobuf::rt::LazyV2<VerifyFileInput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VerifyFileInput::new)
    }
}

impl ::protobuf::Clear for VerifyFileInput {
    fn clear(&mut self) {
        self.field_in.clear();
        self.out.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyFileInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyFileInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyFileOutput {
    // message fields
    pub signer: ::protobuf::SingularPtrField<Key>,
    pub out: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyFileOutput {
    fn default() -> &'a VerifyFileOutput {
        <VerifyFileOutput as ::protobuf::Message>::default_instance()
    }
}

impl VerifyFileOutput {
    pub fn new() -> VerifyFileOutput {
        ::std::default::Default::default()
    }

    // .service.Key signer = 1;


    pub fn get_signer(&self) -> &Key {
        self.signer.as_ref().unwrap_or_else(|| <Key as ::protobuf::Message>::default_instance())
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    pub fn has_signer(&self) -> bool {
        self.signer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: Key) {
        self.signer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut Key {
        if self.signer.is_none() {
            self.signer.set_default();
        }
        self.signer.as_mut().unwrap()
    }

    // Take field
    pub fn take_signer(&mut self) -> Key {
        self.signer.take().unwrap_or_else(|| Key::new())
    }

    // string out = 2;


    pub fn get_out(&self) -> &str {
        &self.out
    }
    pub fn clear_out(&mut self) {
        self.out.clear();
    }

    // Param is passed by value, moved
    pub fn set_out(&mut self, v: ::std::string::String) {
        self.out = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out(&mut self) -> &mut ::std::string::String {
        &mut self.out
    }

    // Take field
    pub fn take_out(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.out, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VerifyFileOutput {
    fn is_initialized(&self) -> bool {
        for v in &self.signer {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signer)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.out)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.signer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.out.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.out);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.signer.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.out.is_empty() {
            os.write_string(2, &self.out)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyFileOutput {
        VerifyFileOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                "signer",
                |m: &VerifyFileOutput| { &m.signer },
                |m: &mut VerifyFileOutput| { &mut m.signer },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "out",
                |m: &VerifyFileOutput| { &m.out },
                |m: &mut VerifyFileOutput| { &mut m.out },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyFileOutput>(
                "VerifyFileOutput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VerifyFileOutput {
        static instance: ::protobuf::rt::LazyV2<VerifyFileOutput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VerifyFileOutput::new)
    }
}

impl ::protobuf::Clear for VerifyFileOutput {
    fn clear(&mut self) {
        self.signer.clear();
        self.out.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyFileOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyFileOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyDetachedFileInput {
    // message fields
    pub field_in: ::std::string::String,
    pub sig: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyDetachedFileInput {
    fn default() -> &'a VerifyDetachedFileInput {
        <VerifyDetachedFileInput as ::protobuf::Message>::default_instance()
    }
}

impl VerifyDetachedFileInput {
    pub fn new() -> VerifyDetachedFileInput {
        ::std::default::Default::default()
    }

    // string in = 1;


    pub fn get_field_in(&self) -> &str {
        &self.field_in
    }
    pub fn clear_field_in(&mut self) {
        self.field_in.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_in(&mut self, v: ::std::string::String) {
        self.field_in = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_in(&mut self) -> &mut ::std::string::String {
        &mut self.field_in
    }

    // Take field
    pub fn take_field_in(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_in, ::std::string::String::new())
    }

    // bytes sig = 2;


    pub fn get_sig(&self) -> &[u8] {
        &self.sig
    }
    pub fn clear_sig(&mut self) {
        self.sig.clear();
    }

    // Param is passed by value, moved
    pub fn set_sig(&mut self, v: ::std::vec::Vec<u8>) {
        self.sig = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sig(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.sig
    }

    // Take field
    pub fn take_sig(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.sig, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for VerifyDetachedFileInput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_in)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.sig)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_in.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_in);
        }
        if !self.sig.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.sig);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_in.is_empty() {
            os.write_string(1, &self.field_in)?;
        }
        if !self.sig.is_empty() {
            os.write_bytes(2, &self.sig)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyDetachedFileInput {
        VerifyDetachedFileInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "in",
                |m: &VerifyDetachedFileInput| { &m.field_in },
                |m: &mut VerifyDetachedFileInput| { &mut m.field_in },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sig",
                |m: &VerifyDetachedFileInput| { &m.sig },
                |m: &mut VerifyDetachedFileInput| { &mut m.sig },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyDetachedFileInput>(
                "VerifyDetachedFileInput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VerifyDetachedFileInput {
        static instance: ::protobuf::rt::LazyV2<VerifyDetachedFileInput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VerifyDetachedFileInput::new)
    }
}

impl ::protobuf::Clear for VerifyDetachedFileInput {
    fn clear(&mut self) {
        self.field_in.clear();
        self.sig.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyDetachedFileInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyDetachedFileInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyDetachedInput {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub sig: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyDetachedInput {
    fn default() -> &'a VerifyDetachedInput {
        <VerifyDetachedInput as ::protobuf::Message>::default_instance()
    }
}

impl VerifyDetachedInput {
    pub fn new() -> VerifyDetachedInput {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // bytes sig = 2;


    pub fn get_sig(&self) -> &[u8] {
        &self.sig
    }
    pub fn clear_sig(&mut self) {
        self.sig.clear();
    }

    // Param is passed by value, moved
    pub fn set_sig(&mut self, v: ::std::vec::Vec<u8>) {
        self.sig = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sig(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.sig
    }

    // Take field
    pub fn take_sig(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.sig, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for VerifyDetachedInput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.sig)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if !self.sig.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.sig);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if !self.sig.is_empty() {
            os.write_bytes(2, &self.sig)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyDetachedInput {
        VerifyDetachedInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &VerifyDetachedInput| { &m.data },
                |m: &mut VerifyDetachedInput| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sig",
                |m: &VerifyDetachedInput| { &m.sig },
                |m: &mut VerifyDetachedInput| { &mut m.sig },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerifyDetachedInput>(
                "VerifyDetachedInput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VerifyDetachedInput {
        static instance: ::protobuf::rt::LazyV2<VerifyDetachedInput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VerifyDetachedInput::new)
    }
}

impl ::protobuf::Clear for VerifyDetachedInput {
    fn clear(&mut self) {
        self.data.clear();
        self.sig.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyDetachedInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyDetachedInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Statement {
    // message fields
    pub sig: ::std::vec::Vec<u8>,
    pub data: ::std::vec::Vec<u8>,
    pub kid: ::std::string::String,
    pub seq: i32,
    pub prev: ::std::vec::Vec<u8>,
    pub revoke: i32,
    pub timestamp: i64,
    pub field_type: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Statement {
    fn default() -> &'a Statement {
        <Statement as ::protobuf::Message>::default_instance()
    }
}

impl Statement {
    pub fn new() -> Statement {
        ::std::default::Default::default()
    }

    // bytes sig = 1;


    pub fn get_sig(&self) -> &[u8] {
        &self.sig
    }
    pub fn clear_sig(&mut self) {
        self.sig.clear();
    }

    // Param is passed by value, moved
    pub fn set_sig(&mut self, v: ::std::vec::Vec<u8>) {
        self.sig = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sig(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.sig
    }

    // Take field
    pub fn take_sig(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.sig, ::std::vec::Vec::new())
    }

    // bytes data = 2;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // string kid = 3;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // int32 seq = 4;


    pub fn get_seq(&self) -> i32 {
        self.seq
    }
    pub fn clear_seq(&mut self) {
        self.seq = 0;
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: i32) {
        self.seq = v;
    }

    // bytes prev = 5;


    pub fn get_prev(&self) -> &[u8] {
        &self.prev
    }
    pub fn clear_prev(&mut self) {
        self.prev.clear();
    }

    // Param is passed by value, moved
    pub fn set_prev(&mut self, v: ::std::vec::Vec<u8>) {
        self.prev = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prev(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.prev
    }

    // Take field
    pub fn take_prev(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.prev, ::std::vec::Vec::new())
    }

    // int32 revoke = 6;


    pub fn get_revoke(&self) -> i32 {
        self.revoke
    }
    pub fn clear_revoke(&mut self) {
        self.revoke = 0;
    }

    // Param is passed by value, moved
    pub fn set_revoke(&mut self, v: i32) {
        self.revoke = v;
    }

    // int64 timestamp = 7;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // string type = 8;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Statement {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.sig)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seq = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.prev)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.revoke = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sig.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.sig);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.kid);
        }
        if self.seq != 0 {
            my_size += ::protobuf::rt::value_size(4, self.seq, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.prev.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.prev);
        }
        if self.revoke != 0 {
            my_size += ::protobuf::rt::value_size(6, self.revoke, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(7, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sig.is_empty() {
            os.write_bytes(1, &self.sig)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        if !self.kid.is_empty() {
            os.write_string(3, &self.kid)?;
        }
        if self.seq != 0 {
            os.write_int32(4, self.seq)?;
        }
        if !self.prev.is_empty() {
            os.write_bytes(5, &self.prev)?;
        }
        if self.revoke != 0 {
            os.write_int32(6, self.revoke)?;
        }
        if self.timestamp != 0 {
            os.write_int64(7, self.timestamp)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(8, &self.field_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Statement {
        Statement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "sig",
                |m: &Statement| { &m.sig },
                |m: &mut Statement| { &mut m.sig },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &Statement| { &m.data },
                |m: &mut Statement| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kid",
                |m: &Statement| { &m.kid },
                |m: &mut Statement| { &mut m.kid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "seq",
                |m: &Statement| { &m.seq },
                |m: &mut Statement| { &mut m.seq },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "prev",
                |m: &Statement| { &m.prev },
                |m: &mut Statement| { &mut m.prev },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "revoke",
                |m: &Statement| { &m.revoke },
                |m: &mut Statement| { &mut m.revoke },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &Statement| { &m.timestamp },
                |m: &mut Statement| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &Statement| { &m.field_type },
                |m: &mut Statement| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Statement>(
                "Statement",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Statement {
        static instance: ::protobuf::rt::LazyV2<Statement> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Statement::new)
    }
}

impl ::protobuf::Clear for Statement {
    fn clear(&mut self) {
        self.sig.clear();
        self.data.clear();
        self.kid.clear();
        self.seq = 0;
        self.prev.clear();
        self.revoke = 0;
        self.timestamp = 0;
        self.field_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Statement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Statement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SigchainRequest {
    // message fields
    pub kid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SigchainRequest {
    fn default() -> &'a SigchainRequest {
        <SigchainRequest as ::protobuf::Message>::default_instance()
    }
}

impl SigchainRequest {
    pub fn new() -> SigchainRequest {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SigchainRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SigchainRequest {
        SigchainRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kid",
                |m: &SigchainRequest| { &m.kid },
                |m: &mut SigchainRequest| { &mut m.kid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SigchainRequest>(
                "SigchainRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SigchainRequest {
        static instance: ::protobuf::rt::LazyV2<SigchainRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SigchainRequest::new)
    }
}

impl ::protobuf::Clear for SigchainRequest {
    fn clear(&mut self) {
        self.kid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SigchainRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SigchainRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SigchainResponse {
    // message fields
    pub key: ::protobuf::SingularPtrField<Key>,
    pub statements: ::protobuf::RepeatedField<Statement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SigchainResponse {
    fn default() -> &'a SigchainResponse {
        <SigchainResponse as ::protobuf::Message>::default_instance()
    }
}

impl SigchainResponse {
    pub fn new() -> SigchainResponse {
        ::std::default::Default::default()
    }

    // .service.Key key = 1;


    pub fn get_key(&self) -> &Key {
        self.key.as_ref().unwrap_or_else(|| <Key as ::protobuf::Message>::default_instance())
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: Key) {
        self.key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut Key {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> Key {
        self.key.take().unwrap_or_else(|| Key::new())
    }

    // repeated .service.Statement statements = 2;


    pub fn get_statements(&self) -> &[Statement] {
        &self.statements
    }
    pub fn clear_statements(&mut self) {
        self.statements.clear();
    }

    // Param is passed by value, moved
    pub fn set_statements(&mut self, v: ::protobuf::RepeatedField<Statement>) {
        self.statements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statements(&mut self) -> &mut ::protobuf::RepeatedField<Statement> {
        &mut self.statements
    }

    // Take field
    pub fn take_statements(&mut self) -> ::protobuf::RepeatedField<Statement> {
        ::std::mem::replace(&mut self.statements, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SigchainResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.key {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statements {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.statements)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.statements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.statements {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SigchainResponse {
        SigchainResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                "key",
                |m: &SigchainResponse| { &m.key },
                |m: &mut SigchainResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Statement>>(
                "statements",
                |m: &SigchainResponse| { &m.statements },
                |m: &mut SigchainResponse| { &mut m.statements },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SigchainResponse>(
                "SigchainResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SigchainResponse {
        static instance: ::protobuf::rt::LazyV2<SigchainResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SigchainResponse::new)
    }
}

impl ::protobuf::Clear for SigchainResponse {
    fn clear(&mut self) {
        self.key.clear();
        self.statements.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SigchainResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SigchainResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatementRequest {
    // message fields
    pub kid: ::std::string::String,
    pub seq: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatementRequest {
    fn default() -> &'a StatementRequest {
        <StatementRequest as ::protobuf::Message>::default_instance()
    }
}

impl StatementRequest {
    pub fn new() -> StatementRequest {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // int32 seq = 2;


    pub fn get_seq(&self) -> i32 {
        self.seq
    }
    pub fn clear_seq(&mut self) {
        self.seq = 0;
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: i32) {
        self.seq = v;
    }
}

impl ::protobuf::Message for StatementRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seq = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        if self.seq != 0 {
            my_size += ::protobuf::rt::value_size(2, self.seq, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        if self.seq != 0 {
            os.write_int32(2, self.seq)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatementRequest {
        StatementRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kid",
                |m: &StatementRequest| { &m.kid },
                |m: &mut StatementRequest| { &mut m.kid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "seq",
                |m: &StatementRequest| { &m.seq },
                |m: &mut StatementRequest| { &mut m.seq },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatementRequest>(
                "StatementRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatementRequest {
        static instance: ::protobuf::rt::LazyV2<StatementRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatementRequest::new)
    }
}

impl ::protobuf::Clear for StatementRequest {
    fn clear(&mut self) {
        self.kid.clear();
        self.seq = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatementRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatementRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatementResponse {
    // message fields
    pub statement: ::protobuf::SingularPtrField<Statement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatementResponse {
    fn default() -> &'a StatementResponse {
        <StatementResponse as ::protobuf::Message>::default_instance()
    }
}

impl StatementResponse {
    pub fn new() -> StatementResponse {
        ::std::default::Default::default()
    }

    // .service.Statement statement = 1;


    pub fn get_statement(&self) -> &Statement {
        self.statement.as_ref().unwrap_or_else(|| <Statement as ::protobuf::Message>::default_instance())
    }
    pub fn clear_statement(&mut self) {
        self.statement.clear();
    }

    pub fn has_statement(&self) -> bool {
        self.statement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statement(&mut self, v: Statement) {
        self.statement = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statement(&mut self) -> &mut Statement {
        if self.statement.is_none() {
            self.statement.set_default();
        }
        self.statement.as_mut().unwrap()
    }

    // Take field
    pub fn take_statement(&mut self) -> Statement {
        self.statement.take().unwrap_or_else(|| Statement::new())
    }
}

impl ::protobuf::Message for StatementResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.statement {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statement)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.statement.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.statement.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatementResponse {
        StatementResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Statement>>(
                "statement",
                |m: &StatementResponse| { &m.statement },
                |m: &mut StatementResponse| { &mut m.statement },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatementResponse>(
                "StatementResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatementResponse {
        static instance: ::protobuf::rt::LazyV2<StatementResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatementResponse::new)
    }
}

impl ::protobuf::Clear for StatementResponse {
    fn clear(&mut self) {
        self.statement.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatementResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatementResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatementCreateRequest {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub kid: ::std::string::String,
    pub local: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatementCreateRequest {
    fn default() -> &'a StatementCreateRequest {
        <StatementCreateRequest as ::protobuf::Message>::default_instance()
    }
}

impl StatementCreateRequest {
    pub fn new() -> StatementCreateRequest {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // string kid = 2;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // bool local = 5;


    pub fn get_local(&self) -> bool {
        self.local
    }
    pub fn clear_local(&mut self) {
        self.local = false;
    }

    // Param is passed by value, moved
    pub fn set_local(&mut self, v: bool) {
        self.local = v;
    }
}

impl ::protobuf::Message for StatementCreateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.local = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.kid);
        }
        if self.local != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if !self.kid.is_empty() {
            os.write_string(2, &self.kid)?;
        }
        if self.local != false {
            os.write_bool(5, self.local)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatementCreateRequest {
        StatementCreateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &StatementCreateRequest| { &m.data },
                |m: &mut StatementCreateRequest| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kid",
                |m: &StatementCreateRequest| { &m.kid },
                |m: &mut StatementCreateRequest| { &mut m.kid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "local",
                |m: &StatementCreateRequest| { &m.local },
                |m: &mut StatementCreateRequest| { &mut m.local },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatementCreateRequest>(
                "StatementCreateRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatementCreateRequest {
        static instance: ::protobuf::rt::LazyV2<StatementCreateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatementCreateRequest::new)
    }
}

impl ::protobuf::Clear for StatementCreateRequest {
    fn clear(&mut self) {
        self.data.clear();
        self.kid.clear();
        self.local = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatementCreateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatementCreateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatementCreateResponse {
    // message fields
    pub statement: ::protobuf::SingularPtrField<Statement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatementCreateResponse {
    fn default() -> &'a StatementCreateResponse {
        <StatementCreateResponse as ::protobuf::Message>::default_instance()
    }
}

impl StatementCreateResponse {
    pub fn new() -> StatementCreateResponse {
        ::std::default::Default::default()
    }

    // .service.Statement statement = 1;


    pub fn get_statement(&self) -> &Statement {
        self.statement.as_ref().unwrap_or_else(|| <Statement as ::protobuf::Message>::default_instance())
    }
    pub fn clear_statement(&mut self) {
        self.statement.clear();
    }

    pub fn has_statement(&self) -> bool {
        self.statement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statement(&mut self, v: Statement) {
        self.statement = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statement(&mut self) -> &mut Statement {
        if self.statement.is_none() {
            self.statement.set_default();
        }
        self.statement.as_mut().unwrap()
    }

    // Take field
    pub fn take_statement(&mut self) -> Statement {
        self.statement.take().unwrap_or_else(|| Statement::new())
    }
}

impl ::protobuf::Message for StatementCreateResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.statement {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statement)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.statement.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.statement.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatementCreateResponse {
        StatementCreateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Statement>>(
                "statement",
                |m: &StatementCreateResponse| { &m.statement },
                |m: &mut StatementCreateResponse| { &mut m.statement },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatementCreateResponse>(
                "StatementCreateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatementCreateResponse {
        static instance: ::protobuf::rt::LazyV2<StatementCreateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatementCreateResponse::new)
    }
}

impl ::protobuf::Clear for StatementCreateResponse {
    fn clear(&mut self) {
        self.statement.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatementCreateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatementCreateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatementRevokeRequest {
    // message fields
    pub seq: i32,
    pub kid: ::std::string::String,
    pub local: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatementRevokeRequest {
    fn default() -> &'a StatementRevokeRequest {
        <StatementRevokeRequest as ::protobuf::Message>::default_instance()
    }
}

impl StatementRevokeRequest {
    pub fn new() -> StatementRevokeRequest {
        ::std::default::Default::default()
    }

    // int32 seq = 1;


    pub fn get_seq(&self) -> i32 {
        self.seq
    }
    pub fn clear_seq(&mut self) {
        self.seq = 0;
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: i32) {
        self.seq = v;
    }

    // string kid = 2;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // bool local = 5;


    pub fn get_local(&self) -> bool {
        self.local
    }
    pub fn clear_local(&mut self) {
        self.local = false;
    }

    // Param is passed by value, moved
    pub fn set_local(&mut self, v: bool) {
        self.local = v;
    }
}

impl ::protobuf::Message for StatementRevokeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seq = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.local = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.seq != 0 {
            my_size += ::protobuf::rt::value_size(1, self.seq, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.kid);
        }
        if self.local != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.seq != 0 {
            os.write_int32(1, self.seq)?;
        }
        if !self.kid.is_empty() {
            os.write_string(2, &self.kid)?;
        }
        if self.local != false {
            os.write_bool(5, self.local)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatementRevokeRequest {
        StatementRevokeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "seq",
                |m: &StatementRevokeRequest| { &m.seq },
                |m: &mut StatementRevokeRequest| { &mut m.seq },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kid",
                |m: &StatementRevokeRequest| { &m.kid },
                |m: &mut StatementRevokeRequest| { &mut m.kid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "local",
                |m: &StatementRevokeRequest| { &m.local },
                |m: &mut StatementRevokeRequest| { &mut m.local },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatementRevokeRequest>(
                "StatementRevokeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatementRevokeRequest {
        static instance: ::protobuf::rt::LazyV2<StatementRevokeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatementRevokeRequest::new)
    }
}

impl ::protobuf::Clear for StatementRevokeRequest {
    fn clear(&mut self) {
        self.seq = 0;
        self.kid.clear();
        self.local = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatementRevokeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatementRevokeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatementRevokeResponse {
    // message fields
    pub statement: ::protobuf::SingularPtrField<Statement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatementRevokeResponse {
    fn default() -> &'a StatementRevokeResponse {
        <StatementRevokeResponse as ::protobuf::Message>::default_instance()
    }
}

impl StatementRevokeResponse {
    pub fn new() -> StatementRevokeResponse {
        ::std::default::Default::default()
    }

    // .service.Statement statement = 1;


    pub fn get_statement(&self) -> &Statement {
        self.statement.as_ref().unwrap_or_else(|| <Statement as ::protobuf::Message>::default_instance())
    }
    pub fn clear_statement(&mut self) {
        self.statement.clear();
    }

    pub fn has_statement(&self) -> bool {
        self.statement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statement(&mut self, v: Statement) {
        self.statement = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statement(&mut self) -> &mut Statement {
        if self.statement.is_none() {
            self.statement.set_default();
        }
        self.statement.as_mut().unwrap()
    }

    // Take field
    pub fn take_statement(&mut self) -> Statement {
        self.statement.take().unwrap_or_else(|| Statement::new())
    }
}

impl ::protobuf::Message for StatementRevokeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.statement {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statement)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.statement.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.statement.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatementRevokeResponse {
        StatementRevokeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Statement>>(
                "statement",
                |m: &StatementRevokeResponse| { &m.statement },
                |m: &mut StatementRevokeResponse| { &mut m.statement },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatementRevokeResponse>(
                "StatementRevokeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatementRevokeResponse {
        static instance: ::protobuf::rt::LazyV2<StatementRevokeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatementRevokeResponse::new)
    }
}

impl ::protobuf::Clear for StatementRevokeResponse {
    fn clear(&mut self) {
        self.statement.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatementRevokeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatementRevokeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignInput {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub field_in: ::std::string::String,
    pub out: ::std::string::String,
    pub signer: ::std::string::String,
    pub armored: bool,
    pub detached: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignInput {
    fn default() -> &'a SignInput {
        <SignInput as ::protobuf::Message>::default_instance()
    }
}

impl SignInput {
    pub fn new() -> SignInput {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // string in = 2;


    pub fn get_field_in(&self) -> &str {
        &self.field_in
    }
    pub fn clear_field_in(&mut self) {
        self.field_in.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_in(&mut self, v: ::std::string::String) {
        self.field_in = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_in(&mut self) -> &mut ::std::string::String {
        &mut self.field_in
    }

    // Take field
    pub fn take_field_in(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_in, ::std::string::String::new())
    }

    // string out = 3;


    pub fn get_out(&self) -> &str {
        &self.out
    }
    pub fn clear_out(&mut self) {
        self.out.clear();
    }

    // Param is passed by value, moved
    pub fn set_out(&mut self, v: ::std::string::String) {
        self.out = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out(&mut self) -> &mut ::std::string::String {
        &mut self.out
    }

    // Take field
    pub fn take_out(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.out, ::std::string::String::new())
    }

    // string signer = 5;


    pub fn get_signer(&self) -> &str {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::string::String) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::string::String {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signer, ::std::string::String::new())
    }

    // bool armored = 10;


    pub fn get_armored(&self) -> bool {
        self.armored
    }
    pub fn clear_armored(&mut self) {
        self.armored = false;
    }

    // Param is passed by value, moved
    pub fn set_armored(&mut self, v: bool) {
        self.armored = v;
    }

    // bool detached = 11;


    pub fn get_detached(&self) -> bool {
        self.detached
    }
    pub fn clear_detached(&mut self) {
        self.detached = false;
    }

    // Param is passed by value, moved
    pub fn set_detached(&mut self, v: bool) {
        self.detached = v;
    }
}

impl ::protobuf::Message for SignInput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_in)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.out)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signer)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.armored = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.detached = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if !self.field_in.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.field_in);
        }
        if !self.out.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.out);
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.signer);
        }
        if self.armored != false {
            my_size += 2;
        }
        if self.detached != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if !self.field_in.is_empty() {
            os.write_string(2, &self.field_in)?;
        }
        if !self.out.is_empty() {
            os.write_string(3, &self.out)?;
        }
        if !self.signer.is_empty() {
            os.write_string(5, &self.signer)?;
        }
        if self.armored != false {
            os.write_bool(10, self.armored)?;
        }
        if self.detached != false {
            os.write_bool(11, self.detached)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignInput {
        SignInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &SignInput| { &m.data },
                |m: &mut SignInput| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "in",
                |m: &SignInput| { &m.field_in },
                |m: &mut SignInput| { &mut m.field_in },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "out",
                |m: &SignInput| { &m.out },
                |m: &mut SignInput| { &mut m.out },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signer",
                |m: &SignInput| { &m.signer },
                |m: &mut SignInput| { &mut m.signer },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "armored",
                |m: &SignInput| { &m.armored },
                |m: &mut SignInput| { &mut m.armored },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "detached",
                |m: &SignInput| { &m.detached },
                |m: &mut SignInput| { &mut m.detached },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignInput>(
                "SignInput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignInput {
        static instance: ::protobuf::rt::LazyV2<SignInput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SignInput::new)
    }
}

impl ::protobuf::Clear for SignInput {
    fn clear(&mut self) {
        self.data.clear();
        self.field_in.clear();
        self.out.clear();
        self.signer.clear();
        self.armored = false;
        self.detached = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignOutput {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub kid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignOutput {
    fn default() -> &'a SignOutput {
        <SignOutput as ::protobuf::Message>::default_instance()
    }
}

impl SignOutput {
    pub fn new() -> SignOutput {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // string kid = 2;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SignOutput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.kid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if !self.kid.is_empty() {
            os.write_string(2, &self.kid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignOutput {
        SignOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &SignOutput| { &m.data },
                |m: &mut SignOutput| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kid",
                |m: &SignOutput| { &m.kid },
                |m: &mut SignOutput| { &mut m.kid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignOutput>(
                "SignOutput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SignOutput {
        static instance: ::protobuf::rt::LazyV2<SignOutput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SignOutput::new)
    }
}

impl ::protobuf::Clear for SignOutput {
    fn clear(&mut self) {
        self.data.clear();
        self.kid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncryptOptions {
    // message fields
    pub armored: bool,
    pub mode: EncryptMode,
    pub noSenderRecipient: bool,
    pub noSign: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncryptOptions {
    fn default() -> &'a EncryptOptions {
        <EncryptOptions as ::protobuf::Message>::default_instance()
    }
}

impl EncryptOptions {
    pub fn new() -> EncryptOptions {
        ::std::default::Default::default()
    }

    // bool armored = 1;


    pub fn get_armored(&self) -> bool {
        self.armored
    }
    pub fn clear_armored(&mut self) {
        self.armored = false;
    }

    // Param is passed by value, moved
    pub fn set_armored(&mut self, v: bool) {
        self.armored = v;
    }

    // .service.EncryptMode mode = 2;


    pub fn get_mode(&self) -> EncryptMode {
        self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode = EncryptMode::DEFAULT_ENCRYPT;
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: EncryptMode) {
        self.mode = v;
    }

    // bool noSenderRecipient = 3;


    pub fn get_noSenderRecipient(&self) -> bool {
        self.noSenderRecipient
    }
    pub fn clear_noSenderRecipient(&mut self) {
        self.noSenderRecipient = false;
    }

    // Param is passed by value, moved
    pub fn set_noSenderRecipient(&mut self, v: bool) {
        self.noSenderRecipient = v;
    }

    // bool noSign = 4;


    pub fn get_noSign(&self) -> bool {
        self.noSign
    }
    pub fn clear_noSign(&mut self) {
        self.noSign = false;
    }

    // Param is passed by value, moved
    pub fn set_noSign(&mut self, v: bool) {
        self.noSign = v;
    }
}

impl ::protobuf::Message for EncryptOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.armored = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.noSenderRecipient = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.noSign = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.armored != false {
            my_size += 2;
        }
        if self.mode != EncryptMode::DEFAULT_ENCRYPT {
            my_size += ::protobuf::rt::enum_size(2, self.mode);
        }
        if self.noSenderRecipient != false {
            my_size += 2;
        }
        if self.noSign != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.armored != false {
            os.write_bool(1, self.armored)?;
        }
        if self.mode != EncryptMode::DEFAULT_ENCRYPT {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.mode))?;
        }
        if self.noSenderRecipient != false {
            os.write_bool(3, self.noSenderRecipient)?;
        }
        if self.noSign != false {
            os.write_bool(4, self.noSign)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptOptions {
        EncryptOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "armored",
                |m: &EncryptOptions| { &m.armored },
                |m: &mut EncryptOptions| { &mut m.armored },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EncryptMode>>(
                "mode",
                |m: &EncryptOptions| { &m.mode },
                |m: &mut EncryptOptions| { &mut m.mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "noSenderRecipient",
                |m: &EncryptOptions| { &m.noSenderRecipient },
                |m: &mut EncryptOptions| { &mut m.noSenderRecipient },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "noSign",
                |m: &EncryptOptions| { &m.noSign },
                |m: &mut EncryptOptions| { &mut m.noSign },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EncryptOptions>(
                "EncryptOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EncryptOptions {
        static instance: ::protobuf::rt::LazyV2<EncryptOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EncryptOptions::new)
    }
}

impl ::protobuf::Clear for EncryptOptions {
    fn clear(&mut self) {
        self.armored = false;
        self.mode = EncryptMode::DEFAULT_ENCRYPT;
        self.noSenderRecipient = false;
        self.noSign = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncryptRequest {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub recipients: ::protobuf::RepeatedField<::std::string::String>,
    pub sender: ::std::string::String,
    pub options: ::protobuf::SingularPtrField<EncryptOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncryptRequest {
    fn default() -> &'a EncryptRequest {
        <EncryptRequest as ::protobuf::Message>::default_instance()
    }
}

impl EncryptRequest {
    pub fn new() -> EncryptRequest {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // repeated string recipients = 3;


    pub fn get_recipients(&self) -> &[::std::string::String] {
        &self.recipients
    }
    pub fn clear_recipients(&mut self) {
        self.recipients.clear();
    }

    // Param is passed by value, moved
    pub fn set_recipients(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.recipients = v;
    }

    // Mutable pointer to the field.
    pub fn mut_recipients(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.recipients
    }

    // Take field
    pub fn take_recipients(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.recipients, ::protobuf::RepeatedField::new())
    }

    // string sender = 4;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // .service.EncryptOptions options = 10;


    pub fn get_options(&self) -> &EncryptOptions {
        self.options.as_ref().unwrap_or_else(|| <EncryptOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: EncryptOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut EncryptOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> EncryptOptions {
        self.options.take().unwrap_or_else(|| EncryptOptions::new())
    }
}

impl ::protobuf::Message for EncryptRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.recipients)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        for value in &self.recipients {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.sender);
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        for v in &self.recipients {
            os.write_string(3, &v)?;
        };
        if !self.sender.is_empty() {
            os.write_string(4, &self.sender)?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptRequest {
        EncryptRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &EncryptRequest| { &m.data },
                |m: &mut EncryptRequest| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "recipients",
                |m: &EncryptRequest| { &m.recipients },
                |m: &mut EncryptRequest| { &mut m.recipients },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sender",
                |m: &EncryptRequest| { &m.sender },
                |m: &mut EncryptRequest| { &mut m.sender },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncryptOptions>>(
                "options",
                |m: &EncryptRequest| { &m.options },
                |m: &mut EncryptRequest| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EncryptRequest>(
                "EncryptRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EncryptRequest {
        static instance: ::protobuf::rt::LazyV2<EncryptRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EncryptRequest::new)
    }
}

impl ::protobuf::Clear for EncryptRequest {
    fn clear(&mut self) {
        self.data.clear();
        self.recipients.clear();
        self.sender.clear();
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncryptResponse {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub info: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncryptResponse {
    fn default() -> &'a EncryptResponse {
        <EncryptResponse as ::protobuf::Message>::default_instance()
    }
}

impl EncryptResponse {
    pub fn new() -> EncryptResponse {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // string info = 2;


    pub fn get_info(&self) -> &str {
        &self.info
    }
    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::std::string::String) {
        self.info = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ::std::string::String {
        &mut self.info
    }

    // Take field
    pub fn take_info(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.info, ::std::string::String::new())
    }
}

impl ::protobuf::Message for EncryptResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if !self.info.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.info);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if !self.info.is_empty() {
            os.write_string(2, &self.info)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptResponse {
        EncryptResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &EncryptResponse| { &m.data },
                |m: &mut EncryptResponse| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "info",
                |m: &EncryptResponse| { &m.info },
                |m: &mut EncryptResponse| { &mut m.info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EncryptResponse>(
                "EncryptResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EncryptResponse {
        static instance: ::protobuf::rt::LazyV2<EncryptResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EncryptResponse::new)
    }
}

impl ::protobuf::Clear for EncryptResponse {
    fn clear(&mut self) {
        self.data.clear();
        self.info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncryptFileInput {
    // message fields
    pub field_in: ::std::string::String,
    pub out: ::std::string::String,
    pub recipients: ::protobuf::RepeatedField<::std::string::String>,
    pub sender: ::std::string::String,
    pub options: ::protobuf::SingularPtrField<EncryptOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncryptFileInput {
    fn default() -> &'a EncryptFileInput {
        <EncryptFileInput as ::protobuf::Message>::default_instance()
    }
}

impl EncryptFileInput {
    pub fn new() -> EncryptFileInput {
        ::std::default::Default::default()
    }

    // string in = 1;


    pub fn get_field_in(&self) -> &str {
        &self.field_in
    }
    pub fn clear_field_in(&mut self) {
        self.field_in.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_in(&mut self, v: ::std::string::String) {
        self.field_in = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_in(&mut self) -> &mut ::std::string::String {
        &mut self.field_in
    }

    // Take field
    pub fn take_field_in(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_in, ::std::string::String::new())
    }

    // string out = 2;


    pub fn get_out(&self) -> &str {
        &self.out
    }
    pub fn clear_out(&mut self) {
        self.out.clear();
    }

    // Param is passed by value, moved
    pub fn set_out(&mut self, v: ::std::string::String) {
        self.out = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out(&mut self) -> &mut ::std::string::String {
        &mut self.out
    }

    // Take field
    pub fn take_out(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.out, ::std::string::String::new())
    }

    // repeated string recipients = 3;


    pub fn get_recipients(&self) -> &[::std::string::String] {
        &self.recipients
    }
    pub fn clear_recipients(&mut self) {
        self.recipients.clear();
    }

    // Param is passed by value, moved
    pub fn set_recipients(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.recipients = v;
    }

    // Mutable pointer to the field.
    pub fn mut_recipients(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.recipients
    }

    // Take field
    pub fn take_recipients(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.recipients, ::protobuf::RepeatedField::new())
    }

    // string sender = 4;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // .service.EncryptOptions options = 10;


    pub fn get_options(&self) -> &EncryptOptions {
        self.options.as_ref().unwrap_or_else(|| <EncryptOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: EncryptOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut EncryptOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> EncryptOptions {
        self.options.take().unwrap_or_else(|| EncryptOptions::new())
    }
}

impl ::protobuf::Message for EncryptFileInput {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_in)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.out)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.recipients)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_in.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_in);
        }
        if !self.out.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.out);
        }
        for value in &self.recipients {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.sender);
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_in.is_empty() {
            os.write_string(1, &self.field_in)?;
        }
        if !self.out.is_empty() {
            os.write_string(2, &self.out)?;
        }
        for v in &self.recipients {
            os.write_string(3, &v)?;
        };
        if !self.sender.is_empty() {
            os.write_string(4, &self.sender)?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptFileInput {
        EncryptFileInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "in",
                |m: &EncryptFileInput| { &m.field_in },
                |m: &mut EncryptFileInput| { &mut m.field_in },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "out",
                |m: &EncryptFileInput| { &m.out },
                |m: &mut EncryptFileInput| { &mut m.out },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "recipients",
                |m: &EncryptFileInput| { &m.recipients },
                |m: &mut EncryptFileInput| { &mut m.recipients },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sender",
                |m: &EncryptFileInput| { &m.sender },
                |m: &mut EncryptFileInput| { &mut m.sender },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncryptOptions>>(
                "options",
                |m: &EncryptFileInput| { &m.options },
                |m: &mut EncryptFileInput| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EncryptFileInput>(
                "EncryptFileInput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EncryptFileInput {
        static instance: ::protobuf::rt::LazyV2<EncryptFileInput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EncryptFileInput::new)
    }
}

impl ::protobuf::Clear for EncryptFileInput {
    fn clear(&mut self) {
        self.field_in.clear();
        self.out.clear();
        self.recipients.clear();
        self.sender.clear();
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptFileInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptFileInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncryptFileOutput {
    // message fields
    pub out: ::std::string::String,
    pub bytes: i32,
    pub total: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncryptFileOutput {
    fn default() -> &'a EncryptFileOutput {
        <EncryptFileOutput as ::protobuf::Message>::default_instance()
    }
}

impl EncryptFileOutput {
    pub fn new() -> EncryptFileOutput {
        ::std::default::Default::default()
    }

    // string out = 2;


    pub fn get_out(&self) -> &str {
        &self.out
    }
    pub fn clear_out(&mut self) {
        self.out.clear();
    }

    // Param is passed by value, moved
    pub fn set_out(&mut self, v: ::std::string::String) {
        self.out = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out(&mut self) -> &mut ::std::string::String {
        &mut self.out
    }

    // Take field
    pub fn take_out(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.out, ::std::string::String::new())
    }

    // int32 bytes = 10;


    pub fn get_bytes(&self) -> i32 {
        self.bytes
    }
    pub fn clear_bytes(&mut self) {
        self.bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: i32) {
        self.bytes = v;
    }

    // int32 total = 11;


    pub fn get_total(&self) -> i32 {
        self.total
    }
    pub fn clear_total(&mut self) {
        self.total = 0;
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: i32) {
        self.total = v;
    }
}

impl ::protobuf::Message for EncryptFileOutput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.out)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bytes = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.total = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.out.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.out);
        }
        if self.bytes != 0 {
            my_size += ::protobuf::rt::value_size(10, self.bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total != 0 {
            my_size += ::protobuf::rt::value_size(11, self.total, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.out.is_empty() {
            os.write_string(2, &self.out)?;
        }
        if self.bytes != 0 {
            os.write_int32(10, self.bytes)?;
        }
        if self.total != 0 {
            os.write_int32(11, self.total)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptFileOutput {
        EncryptFileOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "out",
                |m: &EncryptFileOutput| { &m.out },
                |m: &mut EncryptFileOutput| { &mut m.out },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bytes",
                |m: &EncryptFileOutput| { &m.bytes },
                |m: &mut EncryptFileOutput| { &mut m.bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "total",
                |m: &EncryptFileOutput| { &m.total },
                |m: &mut EncryptFileOutput| { &mut m.total },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EncryptFileOutput>(
                "EncryptFileOutput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EncryptFileOutput {
        static instance: ::protobuf::rt::LazyV2<EncryptFileOutput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EncryptFileOutput::new)
    }
}

impl ::protobuf::Clear for EncryptFileOutput {
    fn clear(&mut self) {
        self.out.clear();
        self.bytes = 0;
        self.total = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptFileOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptFileOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncryptInput {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub recipients: ::protobuf::RepeatedField<::std::string::String>,
    pub sender: ::std::string::String,
    pub options: ::protobuf::SingularPtrField<EncryptOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncryptInput {
    fn default() -> &'a EncryptInput {
        <EncryptInput as ::protobuf::Message>::default_instance()
    }
}

impl EncryptInput {
    pub fn new() -> EncryptInput {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // repeated string recipients = 3;


    pub fn get_recipients(&self) -> &[::std::string::String] {
        &self.recipients
    }
    pub fn clear_recipients(&mut self) {
        self.recipients.clear();
    }

    // Param is passed by value, moved
    pub fn set_recipients(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.recipients = v;
    }

    // Mutable pointer to the field.
    pub fn mut_recipients(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.recipients
    }

    // Take field
    pub fn take_recipients(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.recipients, ::protobuf::RepeatedField::new())
    }

    // string sender = 4;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // .service.EncryptOptions options = 10;


    pub fn get_options(&self) -> &EncryptOptions {
        self.options.as_ref().unwrap_or_else(|| <EncryptOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: EncryptOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut EncryptOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> EncryptOptions {
        self.options.take().unwrap_or_else(|| EncryptOptions::new())
    }
}

impl ::protobuf::Message for EncryptInput {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.recipients)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        for value in &self.recipients {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.sender);
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        for v in &self.recipients {
            os.write_string(3, &v)?;
        };
        if !self.sender.is_empty() {
            os.write_string(4, &self.sender)?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptInput {
        EncryptInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &EncryptInput| { &m.data },
                |m: &mut EncryptInput| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "recipients",
                |m: &EncryptInput| { &m.recipients },
                |m: &mut EncryptInput| { &mut m.recipients },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sender",
                |m: &EncryptInput| { &m.sender },
                |m: &mut EncryptInput| { &mut m.sender },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncryptOptions>>(
                "options",
                |m: &EncryptInput| { &m.options },
                |m: &mut EncryptInput| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EncryptInput>(
                "EncryptInput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EncryptInput {
        static instance: ::protobuf::rt::LazyV2<EncryptInput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EncryptInput::new)
    }
}

impl ::protobuf::Clear for EncryptInput {
    fn clear(&mut self) {
        self.data.clear();
        self.recipients.clear();
        self.sender.clear();
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncryptOutput {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncryptOutput {
    fn default() -> &'a EncryptOutput {
        <EncryptOutput as ::protobuf::Message>::default_instance()
    }
}

impl EncryptOutput {
    pub fn new() -> EncryptOutput {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for EncryptOutput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptOutput {
        EncryptOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &EncryptOutput| { &m.data },
                |m: &mut EncryptOutput| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EncryptOutput>(
                "EncryptOutput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EncryptOutput {
        static instance: ::protobuf::rt::LazyV2<EncryptOutput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EncryptOutput::new)
    }
}

impl ::protobuf::Clear for EncryptOutput {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DecryptRequest {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecryptRequest {
    fn default() -> &'a DecryptRequest {
        <DecryptRequest as ::protobuf::Message>::default_instance()
    }
}

impl DecryptRequest {
    pub fn new() -> DecryptRequest {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DecryptRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecryptRequest {
        DecryptRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &DecryptRequest| { &m.data },
                |m: &mut DecryptRequest| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DecryptRequest>(
                "DecryptRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DecryptRequest {
        static instance: ::protobuf::rt::LazyV2<DecryptRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DecryptRequest::new)
    }
}

impl ::protobuf::Clear for DecryptRequest {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecryptRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecryptRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DecryptResponse {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub sender: ::protobuf::SingularPtrField<Key>,
    pub mode: EncryptMode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecryptResponse {
    fn default() -> &'a DecryptResponse {
        <DecryptResponse as ::protobuf::Message>::default_instance()
    }
}

impl DecryptResponse {
    pub fn new() -> DecryptResponse {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // .service.Key sender = 2;


    pub fn get_sender(&self) -> &Key {
        self.sender.as_ref().unwrap_or_else(|| <Key as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    pub fn has_sender(&self) -> bool {
        self.sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: Key) {
        self.sender = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut Key {
        if self.sender.is_none() {
            self.sender.set_default();
        }
        self.sender.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender(&mut self) -> Key {
        self.sender.take().unwrap_or_else(|| Key::new())
    }

    // .service.EncryptMode mode = 5;


    pub fn get_mode(&self) -> EncryptMode {
        self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode = EncryptMode::DEFAULT_ENCRYPT;
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: EncryptMode) {
        self.mode = v;
    }
}

impl ::protobuf::Message for DecryptResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.sender {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sender)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if let Some(ref v) = self.sender.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.mode != EncryptMode::DEFAULT_ENCRYPT {
            my_size += ::protobuf::rt::enum_size(5, self.mode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if let Some(ref v) = self.sender.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.mode != EncryptMode::DEFAULT_ENCRYPT {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.mode))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecryptResponse {
        DecryptResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &DecryptResponse| { &m.data },
                |m: &mut DecryptResponse| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                "sender",
                |m: &DecryptResponse| { &m.sender },
                |m: &mut DecryptResponse| { &mut m.sender },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EncryptMode>>(
                "mode",
                |m: &DecryptResponse| { &m.mode },
                |m: &mut DecryptResponse| { &mut m.mode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DecryptResponse>(
                "DecryptResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DecryptResponse {
        static instance: ::protobuf::rt::LazyV2<DecryptResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DecryptResponse::new)
    }
}

impl ::protobuf::Clear for DecryptResponse {
    fn clear(&mut self) {
        self.data.clear();
        self.sender.clear();
        self.mode = EncryptMode::DEFAULT_ENCRYPT;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecryptResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecryptResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DecryptFileInput {
    // message fields
    pub field_in: ::std::string::String,
    pub out: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecryptFileInput {
    fn default() -> &'a DecryptFileInput {
        <DecryptFileInput as ::protobuf::Message>::default_instance()
    }
}

impl DecryptFileInput {
    pub fn new() -> DecryptFileInput {
        ::std::default::Default::default()
    }

    // string in = 1;


    pub fn get_field_in(&self) -> &str {
        &self.field_in
    }
    pub fn clear_field_in(&mut self) {
        self.field_in.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_in(&mut self, v: ::std::string::String) {
        self.field_in = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_in(&mut self) -> &mut ::std::string::String {
        &mut self.field_in
    }

    // Take field
    pub fn take_field_in(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_in, ::std::string::String::new())
    }

    // string out = 2;


    pub fn get_out(&self) -> &str {
        &self.out
    }
    pub fn clear_out(&mut self) {
        self.out.clear();
    }

    // Param is passed by value, moved
    pub fn set_out(&mut self, v: ::std::string::String) {
        self.out = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out(&mut self) -> &mut ::std::string::String {
        &mut self.out
    }

    // Take field
    pub fn take_out(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.out, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DecryptFileInput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_in)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.out)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_in.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_in);
        }
        if !self.out.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.out);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_in.is_empty() {
            os.write_string(1, &self.field_in)?;
        }
        if !self.out.is_empty() {
            os.write_string(2, &self.out)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecryptFileInput {
        DecryptFileInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "in",
                |m: &DecryptFileInput| { &m.field_in },
                |m: &mut DecryptFileInput| { &mut m.field_in },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "out",
                |m: &DecryptFileInput| { &m.out },
                |m: &mut DecryptFileInput| { &mut m.out },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DecryptFileInput>(
                "DecryptFileInput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DecryptFileInput {
        static instance: ::protobuf::rt::LazyV2<DecryptFileInput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DecryptFileInput::new)
    }
}

impl ::protobuf::Clear for DecryptFileInput {
    fn clear(&mut self) {
        self.field_in.clear();
        self.out.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecryptFileInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecryptFileInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DecryptFileOutput {
    // message fields
    pub sender: ::protobuf::SingularPtrField<Key>,
    pub out: ::std::string::String,
    pub bytes: i32,
    pub total: i32,
    pub mode: EncryptMode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecryptFileOutput {
    fn default() -> &'a DecryptFileOutput {
        <DecryptFileOutput as ::protobuf::Message>::default_instance()
    }
}

impl DecryptFileOutput {
    pub fn new() -> DecryptFileOutput {
        ::std::default::Default::default()
    }

    // .service.Key sender = 1;


    pub fn get_sender(&self) -> &Key {
        self.sender.as_ref().unwrap_or_else(|| <Key as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    pub fn has_sender(&self) -> bool {
        self.sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: Key) {
        self.sender = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut Key {
        if self.sender.is_none() {
            self.sender.set_default();
        }
        self.sender.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender(&mut self) -> Key {
        self.sender.take().unwrap_or_else(|| Key::new())
    }

    // string out = 2;


    pub fn get_out(&self) -> &str {
        &self.out
    }
    pub fn clear_out(&mut self) {
        self.out.clear();
    }

    // Param is passed by value, moved
    pub fn set_out(&mut self, v: ::std::string::String) {
        self.out = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_out(&mut self) -> &mut ::std::string::String {
        &mut self.out
    }

    // Take field
    pub fn take_out(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.out, ::std::string::String::new())
    }

    // int32 bytes = 10;


    pub fn get_bytes(&self) -> i32 {
        self.bytes
    }
    pub fn clear_bytes(&mut self) {
        self.bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: i32) {
        self.bytes = v;
    }

    // int32 total = 11;


    pub fn get_total(&self) -> i32 {
        self.total
    }
    pub fn clear_total(&mut self) {
        self.total = 0;
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: i32) {
        self.total = v;
    }

    // .service.EncryptMode mode = 5;


    pub fn get_mode(&self) -> EncryptMode {
        self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode = EncryptMode::DEFAULT_ENCRYPT;
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: EncryptMode) {
        self.mode = v;
    }
}

impl ::protobuf::Message for DecryptFileOutput {
    fn is_initialized(&self) -> bool {
        for v in &self.sender {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.out)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.bytes = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.total = tmp;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.sender.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.out.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.out);
        }
        if self.bytes != 0 {
            my_size += ::protobuf::rt::value_size(10, self.bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total != 0 {
            my_size += ::protobuf::rt::value_size(11, self.total, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.mode != EncryptMode::DEFAULT_ENCRYPT {
            my_size += ::protobuf::rt::enum_size(5, self.mode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.sender.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.out.is_empty() {
            os.write_string(2, &self.out)?;
        }
        if self.bytes != 0 {
            os.write_int32(10, self.bytes)?;
        }
        if self.total != 0 {
            os.write_int32(11, self.total)?;
        }
        if self.mode != EncryptMode::DEFAULT_ENCRYPT {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.mode))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecryptFileOutput {
        DecryptFileOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                "sender",
                |m: &DecryptFileOutput| { &m.sender },
                |m: &mut DecryptFileOutput| { &mut m.sender },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "out",
                |m: &DecryptFileOutput| { &m.out },
                |m: &mut DecryptFileOutput| { &mut m.out },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "bytes",
                |m: &DecryptFileOutput| { &m.bytes },
                |m: &mut DecryptFileOutput| { &mut m.bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "total",
                |m: &DecryptFileOutput| { &m.total },
                |m: &mut DecryptFileOutput| { &mut m.total },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EncryptMode>>(
                "mode",
                |m: &DecryptFileOutput| { &m.mode },
                |m: &mut DecryptFileOutput| { &mut m.mode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DecryptFileOutput>(
                "DecryptFileOutput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DecryptFileOutput {
        static instance: ::protobuf::rt::LazyV2<DecryptFileOutput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DecryptFileOutput::new)
    }
}

impl ::protobuf::Clear for DecryptFileOutput {
    fn clear(&mut self) {
        self.sender.clear();
        self.out.clear();
        self.bytes = 0;
        self.total = 0;
        self.mode = EncryptMode::DEFAULT_ENCRYPT;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecryptFileOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecryptFileOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DecryptInput {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecryptInput {
    fn default() -> &'a DecryptInput {
        <DecryptInput as ::protobuf::Message>::default_instance()
    }
}

impl DecryptInput {
    pub fn new() -> DecryptInput {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DecryptInput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecryptInput {
        DecryptInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &DecryptInput| { &m.data },
                |m: &mut DecryptInput| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DecryptInput>(
                "DecryptInput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DecryptInput {
        static instance: ::protobuf::rt::LazyV2<DecryptInput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DecryptInput::new)
    }
}

impl ::protobuf::Clear for DecryptInput {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecryptInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecryptInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DecryptOutput {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    pub sender: ::protobuf::SingularPtrField<Key>,
    pub mode: EncryptMode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecryptOutput {
    fn default() -> &'a DecryptOutput {
        <DecryptOutput as ::protobuf::Message>::default_instance()
    }
}

impl DecryptOutput {
    pub fn new() -> DecryptOutput {
        ::std::default::Default::default()
    }

    // bytes data = 1;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // .service.Key sender = 2;


    pub fn get_sender(&self) -> &Key {
        self.sender.as_ref().unwrap_or_else(|| <Key as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    pub fn has_sender(&self) -> bool {
        self.sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: Key) {
        self.sender = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut Key {
        if self.sender.is_none() {
            self.sender.set_default();
        }
        self.sender.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender(&mut self) -> Key {
        self.sender.take().unwrap_or_else(|| Key::new())
    }

    // .service.EncryptMode mode = 5;


    pub fn get_mode(&self) -> EncryptMode {
        self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode = EncryptMode::DEFAULT_ENCRYPT;
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: EncryptMode) {
        self.mode = v;
    }
}

impl ::protobuf::Message for DecryptOutput {
    fn is_initialized(&self) -> bool {
        for v in &self.sender {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sender)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if let Some(ref v) = self.sender.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.mode != EncryptMode::DEFAULT_ENCRYPT {
            my_size += ::protobuf::rt::enum_size(5, self.mode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if let Some(ref v) = self.sender.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.mode != EncryptMode::DEFAULT_ENCRYPT {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.mode))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecryptOutput {
        DecryptOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &DecryptOutput| { &m.data },
                |m: &mut DecryptOutput| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                "sender",
                |m: &DecryptOutput| { &m.sender },
                |m: &mut DecryptOutput| { &mut m.sender },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<EncryptMode>>(
                "mode",
                |m: &DecryptOutput| { &m.mode },
                |m: &mut DecryptOutput| { &mut m.mode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DecryptOutput>(
                "DecryptOutput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DecryptOutput {
        static instance: ::protobuf::rt::LazyV2<DecryptOutput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DecryptOutput::new)
    }
}

impl ::protobuf::Clear for DecryptOutput {
    fn clear(&mut self) {
        self.data.clear();
        self.sender.clear();
        self.mode = EncryptMode::DEFAULT_ENCRYPT;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecryptOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecryptOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeStatusRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuntimeStatusRequest {
    fn default() -> &'a RuntimeStatusRequest {
        <RuntimeStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl RuntimeStatusRequest {
    pub fn new() -> RuntimeStatusRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RuntimeStatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeStatusRequest {
        RuntimeStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuntimeStatusRequest>(
                "RuntimeStatusRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuntimeStatusRequest {
        static instance: ::protobuf::rt::LazyV2<RuntimeStatusRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RuntimeStatusRequest::new)
    }
}

impl ::protobuf::Clear for RuntimeStatusRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeStatusResponse {
    // message fields
    pub version: ::std::string::String,
    pub appName: ::std::string::String,
    pub exe: ::std::string::String,
    pub authStatus: AuthStatus,
    pub sync: bool,
    pub fido2: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuntimeStatusResponse {
    fn default() -> &'a RuntimeStatusResponse {
        <RuntimeStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl RuntimeStatusResponse {
    pub fn new() -> RuntimeStatusResponse {
        ::std::default::Default::default()
    }

    // string version = 1;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // string appName = 2;


    pub fn get_appName(&self) -> &str {
        &self.appName
    }
    pub fn clear_appName(&mut self) {
        self.appName.clear();
    }

    // Param is passed by value, moved
    pub fn set_appName(&mut self, v: ::std::string::String) {
        self.appName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appName(&mut self) -> &mut ::std::string::String {
        &mut self.appName
    }

    // Take field
    pub fn take_appName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.appName, ::std::string::String::new())
    }

    // string exe = 4;


    pub fn get_exe(&self) -> &str {
        &self.exe
    }
    pub fn clear_exe(&mut self) {
        self.exe.clear();
    }

    // Param is passed by value, moved
    pub fn set_exe(&mut self, v: ::std::string::String) {
        self.exe = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exe(&mut self) -> &mut ::std::string::String {
        &mut self.exe
    }

    // Take field
    pub fn take_exe(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exe, ::std::string::String::new())
    }

    // .service.AuthStatus authStatus = 5;


    pub fn get_authStatus(&self) -> AuthStatus {
        self.authStatus
    }
    pub fn clear_authStatus(&mut self) {
        self.authStatus = AuthStatus::AUTH_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_authStatus(&mut self, v: AuthStatus) {
        self.authStatus = v;
    }

    // bool sync = 6;


    pub fn get_sync(&self) -> bool {
        self.sync
    }
    pub fn clear_sync(&mut self) {
        self.sync = false;
    }

    // Param is passed by value, moved
    pub fn set_sync(&mut self, v: bool) {
        self.sync = v;
    }

    // bool fido2 = 20;


    pub fn get_fido2(&self) -> bool {
        self.fido2
    }
    pub fn clear_fido2(&mut self) {
        self.fido2 = false;
    }

    // Param is passed by value, moved
    pub fn set_fido2(&mut self, v: bool) {
        self.fido2 = v;
    }
}

impl ::protobuf::Message for RuntimeStatusResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.appName)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.exe)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.authStatus, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sync = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fido2 = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version);
        }
        if !self.appName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.appName);
        }
        if !self.exe.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.exe);
        }
        if self.authStatus != AuthStatus::AUTH_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(5, self.authStatus);
        }
        if self.sync != false {
            my_size += 2;
        }
        if self.fido2 != false {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.version.is_empty() {
            os.write_string(1, &self.version)?;
        }
        if !self.appName.is_empty() {
            os.write_string(2, &self.appName)?;
        }
        if !self.exe.is_empty() {
            os.write_string(4, &self.exe)?;
        }
        if self.authStatus != AuthStatus::AUTH_UNKNOWN {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.authStatus))?;
        }
        if self.sync != false {
            os.write_bool(6, self.sync)?;
        }
        if self.fido2 != false {
            os.write_bool(20, self.fido2)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeStatusResponse {
        RuntimeStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &RuntimeStatusResponse| { &m.version },
                |m: &mut RuntimeStatusResponse| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "appName",
                |m: &RuntimeStatusResponse| { &m.appName },
                |m: &mut RuntimeStatusResponse| { &mut m.appName },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "exe",
                |m: &RuntimeStatusResponse| { &m.exe },
                |m: &mut RuntimeStatusResponse| { &mut m.exe },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AuthStatus>>(
                "authStatus",
                |m: &RuntimeStatusResponse| { &m.authStatus },
                |m: &mut RuntimeStatusResponse| { &mut m.authStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "sync",
                |m: &RuntimeStatusResponse| { &m.sync },
                |m: &mut RuntimeStatusResponse| { &mut m.sync },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fido2",
                |m: &RuntimeStatusResponse| { &m.fido2 },
                |m: &mut RuntimeStatusResponse| { &mut m.fido2 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuntimeStatusResponse>(
                "RuntimeStatusResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuntimeStatusResponse {
        static instance: ::protobuf::rt::LazyV2<RuntimeStatusResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RuntimeStatusResponse::new)
    }
}

impl ::protobuf::Clear for RuntimeStatusResponse {
    fn clear(&mut self) {
        self.version.clear();
        self.appName.clear();
        self.exe.clear();
        self.authStatus = AuthStatus::AUTH_UNKNOWN;
        self.sync = false;
        self.fido2 = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthSetupRequest {
    // message fields
    pub secret: ::std::string::String,
    pub field_type: AuthType,
    pub device: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthSetupRequest {
    fn default() -> &'a AuthSetupRequest {
        <AuthSetupRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthSetupRequest {
    pub fn new() -> AuthSetupRequest {
        ::std::default::Default::default()
    }

    // string secret = 1;


    pub fn get_secret(&self) -> &str {
        &self.secret
    }
    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: ::std::string::String) {
        self.secret = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret(&mut self) -> &mut ::std::string::String {
        &mut self.secret
    }

    // Take field
    pub fn take_secret(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.secret, ::std::string::String::new())
    }

    // .service.AuthType type = 2;


    pub fn get_field_type(&self) -> AuthType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = AuthType::UNKNOWN_AUTH;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: AuthType) {
        self.field_type = v;
    }

    // string device = 5;


    pub fn get_device(&self) -> &str {
        &self.device
    }
    pub fn clear_device(&mut self) {
        self.device.clear();
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: ::std::string::String) {
        self.device = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut ::std::string::String {
        &mut self.device
    }

    // Take field
    pub fn take_device(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthSetupRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.secret)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.secret.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.secret);
        }
        if self.field_type != AuthType::UNKNOWN_AUTH {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        if !self.device.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.device);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.secret.is_empty() {
            os.write_string(1, &self.secret)?;
        }
        if self.field_type != AuthType::UNKNOWN_AUTH {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if !self.device.is_empty() {
            os.write_string(5, &self.device)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthSetupRequest {
        AuthSetupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "secret",
                |m: &AuthSetupRequest| { &m.secret },
                |m: &mut AuthSetupRequest| { &mut m.secret },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AuthType>>(
                "type",
                |m: &AuthSetupRequest| { &m.field_type },
                |m: &mut AuthSetupRequest| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device",
                |m: &AuthSetupRequest| { &m.device },
                |m: &mut AuthSetupRequest| { &mut m.device },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthSetupRequest>(
                "AuthSetupRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthSetupRequest {
        static instance: ::protobuf::rt::LazyV2<AuthSetupRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthSetupRequest::new)
    }
}

impl ::protobuf::Clear for AuthSetupRequest {
    fn clear(&mut self) {
        self.secret.clear();
        self.field_type = AuthType::UNKNOWN_AUTH;
        self.device.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthSetupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthSetupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthSetupResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthSetupResponse {
    fn default() -> &'a AuthSetupResponse {
        <AuthSetupResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthSetupResponse {
    pub fn new() -> AuthSetupResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AuthSetupResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthSetupResponse {
        AuthSetupResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthSetupResponse>(
                "AuthSetupResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthSetupResponse {
        static instance: ::protobuf::rt::LazyV2<AuthSetupResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthSetupResponse::new)
    }
}

impl ::protobuf::Clear for AuthSetupResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthSetupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthSetupResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthVaultRequest {
    // message fields
    pub phrase: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthVaultRequest {
    fn default() -> &'a AuthVaultRequest {
        <AuthVaultRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthVaultRequest {
    pub fn new() -> AuthVaultRequest {
        ::std::default::Default::default()
    }

    // string phrase = 1;


    pub fn get_phrase(&self) -> &str {
        &self.phrase
    }
    pub fn clear_phrase(&mut self) {
        self.phrase.clear();
    }

    // Param is passed by value, moved
    pub fn set_phrase(&mut self, v: ::std::string::String) {
        self.phrase = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phrase(&mut self) -> &mut ::std::string::String {
        &mut self.phrase
    }

    // Take field
    pub fn take_phrase(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.phrase, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthVaultRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.phrase)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.phrase.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.phrase);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.phrase.is_empty() {
            os.write_string(1, &self.phrase)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthVaultRequest {
        AuthVaultRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "phrase",
                |m: &AuthVaultRequest| { &m.phrase },
                |m: &mut AuthVaultRequest| { &mut m.phrase },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthVaultRequest>(
                "AuthVaultRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthVaultRequest {
        static instance: ::protobuf::rt::LazyV2<AuthVaultRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthVaultRequest::new)
    }
}

impl ::protobuf::Clear for AuthVaultRequest {
    fn clear(&mut self) {
        self.phrase.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthVaultRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthVaultRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthVaultResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthVaultResponse {
    fn default() -> &'a AuthVaultResponse {
        <AuthVaultResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthVaultResponse {
    pub fn new() -> AuthVaultResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AuthVaultResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthVaultResponse {
        AuthVaultResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthVaultResponse>(
                "AuthVaultResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthVaultResponse {
        static instance: ::protobuf::rt::LazyV2<AuthVaultResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthVaultResponse::new)
    }
}

impl ::protobuf::Clear for AuthVaultResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthVaultResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthVaultResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUnlockRequest {
    // message fields
    pub secret: ::std::string::String,
    pub field_type: AuthType,
    pub client: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUnlockRequest {
    fn default() -> &'a AuthUnlockRequest {
        <AuthUnlockRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthUnlockRequest {
    pub fn new() -> AuthUnlockRequest {
        ::std::default::Default::default()
    }

    // string secret = 1;


    pub fn get_secret(&self) -> &str {
        &self.secret
    }
    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: ::std::string::String) {
        self.secret = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret(&mut self) -> &mut ::std::string::String {
        &mut self.secret
    }

    // Take field
    pub fn take_secret(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.secret, ::std::string::String::new())
    }

    // .service.AuthType type = 2;


    pub fn get_field_type(&self) -> AuthType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = AuthType::UNKNOWN_AUTH;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: AuthType) {
        self.field_type = v;
    }

    // string client = 6;


    pub fn get_client(&self) -> &str {
        &self.client
    }
    pub fn clear_client(&mut self) {
        self.client.clear();
    }

    // Param is passed by value, moved
    pub fn set_client(&mut self, v: ::std::string::String) {
        self.client = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client(&mut self) -> &mut ::std::string::String {
        &mut self.client
    }

    // Take field
    pub fn take_client(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthUnlockRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.secret)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.secret.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.secret);
        }
        if self.field_type != AuthType::UNKNOWN_AUTH {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        if !self.client.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.client);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.secret.is_empty() {
            os.write_string(1, &self.secret)?;
        }
        if self.field_type != AuthType::UNKNOWN_AUTH {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if !self.client.is_empty() {
            os.write_string(6, &self.client)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUnlockRequest {
        AuthUnlockRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "secret",
                |m: &AuthUnlockRequest| { &m.secret },
                |m: &mut AuthUnlockRequest| { &mut m.secret },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AuthType>>(
                "type",
                |m: &AuthUnlockRequest| { &m.field_type },
                |m: &mut AuthUnlockRequest| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client",
                |m: &AuthUnlockRequest| { &m.client },
                |m: &mut AuthUnlockRequest| { &mut m.client },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthUnlockRequest>(
                "AuthUnlockRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthUnlockRequest {
        static instance: ::protobuf::rt::LazyV2<AuthUnlockRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthUnlockRequest::new)
    }
}

impl ::protobuf::Clear for AuthUnlockRequest {
    fn clear(&mut self) {
        self.secret.clear();
        self.field_type = AuthType::UNKNOWN_AUTH;
        self.client.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUnlockRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUnlockRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthUnlockResponse {
    // message fields
    pub authToken: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthUnlockResponse {
    fn default() -> &'a AuthUnlockResponse {
        <AuthUnlockResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthUnlockResponse {
    pub fn new() -> AuthUnlockResponse {
        ::std::default::Default::default()
    }

    // string authToken = 1;


    pub fn get_authToken(&self) -> &str {
        &self.authToken
    }
    pub fn clear_authToken(&mut self) {
        self.authToken.clear();
    }

    // Param is passed by value, moved
    pub fn set_authToken(&mut self, v: ::std::string::String) {
        self.authToken = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authToken(&mut self) -> &mut ::std::string::String {
        &mut self.authToken
    }

    // Take field
    pub fn take_authToken(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.authToken, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthUnlockResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.authToken)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.authToken.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.authToken);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.authToken.is_empty() {
            os.write_string(1, &self.authToken)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthUnlockResponse {
        AuthUnlockResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "authToken",
                |m: &AuthUnlockResponse| { &m.authToken },
                |m: &mut AuthUnlockResponse| { &mut m.authToken },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthUnlockResponse>(
                "AuthUnlockResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthUnlockResponse {
        static instance: ::protobuf::rt::LazyV2<AuthUnlockResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthUnlockResponse::new)
    }
}

impl ::protobuf::Clear for AuthUnlockResponse {
    fn clear(&mut self) {
        self.authToken.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthUnlockResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthUnlockResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthProvisionRequest {
    // message fields
    pub secret: ::std::string::String,
    pub field_type: AuthType,
    pub device: ::std::string::String,
    pub generate: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthProvisionRequest {
    fn default() -> &'a AuthProvisionRequest {
        <AuthProvisionRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthProvisionRequest {
    pub fn new() -> AuthProvisionRequest {
        ::std::default::Default::default()
    }

    // string secret = 1;


    pub fn get_secret(&self) -> &str {
        &self.secret
    }
    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: ::std::string::String) {
        self.secret = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret(&mut self) -> &mut ::std::string::String {
        &mut self.secret
    }

    // Take field
    pub fn take_secret(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.secret, ::std::string::String::new())
    }

    // .service.AuthType type = 2;


    pub fn get_field_type(&self) -> AuthType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = AuthType::UNKNOWN_AUTH;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: AuthType) {
        self.field_type = v;
    }

    // string device = 5;


    pub fn get_device(&self) -> &str {
        &self.device
    }
    pub fn clear_device(&mut self) {
        self.device.clear();
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: ::std::string::String) {
        self.device = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut ::std::string::String {
        &mut self.device
    }

    // Take field
    pub fn take_device(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device, ::std::string::String::new())
    }

    // bool generate = 7;


    pub fn get_generate(&self) -> bool {
        self.generate
    }
    pub fn clear_generate(&mut self) {
        self.generate = false;
    }

    // Param is passed by value, moved
    pub fn set_generate(&mut self, v: bool) {
        self.generate = v;
    }
}

impl ::protobuf::Message for AuthProvisionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.secret)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.generate = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.secret.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.secret);
        }
        if self.field_type != AuthType::UNKNOWN_AUTH {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        if !self.device.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.device);
        }
        if self.generate != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.secret.is_empty() {
            os.write_string(1, &self.secret)?;
        }
        if self.field_type != AuthType::UNKNOWN_AUTH {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if !self.device.is_empty() {
            os.write_string(5, &self.device)?;
        }
        if self.generate != false {
            os.write_bool(7, self.generate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthProvisionRequest {
        AuthProvisionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "secret",
                |m: &AuthProvisionRequest| { &m.secret },
                |m: &mut AuthProvisionRequest| { &mut m.secret },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AuthType>>(
                "type",
                |m: &AuthProvisionRequest| { &m.field_type },
                |m: &mut AuthProvisionRequest| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device",
                |m: &AuthProvisionRequest| { &m.device },
                |m: &mut AuthProvisionRequest| { &mut m.device },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "generate",
                |m: &AuthProvisionRequest| { &m.generate },
                |m: &mut AuthProvisionRequest| { &mut m.generate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthProvisionRequest>(
                "AuthProvisionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthProvisionRequest {
        static instance: ::protobuf::rt::LazyV2<AuthProvisionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthProvisionRequest::new)
    }
}

impl ::protobuf::Clear for AuthProvisionRequest {
    fn clear(&mut self) {
        self.secret.clear();
        self.field_type = AuthType::UNKNOWN_AUTH;
        self.device.clear();
        self.generate = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthProvisionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthProvisionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthProvisionResponse {
    // message fields
    pub provision: ::protobuf::SingularPtrField<AuthProvision>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthProvisionResponse {
    fn default() -> &'a AuthProvisionResponse {
        <AuthProvisionResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthProvisionResponse {
    pub fn new() -> AuthProvisionResponse {
        ::std::default::Default::default()
    }

    // .service.AuthProvision provision = 1;


    pub fn get_provision(&self) -> &AuthProvision {
        self.provision.as_ref().unwrap_or_else(|| <AuthProvision as ::protobuf::Message>::default_instance())
    }
    pub fn clear_provision(&mut self) {
        self.provision.clear();
    }

    pub fn has_provision(&self) -> bool {
        self.provision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_provision(&mut self, v: AuthProvision) {
        self.provision = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_provision(&mut self) -> &mut AuthProvision {
        if self.provision.is_none() {
            self.provision.set_default();
        }
        self.provision.as_mut().unwrap()
    }

    // Take field
    pub fn take_provision(&mut self) -> AuthProvision {
        self.provision.take().unwrap_or_else(|| AuthProvision::new())
    }
}

impl ::protobuf::Message for AuthProvisionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.provision {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.provision)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.provision.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.provision.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthProvisionResponse {
        AuthProvisionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AuthProvision>>(
                "provision",
                |m: &AuthProvisionResponse| { &m.provision },
                |m: &mut AuthProvisionResponse| { &mut m.provision },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthProvisionResponse>(
                "AuthProvisionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthProvisionResponse {
        static instance: ::protobuf::rt::LazyV2<AuthProvisionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthProvisionResponse::new)
    }
}

impl ::protobuf::Clear for AuthProvisionResponse {
    fn clear(&mut self) {
        self.provision.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthProvisionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthProvisionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthDeprovisionRequest {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthDeprovisionRequest {
    fn default() -> &'a AuthDeprovisionRequest {
        <AuthDeprovisionRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthDeprovisionRequest {
    pub fn new() -> AuthDeprovisionRequest {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthDeprovisionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthDeprovisionRequest {
        AuthDeprovisionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &AuthDeprovisionRequest| { &m.id },
                |m: &mut AuthDeprovisionRequest| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthDeprovisionRequest>(
                "AuthDeprovisionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthDeprovisionRequest {
        static instance: ::protobuf::rt::LazyV2<AuthDeprovisionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthDeprovisionRequest::new)
    }
}

impl ::protobuf::Clear for AuthDeprovisionRequest {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthDeprovisionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthDeprovisionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthDeprovisionResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthDeprovisionResponse {
    fn default() -> &'a AuthDeprovisionResponse {
        <AuthDeprovisionResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthDeprovisionResponse {
    pub fn new() -> AuthDeprovisionResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AuthDeprovisionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthDeprovisionResponse {
        AuthDeprovisionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthDeprovisionResponse>(
                "AuthDeprovisionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthDeprovisionResponse {
        static instance: ::protobuf::rt::LazyV2<AuthDeprovisionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthDeprovisionResponse::new)
    }
}

impl ::protobuf::Clear for AuthDeprovisionResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthDeprovisionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthDeprovisionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthPasswordChangeRequest {
    // message fields
    pub old: ::std::string::String,
    pub new: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthPasswordChangeRequest {
    fn default() -> &'a AuthPasswordChangeRequest {
        <AuthPasswordChangeRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthPasswordChangeRequest {
    pub fn new() -> AuthPasswordChangeRequest {
        ::std::default::Default::default()
    }

    // string old = 1;


    pub fn get_old(&self) -> &str {
        &self.old
    }
    pub fn clear_old(&mut self) {
        self.old.clear();
    }

    // Param is passed by value, moved
    pub fn set_old(&mut self, v: ::std::string::String) {
        self.old = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_old(&mut self) -> &mut ::std::string::String {
        &mut self.old
    }

    // Take field
    pub fn take_old(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.old, ::std::string::String::new())
    }

    // string new = 2;


    pub fn get_new(&self) -> &str {
        &self.new
    }
    pub fn clear_new(&mut self) {
        self.new.clear();
    }

    // Param is passed by value, moved
    pub fn set_new(&mut self, v: ::std::string::String) {
        self.new = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_new(&mut self) -> &mut ::std::string::String {
        &mut self.new
    }

    // Take field
    pub fn take_new(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.new, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthPasswordChangeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.old)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.new)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.old.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.old);
        }
        if !self.new.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.new);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.old.is_empty() {
            os.write_string(1, &self.old)?;
        }
        if !self.new.is_empty() {
            os.write_string(2, &self.new)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthPasswordChangeRequest {
        AuthPasswordChangeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "old",
                |m: &AuthPasswordChangeRequest| { &m.old },
                |m: &mut AuthPasswordChangeRequest| { &mut m.old },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "new",
                |m: &AuthPasswordChangeRequest| { &m.new },
                |m: &mut AuthPasswordChangeRequest| { &mut m.new },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthPasswordChangeRequest>(
                "AuthPasswordChangeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthPasswordChangeRequest {
        static instance: ::protobuf::rt::LazyV2<AuthPasswordChangeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthPasswordChangeRequest::new)
    }
}

impl ::protobuf::Clear for AuthPasswordChangeRequest {
    fn clear(&mut self) {
        self.old.clear();
        self.new.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthPasswordChangeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthPasswordChangeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthPasswordChangeResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthPasswordChangeResponse {
    fn default() -> &'a AuthPasswordChangeResponse {
        <AuthPasswordChangeResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthPasswordChangeResponse {
    pub fn new() -> AuthPasswordChangeResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AuthPasswordChangeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthPasswordChangeResponse {
        AuthPasswordChangeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthPasswordChangeResponse>(
                "AuthPasswordChangeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthPasswordChangeResponse {
        static instance: ::protobuf::rt::LazyV2<AuthPasswordChangeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthPasswordChangeResponse::new)
    }
}

impl ::protobuf::Clear for AuthPasswordChangeResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthPasswordChangeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthPasswordChangeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthProvision {
    // message fields
    pub id: ::std::string::String,
    pub field_type: AuthType,
    pub createdAt: i64,
    pub aaguid: ::std::string::String,
    pub noPin: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthProvision {
    fn default() -> &'a AuthProvision {
        <AuthProvision as ::protobuf::Message>::default_instance()
    }
}

impl AuthProvision {
    pub fn new() -> AuthProvision {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .service.AuthType type = 2;


    pub fn get_field_type(&self) -> AuthType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = AuthType::UNKNOWN_AUTH;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: AuthType) {
        self.field_type = v;
    }

    // int64 createdAt = 3;


    pub fn get_createdAt(&self) -> i64 {
        self.createdAt
    }
    pub fn clear_createdAt(&mut self) {
        self.createdAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_createdAt(&mut self, v: i64) {
        self.createdAt = v;
    }

    // string aaguid = 100;


    pub fn get_aaguid(&self) -> &str {
        &self.aaguid
    }
    pub fn clear_aaguid(&mut self) {
        self.aaguid.clear();
    }

    // Param is passed by value, moved
    pub fn set_aaguid(&mut self, v: ::std::string::String) {
        self.aaguid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aaguid(&mut self) -> &mut ::std::string::String {
        &mut self.aaguid
    }

    // Take field
    pub fn take_aaguid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.aaguid, ::std::string::String::new())
    }

    // bool noPin = 101;


    pub fn get_noPin(&self) -> bool {
        self.noPin
    }
    pub fn clear_noPin(&mut self) {
        self.noPin = false;
    }

    // Param is passed by value, moved
    pub fn set_noPin(&mut self, v: bool) {
        self.noPin = v;
    }
}

impl ::protobuf::Message for AuthProvision {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.createdAt = tmp;
                },
                100 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.aaguid)?;
                },
                101 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.noPin = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.field_type != AuthType::UNKNOWN_AUTH {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        if self.createdAt != 0 {
            my_size += ::protobuf::rt::value_size(3, self.createdAt, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.aaguid.is_empty() {
            my_size += ::protobuf::rt::string_size(100, &self.aaguid);
        }
        if self.noPin != false {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.field_type != AuthType::UNKNOWN_AUTH {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.createdAt != 0 {
            os.write_int64(3, self.createdAt)?;
        }
        if !self.aaguid.is_empty() {
            os.write_string(100, &self.aaguid)?;
        }
        if self.noPin != false {
            os.write_bool(101, self.noPin)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthProvision {
        AuthProvision::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &AuthProvision| { &m.id },
                |m: &mut AuthProvision| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<AuthType>>(
                "type",
                |m: &AuthProvision| { &m.field_type },
                |m: &mut AuthProvision| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "createdAt",
                |m: &AuthProvision| { &m.createdAt },
                |m: &mut AuthProvision| { &mut m.createdAt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "aaguid",
                |m: &AuthProvision| { &m.aaguid },
                |m: &mut AuthProvision| { &mut m.aaguid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "noPin",
                |m: &AuthProvision| { &m.noPin },
                |m: &mut AuthProvision| { &mut m.noPin },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthProvision>(
                "AuthProvision",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthProvision {
        static instance: ::protobuf::rt::LazyV2<AuthProvision> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthProvision::new)
    }
}

impl ::protobuf::Clear for AuthProvision {
    fn clear(&mut self) {
        self.id.clear();
        self.field_type = AuthType::UNKNOWN_AUTH;
        self.createdAt = 0;
        self.aaguid.clear();
        self.noPin = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthProvision {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthProvision {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthProvisionsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthProvisionsRequest {
    fn default() -> &'a AuthProvisionsRequest {
        <AuthProvisionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthProvisionsRequest {
    pub fn new() -> AuthProvisionsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AuthProvisionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthProvisionsRequest {
        AuthProvisionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthProvisionsRequest>(
                "AuthProvisionsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthProvisionsRequest {
        static instance: ::protobuf::rt::LazyV2<AuthProvisionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthProvisionsRequest::new)
    }
}

impl ::protobuf::Clear for AuthProvisionsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthProvisionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthProvisionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthProvisionsResponse {
    // message fields
    pub provisions: ::protobuf::RepeatedField<AuthProvision>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthProvisionsResponse {
    fn default() -> &'a AuthProvisionsResponse {
        <AuthProvisionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthProvisionsResponse {
    pub fn new() -> AuthProvisionsResponse {
        ::std::default::Default::default()
    }

    // repeated .service.AuthProvision provisions = 1;


    pub fn get_provisions(&self) -> &[AuthProvision] {
        &self.provisions
    }
    pub fn clear_provisions(&mut self) {
        self.provisions.clear();
    }

    // Param is passed by value, moved
    pub fn set_provisions(&mut self, v: ::protobuf::RepeatedField<AuthProvision>) {
        self.provisions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_provisions(&mut self) -> &mut ::protobuf::RepeatedField<AuthProvision> {
        &mut self.provisions
    }

    // Take field
    pub fn take_provisions(&mut self) -> ::protobuf::RepeatedField<AuthProvision> {
        ::std::mem::replace(&mut self.provisions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AuthProvisionsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.provisions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.provisions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.provisions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.provisions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthProvisionsResponse {
        AuthProvisionsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AuthProvision>>(
                "provisions",
                |m: &AuthProvisionsResponse| { &m.provisions },
                |m: &mut AuthProvisionsResponse| { &mut m.provisions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthProvisionsResponse>(
                "AuthProvisionsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthProvisionsResponse {
        static instance: ::protobuf::rt::LazyV2<AuthProvisionsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthProvisionsResponse::new)
    }
}

impl ::protobuf::Clear for AuthProvisionsResponse {
    fn clear(&mut self) {
        self.provisions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthProvisionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthProvisionsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthLockRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthLockRequest {
    fn default() -> &'a AuthLockRequest {
        <AuthLockRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthLockRequest {
    pub fn new() -> AuthLockRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AuthLockRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthLockRequest {
        AuthLockRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthLockRequest>(
                "AuthLockRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthLockRequest {
        static instance: ::protobuf::rt::LazyV2<AuthLockRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthLockRequest::new)
    }
}

impl ::protobuf::Clear for AuthLockRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthLockRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthLockRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthLockResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthLockResponse {
    fn default() -> &'a AuthLockResponse {
        <AuthLockResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthLockResponse {
    pub fn new() -> AuthLockResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AuthLockResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthLockResponse {
        AuthLockResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthLockResponse>(
                "AuthLockResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthLockResponse {
        static instance: ::protobuf::rt::LazyV2<AuthLockResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthLockResponse::new)
    }
}

impl ::protobuf::Clear for AuthLockResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthLockResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthLockResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthResetRequest {
    // message fields
    pub appName: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthResetRequest {
    fn default() -> &'a AuthResetRequest {
        <AuthResetRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthResetRequest {
    pub fn new() -> AuthResetRequest {
        ::std::default::Default::default()
    }

    // string appName = 1;


    pub fn get_appName(&self) -> &str {
        &self.appName
    }
    pub fn clear_appName(&mut self) {
        self.appName.clear();
    }

    // Param is passed by value, moved
    pub fn set_appName(&mut self, v: ::std::string::String) {
        self.appName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appName(&mut self) -> &mut ::std::string::String {
        &mut self.appName
    }

    // Take field
    pub fn take_appName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.appName, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthResetRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.appName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.appName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.appName);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.appName.is_empty() {
            os.write_string(1, &self.appName)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthResetRequest {
        AuthResetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "appName",
                |m: &AuthResetRequest| { &m.appName },
                |m: &mut AuthResetRequest| { &mut m.appName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthResetRequest>(
                "AuthResetRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthResetRequest {
        static instance: ::protobuf::rt::LazyV2<AuthResetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthResetRequest::new)
    }
}

impl ::protobuf::Clear for AuthResetRequest {
    fn clear(&mut self) {
        self.appName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthResetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthResetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthResetResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthResetResponse {
    fn default() -> &'a AuthResetResponse {
        <AuthResetResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthResetResponse {
    pub fn new() -> AuthResetResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AuthResetResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthResetResponse {
        AuthResetResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthResetResponse>(
                "AuthResetResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthResetResponse {
        static instance: ::protobuf::rt::LazyV2<AuthResetResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthResetResponse::new)
    }
}

impl ::protobuf::Clear for AuthResetResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthResetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthResetResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRecoverRequest {
    // message fields
    pub paperKey: ::std::string::String,
    pub newPassword: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRecoverRequest {
    fn default() -> &'a AuthRecoverRequest {
        <AuthRecoverRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthRecoverRequest {
    pub fn new() -> AuthRecoverRequest {
        ::std::default::Default::default()
    }

    // string paperKey = 1;


    pub fn get_paperKey(&self) -> &str {
        &self.paperKey
    }
    pub fn clear_paperKey(&mut self) {
        self.paperKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_paperKey(&mut self, v: ::std::string::String) {
        self.paperKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paperKey(&mut self) -> &mut ::std::string::String {
        &mut self.paperKey
    }

    // Take field
    pub fn take_paperKey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.paperKey, ::std::string::String::new())
    }

    // string newPassword = 2;


    pub fn get_newPassword(&self) -> &str {
        &self.newPassword
    }
    pub fn clear_newPassword(&mut self) {
        self.newPassword.clear();
    }

    // Param is passed by value, moved
    pub fn set_newPassword(&mut self, v: ::std::string::String) {
        self.newPassword = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_newPassword(&mut self) -> &mut ::std::string::String {
        &mut self.newPassword
    }

    // Take field
    pub fn take_newPassword(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.newPassword, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthRecoverRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.paperKey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.newPassword)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.paperKey.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.paperKey);
        }
        if !self.newPassword.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.newPassword);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.paperKey.is_empty() {
            os.write_string(1, &self.paperKey)?;
        }
        if !self.newPassword.is_empty() {
            os.write_string(2, &self.newPassword)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRecoverRequest {
        AuthRecoverRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "paperKey",
                |m: &AuthRecoverRequest| { &m.paperKey },
                |m: &mut AuthRecoverRequest| { &mut m.paperKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "newPassword",
                |m: &AuthRecoverRequest| { &m.newPassword },
                |m: &mut AuthRecoverRequest| { &mut m.newPassword },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthRecoverRequest>(
                "AuthRecoverRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthRecoverRequest {
        static instance: ::protobuf::rt::LazyV2<AuthRecoverRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthRecoverRequest::new)
    }
}

impl ::protobuf::Clear for AuthRecoverRequest {
    fn clear(&mut self) {
        self.paperKey.clear();
        self.newPassword.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRecoverRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRecoverRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthRecoverResponse {
    // message fields
    pub authToken: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthRecoverResponse {
    fn default() -> &'a AuthRecoverResponse {
        <AuthRecoverResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthRecoverResponse {
    pub fn new() -> AuthRecoverResponse {
        ::std::default::Default::default()
    }

    // string authToken = 1;


    pub fn get_authToken(&self) -> &str {
        &self.authToken
    }
    pub fn clear_authToken(&mut self) {
        self.authToken.clear();
    }

    // Param is passed by value, moved
    pub fn set_authToken(&mut self, v: ::std::string::String) {
        self.authToken = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authToken(&mut self) -> &mut ::std::string::String {
        &mut self.authToken
    }

    // Take field
    pub fn take_authToken(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.authToken, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthRecoverResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.authToken)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.authToken.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.authToken);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.authToken.is_empty() {
            os.write_string(1, &self.authToken)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthRecoverResponse {
        AuthRecoverResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "authToken",
                |m: &AuthRecoverResponse| { &m.authToken },
                |m: &mut AuthRecoverResponse| { &mut m.authToken },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthRecoverResponse>(
                "AuthRecoverResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthRecoverResponse {
        static instance: ::protobuf::rt::LazyV2<AuthRecoverResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthRecoverResponse::new)
    }
}

impl ::protobuf::Clear for AuthRecoverResponse {
    fn clear(&mut self) {
        self.authToken.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthRecoverResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthRecoverResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyGenerateRequest {
    // message fields
    pub field_type: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyGenerateRequest {
    fn default() -> &'a KeyGenerateRequest {
        <KeyGenerateRequest as ::protobuf::Message>::default_instance()
    }
}

impl KeyGenerateRequest {
    pub fn new() -> KeyGenerateRequest {
        ::std::default::Default::default()
    }

    // string type = 1;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }
}

impl ::protobuf::Message for KeyGenerateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_type.is_empty() {
            os.write_string(1, &self.field_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyGenerateRequest {
        KeyGenerateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &KeyGenerateRequest| { &m.field_type },
                |m: &mut KeyGenerateRequest| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyGenerateRequest>(
                "KeyGenerateRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyGenerateRequest {
        static instance: ::protobuf::rt::LazyV2<KeyGenerateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyGenerateRequest::new)
    }
}

impl ::protobuf::Clear for KeyGenerateRequest {
    fn clear(&mut self) {
        self.field_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyGenerateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyGenerateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyGenerateResponse {
    // message fields
    pub kid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyGenerateResponse {
    fn default() -> &'a KeyGenerateResponse {
        <KeyGenerateResponse as ::protobuf::Message>::default_instance()
    }
}

impl KeyGenerateResponse {
    pub fn new() -> KeyGenerateResponse {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for KeyGenerateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyGenerateResponse {
        KeyGenerateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kid",
                |m: &KeyGenerateResponse| { &m.kid },
                |m: &mut KeyGenerateResponse| { &mut m.kid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyGenerateResponse>(
                "KeyGenerateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyGenerateResponse {
        static instance: ::protobuf::rt::LazyV2<KeyGenerateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyGenerateResponse::new)
    }
}

impl ::protobuf::Clear for KeyGenerateResponse {
    fn clear(&mut self) {
        self.kid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyGenerateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyGenerateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserServiceRequest {
    // message fields
    pub kid: ::std::string::String,
    pub service: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserServiceRequest {
    fn default() -> &'a UserServiceRequest {
        <UserServiceRequest as ::protobuf::Message>::default_instance()
    }
}

impl UserServiceRequest {
    pub fn new() -> UserServiceRequest {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // string service = 2;


    pub fn get_service(&self) -> &str {
        &self.service
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UserServiceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.service);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        if !self.service.is_empty() {
            os.write_string(2, &self.service)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserServiceRequest {
        UserServiceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kid",
                |m: &UserServiceRequest| { &m.kid },
                |m: &mut UserServiceRequest| { &mut m.kid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service",
                |m: &UserServiceRequest| { &m.service },
                |m: &mut UserServiceRequest| { &mut m.service },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserServiceRequest>(
                "UserServiceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserServiceRequest {
        static instance: ::protobuf::rt::LazyV2<UserServiceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserServiceRequest::new)
    }
}

impl ::protobuf::Clear for UserServiceRequest {
    fn clear(&mut self) {
        self.kid.clear();
        self.service.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserServiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserServiceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserServiceResponse {
    // message fields
    pub service: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserServiceResponse {
    fn default() -> &'a UserServiceResponse {
        <UserServiceResponse as ::protobuf::Message>::default_instance()
    }
}

impl UserServiceResponse {
    pub fn new() -> UserServiceResponse {
        ::std::default::Default::default()
    }

    // string service = 1;


    pub fn get_service(&self) -> &str {
        &self.service
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UserServiceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service.is_empty() {
            os.write_string(1, &self.service)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserServiceResponse {
        UserServiceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service",
                |m: &UserServiceResponse| { &m.service },
                |m: &mut UserServiceResponse| { &mut m.service },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserServiceResponse>(
                "UserServiceResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserServiceResponse {
        static instance: ::protobuf::rt::LazyV2<UserServiceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserServiceResponse::new)
    }
}

impl ::protobuf::Clear for UserServiceResponse {
    fn clear(&mut self) {
        self.service.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserServiceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserServiceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserSignRequest {
    // message fields
    pub kid: ::std::string::String,
    pub service: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserSignRequest {
    fn default() -> &'a UserSignRequest {
        <UserSignRequest as ::protobuf::Message>::default_instance()
    }
}

impl UserSignRequest {
    pub fn new() -> UserSignRequest {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // string service = 2;


    pub fn get_service(&self) -> &str {
        &self.service
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UserSignRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.service);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        if !self.service.is_empty() {
            os.write_string(2, &self.service)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserSignRequest {
        UserSignRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kid",
                |m: &UserSignRequest| { &m.kid },
                |m: &mut UserSignRequest| { &mut m.kid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service",
                |m: &UserSignRequest| { &m.service },
                |m: &mut UserSignRequest| { &mut m.service },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &UserSignRequest| { &m.name },
                |m: &mut UserSignRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserSignRequest>(
                "UserSignRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserSignRequest {
        static instance: ::protobuf::rt::LazyV2<UserSignRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserSignRequest::new)
    }
}

impl ::protobuf::Clear for UserSignRequest {
    fn clear(&mut self) {
        self.kid.clear();
        self.service.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserSignRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserSignRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserSignResponse {
    // message fields
    pub message: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserSignResponse {
    fn default() -> &'a UserSignResponse {
        <UserSignResponse as ::protobuf::Message>::default_instance()
    }
}

impl UserSignResponse {
    pub fn new() -> UserSignResponse {
        ::std::default::Default::default()
    }

    // string message = 1;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UserSignResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.message);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_string(1, &self.message)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserSignResponse {
        UserSignResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &UserSignResponse| { &m.message },
                |m: &mut UserSignResponse| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &UserSignResponse| { &m.name },
                |m: &mut UserSignResponse| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserSignResponse>(
                "UserSignResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserSignResponse {
        static instance: ::protobuf::rt::LazyV2<UserSignResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserSignResponse::new)
    }
}

impl ::protobuf::Clear for UserSignResponse {
    fn clear(&mut self) {
        self.message.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserSignResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserSignResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserAddRequest {
    // message fields
    pub kid: ::std::string::String,
    pub service: ::std::string::String,
    pub name: ::std::string::String,
    pub url: ::std::string::String,
    pub local: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserAddRequest {
    fn default() -> &'a UserAddRequest {
        <UserAddRequest as ::protobuf::Message>::default_instance()
    }
}

impl UserAddRequest {
    pub fn new() -> UserAddRequest {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // string service = 2;


    pub fn get_service(&self) -> &str {
        &self.service
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string url = 4;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // bool local = 5;


    pub fn get_local(&self) -> bool {
        self.local
    }
    pub fn clear_local(&mut self) {
        self.local = false;
    }

    // Param is passed by value, moved
    pub fn set_local(&mut self, v: bool) {
        self.local = v;
    }
}

impl ::protobuf::Message for UserAddRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.local = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.service);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.url);
        }
        if self.local != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        if !self.service.is_empty() {
            os.write_string(2, &self.service)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.url.is_empty() {
            os.write_string(4, &self.url)?;
        }
        if self.local != false {
            os.write_bool(5, self.local)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserAddRequest {
        UserAddRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kid",
                |m: &UserAddRequest| { &m.kid },
                |m: &mut UserAddRequest| { &mut m.kid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service",
                |m: &UserAddRequest| { &m.service },
                |m: &mut UserAddRequest| { &mut m.service },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &UserAddRequest| { &m.name },
                |m: &mut UserAddRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &UserAddRequest| { &m.url },
                |m: &mut UserAddRequest| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "local",
                |m: &UserAddRequest| { &m.local },
                |m: &mut UserAddRequest| { &mut m.local },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserAddRequest>(
                "UserAddRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserAddRequest {
        static instance: ::protobuf::rt::LazyV2<UserAddRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserAddRequest::new)
    }
}

impl ::protobuf::Clear for UserAddRequest {
    fn clear(&mut self) {
        self.kid.clear();
        self.service.clear();
        self.name.clear();
        self.url.clear();
        self.local = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserAddRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserAddRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserAddResponse {
    // message fields
    pub user: ::protobuf::SingularPtrField<User>,
    pub statement: ::protobuf::SingularPtrField<Statement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserAddResponse {
    fn default() -> &'a UserAddResponse {
        <UserAddResponse as ::protobuf::Message>::default_instance()
    }
}

impl UserAddResponse {
    pub fn new() -> UserAddResponse {
        ::std::default::Default::default()
    }

    // .service.User user = 1;


    pub fn get_user(&self) -> &User {
        self.user.as_ref().unwrap_or_else(|| <User as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: User) {
        self.user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut User {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> User {
        self.user.take().unwrap_or_else(|| User::new())
    }

    // .service.Statement statement = 2;


    pub fn get_statement(&self) -> &Statement {
        self.statement.as_ref().unwrap_or_else(|| <Statement as ::protobuf::Message>::default_instance())
    }
    pub fn clear_statement(&mut self) {
        self.statement.clear();
    }

    pub fn has_statement(&self) -> bool {
        self.statement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statement(&mut self, v: Statement) {
        self.statement = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statement(&mut self) -> &mut Statement {
        if self.statement.is_none() {
            self.statement.set_default();
        }
        self.statement.as_mut().unwrap()
    }

    // Take field
    pub fn take_statement(&mut self) -> Statement {
        self.statement.take().unwrap_or_else(|| Statement::new())
    }
}

impl ::protobuf::Message for UserAddResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.user {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.statement {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statement)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.statement.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.statement.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserAddResponse {
        UserAddResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                "user",
                |m: &UserAddResponse| { &m.user },
                |m: &mut UserAddResponse| { &mut m.user },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Statement>>(
                "statement",
                |m: &UserAddResponse| { &m.statement },
                |m: &mut UserAddResponse| { &mut m.statement },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserAddResponse>(
                "UserAddResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserAddResponse {
        static instance: ::protobuf::rt::LazyV2<UserAddResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserAddResponse::new)
    }
}

impl ::protobuf::Clear for UserAddResponse {
    fn clear(&mut self) {
        self.user.clear();
        self.statement.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserAddResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserAddResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyExportRequest {
    // message fields
    pub kid: ::std::string::String,
    pub password: ::std::string::String,
    pub field_type: ExportType,
    pub public: bool,
    pub noPassword: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyExportRequest {
    fn default() -> &'a KeyExportRequest {
        <KeyExportRequest as ::protobuf::Message>::default_instance()
    }
}

impl KeyExportRequest {
    pub fn new() -> KeyExportRequest {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // string password = 2;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }

    // .service.ExportType type = 3;


    pub fn get_field_type(&self) -> ExportType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ExportType::DEFAULT_EXPORT_TYPE;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ExportType) {
        self.field_type = v;
    }

    // bool public = 4;


    pub fn get_public(&self) -> bool {
        self.public
    }
    pub fn clear_public(&mut self) {
        self.public = false;
    }

    // Param is passed by value, moved
    pub fn set_public(&mut self, v: bool) {
        self.public = v;
    }

    // bool noPassword = 5;


    pub fn get_noPassword(&self) -> bool {
        self.noPassword
    }
    pub fn clear_noPassword(&mut self) {
        self.noPassword = false;
    }

    // Param is passed by value, moved
    pub fn set_noPassword(&mut self, v: bool) {
        self.noPassword = v;
    }
}

impl ::protobuf::Message for KeyExportRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.public = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.noPassword = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        if self.field_type != ExportType::DEFAULT_EXPORT_TYPE {
            my_size += ::protobuf::rt::enum_size(3, self.field_type);
        }
        if self.public != false {
            my_size += 2;
        }
        if self.noPassword != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        if self.field_type != ExportType::DEFAULT_EXPORT_TYPE {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.public != false {
            os.write_bool(4, self.public)?;
        }
        if self.noPassword != false {
            os.write_bool(5, self.noPassword)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyExportRequest {
        KeyExportRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kid",
                |m: &KeyExportRequest| { &m.kid },
                |m: &mut KeyExportRequest| { &mut m.kid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "password",
                |m: &KeyExportRequest| { &m.password },
                |m: &mut KeyExportRequest| { &mut m.password },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ExportType>>(
                "type",
                |m: &KeyExportRequest| { &m.field_type },
                |m: &mut KeyExportRequest| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "public",
                |m: &KeyExportRequest| { &m.public },
                |m: &mut KeyExportRequest| { &mut m.public },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "noPassword",
                |m: &KeyExportRequest| { &m.noPassword },
                |m: &mut KeyExportRequest| { &mut m.noPassword },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyExportRequest>(
                "KeyExportRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyExportRequest {
        static instance: ::protobuf::rt::LazyV2<KeyExportRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyExportRequest::new)
    }
}

impl ::protobuf::Clear for KeyExportRequest {
    fn clear(&mut self) {
        self.kid.clear();
        self.password.clear();
        self.field_type = ExportType::DEFAULT_EXPORT_TYPE;
        self.public = false;
        self.noPassword = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyExportRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyExportRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyExportResponse {
    // message fields
    pub export: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyExportResponse {
    fn default() -> &'a KeyExportResponse {
        <KeyExportResponse as ::protobuf::Message>::default_instance()
    }
}

impl KeyExportResponse {
    pub fn new() -> KeyExportResponse {
        ::std::default::Default::default()
    }

    // bytes export = 1;


    pub fn get_export(&self) -> &[u8] {
        &self.export
    }
    pub fn clear_export(&mut self) {
        self.export.clear();
    }

    // Param is passed by value, moved
    pub fn set_export(&mut self, v: ::std::vec::Vec<u8>) {
        self.export = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_export(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.export
    }

    // Take field
    pub fn take_export(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.export, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for KeyExportResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.export)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.export.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.export);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.export.is_empty() {
            os.write_bytes(1, &self.export)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyExportResponse {
        KeyExportResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "export",
                |m: &KeyExportResponse| { &m.export },
                |m: &mut KeyExportResponse| { &mut m.export },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyExportResponse>(
                "KeyExportResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyExportResponse {
        static instance: ::protobuf::rt::LazyV2<KeyExportResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyExportResponse::new)
    }
}

impl ::protobuf::Clear for KeyExportResponse {
    fn clear(&mut self) {
        self.export.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyExportResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyExportResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyImportRequest {
    // message fields
    pub field_in: ::std::vec::Vec<u8>,
    pub password: ::std::string::String,
    pub update: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyImportRequest {
    fn default() -> &'a KeyImportRequest {
        <KeyImportRequest as ::protobuf::Message>::default_instance()
    }
}

impl KeyImportRequest {
    pub fn new() -> KeyImportRequest {
        ::std::default::Default::default()
    }

    // bytes in = 1;


    pub fn get_field_in(&self) -> &[u8] {
        &self.field_in
    }
    pub fn clear_field_in(&mut self) {
        self.field_in.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_in(&mut self, v: ::std::vec::Vec<u8>) {
        self.field_in = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_in(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.field_in
    }

    // Take field
    pub fn take_field_in(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.field_in, ::std::vec::Vec::new())
    }

    // string password = 2;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }

    // bool update = 3;


    pub fn get_update(&self) -> bool {
        self.update
    }
    pub fn clear_update(&mut self) {
        self.update = false;
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: bool) {
        self.update = v;
    }
}

impl ::protobuf::Message for KeyImportRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.field_in)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.update = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_in.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.field_in);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        if self.update != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.field_in.is_empty() {
            os.write_bytes(1, &self.field_in)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        if self.update != false {
            os.write_bool(3, self.update)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyImportRequest {
        KeyImportRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "in",
                |m: &KeyImportRequest| { &m.field_in },
                |m: &mut KeyImportRequest| { &mut m.field_in },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "password",
                |m: &KeyImportRequest| { &m.password },
                |m: &mut KeyImportRequest| { &mut m.password },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "update",
                |m: &KeyImportRequest| { &m.update },
                |m: &mut KeyImportRequest| { &mut m.update },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyImportRequest>(
                "KeyImportRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyImportRequest {
        static instance: ::protobuf::rt::LazyV2<KeyImportRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyImportRequest::new)
    }
}

impl ::protobuf::Clear for KeyImportRequest {
    fn clear(&mut self) {
        self.field_in.clear();
        self.password.clear();
        self.update = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyImportRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyImportRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyImportResponse {
    // message fields
    pub kid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyImportResponse {
    fn default() -> &'a KeyImportResponse {
        <KeyImportResponse as ::protobuf::Message>::default_instance()
    }
}

impl KeyImportResponse {
    pub fn new() -> KeyImportResponse {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for KeyImportResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyImportResponse {
        KeyImportResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kid",
                |m: &KeyImportResponse| { &m.kid },
                |m: &mut KeyImportResponse| { &mut m.kid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyImportResponse>(
                "KeyImportResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyImportResponse {
        static instance: ::protobuf::rt::LazyV2<KeyImportResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyImportResponse::new)
    }
}

impl ::protobuf::Clear for KeyImportResponse {
    fn clear(&mut self) {
        self.kid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyImportResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyImportResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyRemoveRequest {
    // message fields
    pub kid: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyRemoveRequest {
    fn default() -> &'a KeyRemoveRequest {
        <KeyRemoveRequest as ::protobuf::Message>::default_instance()
    }
}

impl KeyRemoveRequest {
    pub fn new() -> KeyRemoveRequest {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for KeyRemoveRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyRemoveRequest {
        KeyRemoveRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kid",
                |m: &KeyRemoveRequest| { &m.kid },
                |m: &mut KeyRemoveRequest| { &mut m.kid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyRemoveRequest>(
                "KeyRemoveRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyRemoveRequest {
        static instance: ::protobuf::rt::LazyV2<KeyRemoveRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyRemoveRequest::new)
    }
}

impl ::protobuf::Clear for KeyRemoveRequest {
    fn clear(&mut self) {
        self.kid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyRemoveRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyRemoveRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyRemoveResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyRemoveResponse {
    fn default() -> &'a KeyRemoveResponse {
        <KeyRemoveResponse as ::protobuf::Message>::default_instance()
    }
}

impl KeyRemoveResponse {
    pub fn new() -> KeyRemoveResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for KeyRemoveResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyRemoveResponse {
        KeyRemoveResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyRemoveResponse>(
                "KeyRemoveResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyRemoveResponse {
        static instance: ::protobuf::rt::LazyV2<KeyRemoveResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyRemoveResponse::new)
    }
}

impl ::protobuf::Clear for KeyRemoveResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyRemoveResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyRemoveResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Key {
    // message fields
    pub id: ::std::string::String,
    pub field_type: ::std::string::String,
    pub isPrivate: bool,
    pub user: ::protobuf::SingularPtrField<User>,
    pub saved: bool,
    pub sigchainLength: i32,
    pub sigchainUpdatedAt: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Key {
    fn default() -> &'a Key {
        <Key as ::protobuf::Message>::default_instance()
    }
}

impl Key {
    pub fn new() -> Key {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string type = 3;


    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    // bool isPrivate = 4;


    pub fn get_isPrivate(&self) -> bool {
        self.isPrivate
    }
    pub fn clear_isPrivate(&mut self) {
        self.isPrivate = false;
    }

    // Param is passed by value, moved
    pub fn set_isPrivate(&mut self, v: bool) {
        self.isPrivate = v;
    }

    // .service.User user = 6;


    pub fn get_user(&self) -> &User {
        self.user.as_ref().unwrap_or_else(|| <User as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: User) {
        self.user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut User {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> User {
        self.user.take().unwrap_or_else(|| User::new())
    }

    // bool saved = 10;


    pub fn get_saved(&self) -> bool {
        self.saved
    }
    pub fn clear_saved(&mut self) {
        self.saved = false;
    }

    // Param is passed by value, moved
    pub fn set_saved(&mut self, v: bool) {
        self.saved = v;
    }

    // int32 sigchainLength = 40;


    pub fn get_sigchainLength(&self) -> i32 {
        self.sigchainLength
    }
    pub fn clear_sigchainLength(&mut self) {
        self.sigchainLength = 0;
    }

    // Param is passed by value, moved
    pub fn set_sigchainLength(&mut self, v: i32) {
        self.sigchainLength = v;
    }

    // int64 sigchainUpdatedAt = 41;


    pub fn get_sigchainUpdatedAt(&self) -> i64 {
        self.sigchainUpdatedAt
    }
    pub fn clear_sigchainUpdatedAt(&mut self) {
        self.sigchainUpdatedAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_sigchainUpdatedAt(&mut self, v: i64) {
        self.sigchainUpdatedAt = v;
    }
}

impl ::protobuf::Message for Key {
    fn is_initialized(&self) -> bool {
        for v in &self.user {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isPrivate = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.saved = tmp;
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sigchainLength = tmp;
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sigchainUpdatedAt = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.field_type);
        }
        if self.isPrivate != false {
            my_size += 2;
        }
        if let Some(ref v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.saved != false {
            my_size += 2;
        }
        if self.sigchainLength != 0 {
            my_size += ::protobuf::rt::value_size(40, self.sigchainLength, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sigchainUpdatedAt != 0 {
            my_size += ::protobuf::rt::value_size(41, self.sigchainUpdatedAt, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(3, &self.field_type)?;
        }
        if self.isPrivate != false {
            os.write_bool(4, self.isPrivate)?;
        }
        if let Some(ref v) = self.user.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.saved != false {
            os.write_bool(10, self.saved)?;
        }
        if self.sigchainLength != 0 {
            os.write_int32(40, self.sigchainLength)?;
        }
        if self.sigchainUpdatedAt != 0 {
            os.write_int64(41, self.sigchainUpdatedAt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Key {
        Key::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Key| { &m.id },
                |m: &mut Key| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &Key| { &m.field_type },
                |m: &mut Key| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isPrivate",
                |m: &Key| { &m.isPrivate },
                |m: &mut Key| { &mut m.isPrivate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                "user",
                |m: &Key| { &m.user },
                |m: &mut Key| { &mut m.user },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "saved",
                |m: &Key| { &m.saved },
                |m: &mut Key| { &mut m.saved },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "sigchainLength",
                |m: &Key| { &m.sigchainLength },
                |m: &mut Key| { &mut m.sigchainLength },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "sigchainUpdatedAt",
                |m: &Key| { &m.sigchainUpdatedAt },
                |m: &mut Key| { &mut m.sigchainUpdatedAt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Key>(
                "Key",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Key {
        static instance: ::protobuf::rt::LazyV2<Key> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Key::new)
    }
}

impl ::protobuf::Clear for Key {
    fn clear(&mut self) {
        self.id.clear();
        self.field_type.clear();
        self.isPrivate = false;
        self.user.clear();
        self.saved = false;
        self.sigchainLength = 0;
        self.sigchainUpdatedAt = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Key {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Key {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyRequest {
    // message fields
    pub key: ::std::string::String,
    pub search: bool,
    pub update: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyRequest {
    fn default() -> &'a KeyRequest {
        <KeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl KeyRequest {
    pub fn new() -> KeyRequest {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // bool search = 4;


    pub fn get_search(&self) -> bool {
        self.search
    }
    pub fn clear_search(&mut self) {
        self.search = false;
    }

    // Param is passed by value, moved
    pub fn set_search(&mut self, v: bool) {
        self.search = v;
    }

    // bool update = 5;


    pub fn get_update(&self) -> bool {
        self.update
    }
    pub fn clear_update(&mut self) {
        self.update = false;
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: bool) {
        self.update = v;
    }
}

impl ::protobuf::Message for KeyRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.search = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.update = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if self.search != false {
            my_size += 2;
        }
        if self.update != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if self.search != false {
            os.write_bool(4, self.search)?;
        }
        if self.update != false {
            os.write_bool(5, self.update)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyRequest {
        KeyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &KeyRequest| { &m.key },
                |m: &mut KeyRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "search",
                |m: &KeyRequest| { &m.search },
                |m: &mut KeyRequest| { &mut m.search },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "update",
                |m: &KeyRequest| { &m.update },
                |m: &mut KeyRequest| { &mut m.update },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyRequest>(
                "KeyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyRequest {
        static instance: ::protobuf::rt::LazyV2<KeyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyRequest::new)
    }
}

impl ::protobuf::Clear for KeyRequest {
    fn clear(&mut self) {
        self.key.clear();
        self.search = false;
        self.update = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyResponse {
    // message fields
    pub key: ::protobuf::SingularPtrField<Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyResponse {
    fn default() -> &'a KeyResponse {
        <KeyResponse as ::protobuf::Message>::default_instance()
    }
}

impl KeyResponse {
    pub fn new() -> KeyResponse {
        ::std::default::Default::default()
    }

    // .service.Key key = 1;


    pub fn get_key(&self) -> &Key {
        self.key.as_ref().unwrap_or_else(|| <Key as ::protobuf::Message>::default_instance())
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: Key) {
        self.key = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut Key {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> Key {
        self.key.take().unwrap_or_else(|| Key::new())
    }
}

impl ::protobuf::Message for KeyResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.key {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyResponse {
        KeyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                "key",
                |m: &KeyResponse| { &m.key },
                |m: &mut KeyResponse| { &mut m.key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyResponse>(
                "KeyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyResponse {
        static instance: ::protobuf::rt::LazyV2<KeyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyResponse::new)
    }
}

impl ::protobuf::Clear for KeyResponse {
    fn clear(&mut self) {
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeysRequest {
    // message fields
    pub query: ::std::string::String,
    pub types: ::protobuf::RepeatedField<::std::string::String>,
    pub sortField: ::std::string::String,
    pub sortDirection: SortDirection,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeysRequest {
    fn default() -> &'a KeysRequest {
        <KeysRequest as ::protobuf::Message>::default_instance()
    }
}

impl KeysRequest {
    pub fn new() -> KeysRequest {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }

    // repeated string types = 2;


    pub fn get_types(&self) -> &[::std::string::String] {
        &self.types
    }
    pub fn clear_types(&mut self) {
        self.types.clear();
    }

    // Param is passed by value, moved
    pub fn set_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.types
    }

    // Take field
    pub fn take_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.types, ::protobuf::RepeatedField::new())
    }

    // string sortField = 10;


    pub fn get_sortField(&self) -> &str {
        &self.sortField
    }
    pub fn clear_sortField(&mut self) {
        self.sortField.clear();
    }

    // Param is passed by value, moved
    pub fn set_sortField(&mut self, v: ::std::string::String) {
        self.sortField = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sortField(&mut self) -> &mut ::std::string::String {
        &mut self.sortField
    }

    // Take field
    pub fn take_sortField(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sortField, ::std::string::String::new())
    }

    // .service.SortDirection sortDirection = 11;


    pub fn get_sortDirection(&self) -> SortDirection {
        self.sortDirection
    }
    pub fn clear_sortDirection(&mut self) {
        self.sortDirection = SortDirection::ASC;
    }

    // Param is passed by value, moved
    pub fn set_sortDirection(&mut self, v: SortDirection) {
        self.sortDirection = v;
    }
}

impl ::protobuf::Message for KeysRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.types)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sortField)?;
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.sortDirection, 11, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        for value in &self.types {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if !self.sortField.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.sortField);
        }
        if self.sortDirection != SortDirection::ASC {
            my_size += ::protobuf::rt::enum_size(11, self.sortDirection);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        for v in &self.types {
            os.write_string(2, &v)?;
        };
        if !self.sortField.is_empty() {
            os.write_string(10, &self.sortField)?;
        }
        if self.sortDirection != SortDirection::ASC {
            os.write_enum(11, ::protobuf::ProtobufEnum::value(&self.sortDirection))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeysRequest {
        KeysRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &KeysRequest| { &m.query },
                |m: &mut KeysRequest| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "types",
                |m: &KeysRequest| { &m.types },
                |m: &mut KeysRequest| { &mut m.types },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sortField",
                |m: &KeysRequest| { &m.sortField },
                |m: &mut KeysRequest| { &mut m.sortField },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SortDirection>>(
                "sortDirection",
                |m: &KeysRequest| { &m.sortDirection },
                |m: &mut KeysRequest| { &mut m.sortDirection },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeysRequest>(
                "KeysRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeysRequest {
        static instance: ::protobuf::rt::LazyV2<KeysRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeysRequest::new)
    }
}

impl ::protobuf::Clear for KeysRequest {
    fn clear(&mut self) {
        self.query.clear();
        self.types.clear();
        self.sortField.clear();
        self.sortDirection = SortDirection::ASC;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeysRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeysRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeysResponse {
    // message fields
    pub keys: ::protobuf::RepeatedField<Key>,
    pub sortField: ::std::string::String,
    pub sortDirection: SortDirection,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeysResponse {
    fn default() -> &'a KeysResponse {
        <KeysResponse as ::protobuf::Message>::default_instance()
    }
}

impl KeysResponse {
    pub fn new() -> KeysResponse {
        ::std::default::Default::default()
    }

    // repeated .service.Key keys = 1;


    pub fn get_keys(&self) -> &[Key] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<Key>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<Key> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<Key> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }

    // string sortField = 10;


    pub fn get_sortField(&self) -> &str {
        &self.sortField
    }
    pub fn clear_sortField(&mut self) {
        self.sortField.clear();
    }

    // Param is passed by value, moved
    pub fn set_sortField(&mut self, v: ::std::string::String) {
        self.sortField = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sortField(&mut self) -> &mut ::std::string::String {
        &mut self.sortField
    }

    // Take field
    pub fn take_sortField(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sortField, ::std::string::String::new())
    }

    // .service.SortDirection sortDirection = 11;


    pub fn get_sortDirection(&self) -> SortDirection {
        self.sortDirection
    }
    pub fn clear_sortDirection(&mut self) {
        self.sortDirection = SortDirection::ASC;
    }

    // Param is passed by value, moved
    pub fn set_sortDirection(&mut self, v: SortDirection) {
        self.sortDirection = v;
    }
}

impl ::protobuf::Message for KeysResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.keys)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sortField)?;
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.sortDirection, 11, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.sortField.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.sortField);
        }
        if self.sortDirection != SortDirection::ASC {
            my_size += ::protobuf::rt::enum_size(11, self.sortDirection);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.keys {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.sortField.is_empty() {
            os.write_string(10, &self.sortField)?;
        }
        if self.sortDirection != SortDirection::ASC {
            os.write_enum(11, ::protobuf::ProtobufEnum::value(&self.sortDirection))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeysResponse {
        KeysResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                "keys",
                |m: &KeysResponse| { &m.keys },
                |m: &mut KeysResponse| { &mut m.keys },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sortField",
                |m: &KeysResponse| { &m.sortField },
                |m: &mut KeysResponse| { &mut m.sortField },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SortDirection>>(
                "sortDirection",
                |m: &KeysResponse| { &m.sortDirection },
                |m: &mut KeysResponse| { &mut m.sortDirection },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeysResponse>(
                "KeysResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeysResponse {
        static instance: ::protobuf::rt::LazyV2<KeysResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeysResponse::new)
    }
}

impl ::protobuf::Clear for KeysResponse {
    fn clear(&mut self) {
        self.keys.clear();
        self.sortField.clear();
        self.sortDirection = SortDirection::ASC;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeysResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeysResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Secret {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub field_type: SecretType,
    pub username: ::std::string::String,
    pub password: ::std::string::String,
    pub url: ::std::string::String,
    pub notes: ::std::string::String,
    pub createdAt: i64,
    pub updatedAt: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Secret {
    fn default() -> &'a Secret {
        <Secret as ::protobuf::Message>::default_instance()
    }
}

impl Secret {
    pub fn new() -> Secret {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .service.SecretType type = 3;


    pub fn get_field_type(&self) -> SecretType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = SecretType::UNKNOWN_SECRET_TYPE;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: SecretType) {
        self.field_type = v;
    }

    // string username = 10;


    pub fn get_username(&self) -> &str {
        &self.username
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    // string password = 11;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }

    // string url = 20;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // string notes = 30;


    pub fn get_notes(&self) -> &str {
        &self.notes
    }
    pub fn clear_notes(&mut self) {
        self.notes.clear();
    }

    // Param is passed by value, moved
    pub fn set_notes(&mut self, v: ::std::string::String) {
        self.notes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notes(&mut self) -> &mut ::std::string::String {
        &mut self.notes
    }

    // Take field
    pub fn take_notes(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.notes, ::std::string::String::new())
    }

    // int64 createdAt = 100;


    pub fn get_createdAt(&self) -> i64 {
        self.createdAt
    }
    pub fn clear_createdAt(&mut self) {
        self.createdAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_createdAt(&mut self, v: i64) {
        self.createdAt = v;
    }

    // int64 updatedAt = 101;


    pub fn get_updatedAt(&self) -> i64 {
        self.updatedAt
    }
    pub fn clear_updatedAt(&mut self) {
        self.updatedAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_updatedAt(&mut self, v: i64) {
        self.updatedAt = v;
    }
}

impl ::protobuf::Message for Secret {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 3, &mut self.unknown_fields)?
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                30 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.notes)?;
                },
                100 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.createdAt = tmp;
                },
                101 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.updatedAt = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.field_type != SecretType::UNKNOWN_SECRET_TYPE {
            my_size += ::protobuf::rt::enum_size(3, self.field_type);
        }
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.username);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.password);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(20, &self.url);
        }
        if !self.notes.is_empty() {
            my_size += ::protobuf::rt::string_size(30, &self.notes);
        }
        if self.createdAt != 0 {
            my_size += ::protobuf::rt::value_size(100, self.createdAt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.updatedAt != 0 {
            my_size += ::protobuf::rt::value_size(101, self.updatedAt, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.field_type != SecretType::UNKNOWN_SECRET_TYPE {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if !self.username.is_empty() {
            os.write_string(10, &self.username)?;
        }
        if !self.password.is_empty() {
            os.write_string(11, &self.password)?;
        }
        if !self.url.is_empty() {
            os.write_string(20, &self.url)?;
        }
        if !self.notes.is_empty() {
            os.write_string(30, &self.notes)?;
        }
        if self.createdAt != 0 {
            os.write_int64(100, self.createdAt)?;
        }
        if self.updatedAt != 0 {
            os.write_int64(101, self.updatedAt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Secret {
        Secret::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Secret| { &m.id },
                |m: &mut Secret| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Secret| { &m.name },
                |m: &mut Secret| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SecretType>>(
                "type",
                |m: &Secret| { &m.field_type },
                |m: &mut Secret| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "username",
                |m: &Secret| { &m.username },
                |m: &mut Secret| { &mut m.username },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "password",
                |m: &Secret| { &m.password },
                |m: &mut Secret| { &mut m.password },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &Secret| { &m.url },
                |m: &mut Secret| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "notes",
                |m: &Secret| { &m.notes },
                |m: &mut Secret| { &mut m.notes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "createdAt",
                |m: &Secret| { &m.createdAt },
                |m: &mut Secret| { &mut m.createdAt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "updatedAt",
                |m: &Secret| { &m.updatedAt },
                |m: &mut Secret| { &mut m.updatedAt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Secret>(
                "Secret",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Secret {
        static instance: ::protobuf::rt::LazyV2<Secret> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Secret::new)
    }
}

impl ::protobuf::Clear for Secret {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.field_type = SecretType::UNKNOWN_SECRET_TYPE;
        self.username.clear();
        self.password.clear();
        self.url.clear();
        self.notes.clear();
        self.createdAt = 0;
        self.updatedAt = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Secret {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Secret {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretRequest {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretRequest {
    fn default() -> &'a SecretRequest {
        <SecretRequest as ::protobuf::Message>::default_instance()
    }
}

impl SecretRequest {
    pub fn new() -> SecretRequest {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SecretRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretRequest {
        SecretRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &SecretRequest| { &m.id },
                |m: &mut SecretRequest| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretRequest>(
                "SecretRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SecretRequest {
        static instance: ::protobuf::rt::LazyV2<SecretRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SecretRequest::new)
    }
}

impl ::protobuf::Clear for SecretRequest {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretResponse {
    // message fields
    pub secret: ::protobuf::SingularPtrField<Secret>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretResponse {
    fn default() -> &'a SecretResponse {
        <SecretResponse as ::protobuf::Message>::default_instance()
    }
}

impl SecretResponse {
    pub fn new() -> SecretResponse {
        ::std::default::Default::default()
    }

    // .service.Secret secret = 1;


    pub fn get_secret(&self) -> &Secret {
        self.secret.as_ref().unwrap_or_else(|| <Secret as ::protobuf::Message>::default_instance())
    }
    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    pub fn has_secret(&self) -> bool {
        self.secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: Secret) {
        self.secret = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret(&mut self) -> &mut Secret {
        if self.secret.is_none() {
            self.secret.set_default();
        }
        self.secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_secret(&mut self) -> Secret {
        self.secret.take().unwrap_or_else(|| Secret::new())
    }
}

impl ::protobuf::Message for SecretResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.secret {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secret)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.secret.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.secret.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretResponse {
        SecretResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Secret>>(
                "secret",
                |m: &SecretResponse| { &m.secret },
                |m: &mut SecretResponse| { &mut m.secret },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretResponse>(
                "SecretResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SecretResponse {
        static instance: ::protobuf::rt::LazyV2<SecretResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SecretResponse::new)
    }
}

impl ::protobuf::Clear for SecretResponse {
    fn clear(&mut self) {
        self.secret.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretSaveRequest {
    // message fields
    pub secret: ::protobuf::SingularPtrField<Secret>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretSaveRequest {
    fn default() -> &'a SecretSaveRequest {
        <SecretSaveRequest as ::protobuf::Message>::default_instance()
    }
}

impl SecretSaveRequest {
    pub fn new() -> SecretSaveRequest {
        ::std::default::Default::default()
    }

    // .service.Secret secret = 1;


    pub fn get_secret(&self) -> &Secret {
        self.secret.as_ref().unwrap_or_else(|| <Secret as ::protobuf::Message>::default_instance())
    }
    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    pub fn has_secret(&self) -> bool {
        self.secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: Secret) {
        self.secret = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret(&mut self) -> &mut Secret {
        if self.secret.is_none() {
            self.secret.set_default();
        }
        self.secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_secret(&mut self) -> Secret {
        self.secret.take().unwrap_or_else(|| Secret::new())
    }
}

impl ::protobuf::Message for SecretSaveRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.secret {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secret)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.secret.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.secret.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretSaveRequest {
        SecretSaveRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Secret>>(
                "secret",
                |m: &SecretSaveRequest| { &m.secret },
                |m: &mut SecretSaveRequest| { &mut m.secret },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretSaveRequest>(
                "SecretSaveRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SecretSaveRequest {
        static instance: ::protobuf::rt::LazyV2<SecretSaveRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SecretSaveRequest::new)
    }
}

impl ::protobuf::Clear for SecretSaveRequest {
    fn clear(&mut self) {
        self.secret.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretSaveRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretSaveRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretSaveResponse {
    // message fields
    pub secret: ::protobuf::SingularPtrField<Secret>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretSaveResponse {
    fn default() -> &'a SecretSaveResponse {
        <SecretSaveResponse as ::protobuf::Message>::default_instance()
    }
}

impl SecretSaveResponse {
    pub fn new() -> SecretSaveResponse {
        ::std::default::Default::default()
    }

    // .service.Secret secret = 1;


    pub fn get_secret(&self) -> &Secret {
        self.secret.as_ref().unwrap_or_else(|| <Secret as ::protobuf::Message>::default_instance())
    }
    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    pub fn has_secret(&self) -> bool {
        self.secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: Secret) {
        self.secret = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret(&mut self) -> &mut Secret {
        if self.secret.is_none() {
            self.secret.set_default();
        }
        self.secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_secret(&mut self) -> Secret {
        self.secret.take().unwrap_or_else(|| Secret::new())
    }
}

impl ::protobuf::Message for SecretSaveResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.secret {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secret)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.secret.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.secret.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretSaveResponse {
        SecretSaveResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Secret>>(
                "secret",
                |m: &SecretSaveResponse| { &m.secret },
                |m: &mut SecretSaveResponse| { &mut m.secret },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretSaveResponse>(
                "SecretSaveResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SecretSaveResponse {
        static instance: ::protobuf::rt::LazyV2<SecretSaveResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SecretSaveResponse::new)
    }
}

impl ::protobuf::Clear for SecretSaveResponse {
    fn clear(&mut self) {
        self.secret.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretSaveResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretSaveResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretRemoveRequest {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretRemoveRequest {
    fn default() -> &'a SecretRemoveRequest {
        <SecretRemoveRequest as ::protobuf::Message>::default_instance()
    }
}

impl SecretRemoveRequest {
    pub fn new() -> SecretRemoveRequest {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SecretRemoveRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretRemoveRequest {
        SecretRemoveRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &SecretRemoveRequest| { &m.id },
                |m: &mut SecretRemoveRequest| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretRemoveRequest>(
                "SecretRemoveRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SecretRemoveRequest {
        static instance: ::protobuf::rt::LazyV2<SecretRemoveRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SecretRemoveRequest::new)
    }
}

impl ::protobuf::Clear for SecretRemoveRequest {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretRemoveRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretRemoveRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretRemoveResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretRemoveResponse {
    fn default() -> &'a SecretRemoveResponse {
        <SecretRemoveResponse as ::protobuf::Message>::default_instance()
    }
}

impl SecretRemoveResponse {
    pub fn new() -> SecretRemoveResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SecretRemoveResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretRemoveResponse {
        SecretRemoveResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretRemoveResponse>(
                "SecretRemoveResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SecretRemoveResponse {
        static instance: ::protobuf::rt::LazyV2<SecretRemoveResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SecretRemoveResponse::new)
    }
}

impl ::protobuf::Clear for SecretRemoveResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretRemoveResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretRemoveResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretsRequest {
    // message fields
    pub query: ::std::string::String,
    pub sortField: ::std::string::String,
    pub sortDirection: SortDirection,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretsRequest {
    fn default() -> &'a SecretsRequest {
        <SecretsRequest as ::protobuf::Message>::default_instance()
    }
}

impl SecretsRequest {
    pub fn new() -> SecretsRequest {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }

    // string sortField = 10;


    pub fn get_sortField(&self) -> &str {
        &self.sortField
    }
    pub fn clear_sortField(&mut self) {
        self.sortField.clear();
    }

    // Param is passed by value, moved
    pub fn set_sortField(&mut self, v: ::std::string::String) {
        self.sortField = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sortField(&mut self) -> &mut ::std::string::String {
        &mut self.sortField
    }

    // Take field
    pub fn take_sortField(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sortField, ::std::string::String::new())
    }

    // .service.SortDirection sortDirection = 11;


    pub fn get_sortDirection(&self) -> SortDirection {
        self.sortDirection
    }
    pub fn clear_sortDirection(&mut self) {
        self.sortDirection = SortDirection::ASC;
    }

    // Param is passed by value, moved
    pub fn set_sortDirection(&mut self, v: SortDirection) {
        self.sortDirection = v;
    }
}

impl ::protobuf::Message for SecretsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sortField)?;
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.sortDirection, 11, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        if !self.sortField.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.sortField);
        }
        if self.sortDirection != SortDirection::ASC {
            my_size += ::protobuf::rt::enum_size(11, self.sortDirection);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        if !self.sortField.is_empty() {
            os.write_string(10, &self.sortField)?;
        }
        if self.sortDirection != SortDirection::ASC {
            os.write_enum(11, ::protobuf::ProtobufEnum::value(&self.sortDirection))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretsRequest {
        SecretsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &SecretsRequest| { &m.query },
                |m: &mut SecretsRequest| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sortField",
                |m: &SecretsRequest| { &m.sortField },
                |m: &mut SecretsRequest| { &mut m.sortField },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SortDirection>>(
                "sortDirection",
                |m: &SecretsRequest| { &m.sortDirection },
                |m: &mut SecretsRequest| { &mut m.sortDirection },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretsRequest>(
                "SecretsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SecretsRequest {
        static instance: ::protobuf::rt::LazyV2<SecretsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SecretsRequest::new)
    }
}

impl ::protobuf::Clear for SecretsRequest {
    fn clear(&mut self) {
        self.query.clear();
        self.sortField.clear();
        self.sortDirection = SortDirection::ASC;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretsResponse {
    // message fields
    pub secrets: ::protobuf::RepeatedField<Secret>,
    pub sortField: ::std::string::String,
    pub sortDirection: SortDirection,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretsResponse {
    fn default() -> &'a SecretsResponse {
        <SecretsResponse as ::protobuf::Message>::default_instance()
    }
}

impl SecretsResponse {
    pub fn new() -> SecretsResponse {
        ::std::default::Default::default()
    }

    // repeated .service.Secret secrets = 1;


    pub fn get_secrets(&self) -> &[Secret] {
        &self.secrets
    }
    pub fn clear_secrets(&mut self) {
        self.secrets.clear();
    }

    // Param is passed by value, moved
    pub fn set_secrets(&mut self, v: ::protobuf::RepeatedField<Secret>) {
        self.secrets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_secrets(&mut self) -> &mut ::protobuf::RepeatedField<Secret> {
        &mut self.secrets
    }

    // Take field
    pub fn take_secrets(&mut self) -> ::protobuf::RepeatedField<Secret> {
        ::std::mem::replace(&mut self.secrets, ::protobuf::RepeatedField::new())
    }

    // string sortField = 10;


    pub fn get_sortField(&self) -> &str {
        &self.sortField
    }
    pub fn clear_sortField(&mut self) {
        self.sortField.clear();
    }

    // Param is passed by value, moved
    pub fn set_sortField(&mut self, v: ::std::string::String) {
        self.sortField = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sortField(&mut self) -> &mut ::std::string::String {
        &mut self.sortField
    }

    // Take field
    pub fn take_sortField(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sortField, ::std::string::String::new())
    }

    // .service.SortDirection sortDirection = 11;


    pub fn get_sortDirection(&self) -> SortDirection {
        self.sortDirection
    }
    pub fn clear_sortDirection(&mut self) {
        self.sortDirection = SortDirection::ASC;
    }

    // Param is passed by value, moved
    pub fn set_sortDirection(&mut self, v: SortDirection) {
        self.sortDirection = v;
    }
}

impl ::protobuf::Message for SecretsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.secrets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.secrets)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sortField)?;
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.sortDirection, 11, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.secrets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.sortField.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.sortField);
        }
        if self.sortDirection != SortDirection::ASC {
            my_size += ::protobuf::rt::enum_size(11, self.sortDirection);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.secrets {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.sortField.is_empty() {
            os.write_string(10, &self.sortField)?;
        }
        if self.sortDirection != SortDirection::ASC {
            os.write_enum(11, ::protobuf::ProtobufEnum::value(&self.sortDirection))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretsResponse {
        SecretsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Secret>>(
                "secrets",
                |m: &SecretsResponse| { &m.secrets },
                |m: &mut SecretsResponse| { &mut m.secrets },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sortField",
                |m: &SecretsResponse| { &m.sortField },
                |m: &mut SecretsResponse| { &mut m.sortField },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SortDirection>>(
                "sortDirection",
                |m: &SecretsResponse| { &m.sortDirection },
                |m: &mut SecretsResponse| { &mut m.sortDirection },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretsResponse>(
                "SecretsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SecretsResponse {
        static instance: ::protobuf::rt::LazyV2<SecretsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SecretsResponse::new)
    }
}

impl ::protobuf::Clear for SecretsResponse {
    fn clear(&mut self) {
        self.secrets.clear();
        self.sortField.clear();
        self.sortDirection = SortDirection::ASC;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RandRequest {
    // message fields
    pub numBytes: i32,
    pub encoding: Encoding,
    pub noPadding: bool,
    pub lowercase: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RandRequest {
    fn default() -> &'a RandRequest {
        <RandRequest as ::protobuf::Message>::default_instance()
    }
}

impl RandRequest {
    pub fn new() -> RandRequest {
        ::std::default::Default::default()
    }

    // int32 numBytes = 1;


    pub fn get_numBytes(&self) -> i32 {
        self.numBytes
    }
    pub fn clear_numBytes(&mut self) {
        self.numBytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_numBytes(&mut self, v: i32) {
        self.numBytes = v;
    }

    // .service.Encoding encoding = 2;


    pub fn get_encoding(&self) -> Encoding {
        self.encoding
    }
    pub fn clear_encoding(&mut self) {
        self.encoding = Encoding::HEX;
    }

    // Param is passed by value, moved
    pub fn set_encoding(&mut self, v: Encoding) {
        self.encoding = v;
    }

    // bool noPadding = 10;


    pub fn get_noPadding(&self) -> bool {
        self.noPadding
    }
    pub fn clear_noPadding(&mut self) {
        self.noPadding = false;
    }

    // Param is passed by value, moved
    pub fn set_noPadding(&mut self, v: bool) {
        self.noPadding = v;
    }

    // bool lowercase = 11;


    pub fn get_lowercase(&self) -> bool {
        self.lowercase
    }
    pub fn clear_lowercase(&mut self) {
        self.lowercase = false;
    }

    // Param is passed by value, moved
    pub fn set_lowercase(&mut self, v: bool) {
        self.lowercase = v;
    }
}

impl ::protobuf::Message for RandRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.numBytes = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.encoding, 2, &mut self.unknown_fields)?
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.noPadding = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.lowercase = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.numBytes != 0 {
            my_size += ::protobuf::rt::value_size(1, self.numBytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.encoding != Encoding::HEX {
            my_size += ::protobuf::rt::enum_size(2, self.encoding);
        }
        if self.noPadding != false {
            my_size += 2;
        }
        if self.lowercase != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.numBytes != 0 {
            os.write_int32(1, self.numBytes)?;
        }
        if self.encoding != Encoding::HEX {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.encoding))?;
        }
        if self.noPadding != false {
            os.write_bool(10, self.noPadding)?;
        }
        if self.lowercase != false {
            os.write_bool(11, self.lowercase)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RandRequest {
        RandRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "numBytes",
                |m: &RandRequest| { &m.numBytes },
                |m: &mut RandRequest| { &mut m.numBytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Encoding>>(
                "encoding",
                |m: &RandRequest| { &m.encoding },
                |m: &mut RandRequest| { &mut m.encoding },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "noPadding",
                |m: &RandRequest| { &m.noPadding },
                |m: &mut RandRequest| { &mut m.noPadding },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "lowercase",
                |m: &RandRequest| { &m.lowercase },
                |m: &mut RandRequest| { &mut m.lowercase },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RandRequest>(
                "RandRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RandRequest {
        static instance: ::protobuf::rt::LazyV2<RandRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RandRequest::new)
    }
}

impl ::protobuf::Clear for RandRequest {
    fn clear(&mut self) {
        self.numBytes = 0;
        self.encoding = Encoding::HEX;
        self.noPadding = false;
        self.lowercase = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RandRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RandResponse {
    // message fields
    pub data: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RandResponse {
    fn default() -> &'a RandResponse {
        <RandResponse as ::protobuf::Message>::default_instance()
    }
}

impl RandResponse {
    pub fn new() -> RandResponse {
        ::std::default::Default::default()
    }

    // string data = 1;


    pub fn get_data(&self) -> &str {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::string::String) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::string::String {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.data, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RandResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_string(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RandResponse {
        RandResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "data",
                |m: &RandResponse| { &m.data },
                |m: &mut RandResponse| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RandResponse>(
                "RandResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RandResponse {
        static instance: ::protobuf::rt::LazyV2<RandResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RandResponse::new)
    }
}

impl ::protobuf::Clear for RandResponse {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RandResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RandResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RandPasswordRequest {
    // message fields
    pub length: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RandPasswordRequest {
    fn default() -> &'a RandPasswordRequest {
        <RandPasswordRequest as ::protobuf::Message>::default_instance()
    }
}

impl RandPasswordRequest {
    pub fn new() -> RandPasswordRequest {
        ::std::default::Default::default()
    }

    // int32 length = 1;


    pub fn get_length(&self) -> i32 {
        self.length
    }
    pub fn clear_length(&mut self) {
        self.length = 0;
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: i32) {
        self.length = v;
    }
}

impl ::protobuf::Message for RandPasswordRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.length = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.length != 0 {
            my_size += ::protobuf::rt::value_size(1, self.length, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.length != 0 {
            os.write_int32(1, self.length)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RandPasswordRequest {
        RandPasswordRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "length",
                |m: &RandPasswordRequest| { &m.length },
                |m: &mut RandPasswordRequest| { &mut m.length },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RandPasswordRequest>(
                "RandPasswordRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RandPasswordRequest {
        static instance: ::protobuf::rt::LazyV2<RandPasswordRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RandPasswordRequest::new)
    }
}

impl ::protobuf::Clear for RandPasswordRequest {
    fn clear(&mut self) {
        self.length = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RandPasswordRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RandPasswordRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RandPasswordResponse {
    // message fields
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RandPasswordResponse {
    fn default() -> &'a RandPasswordResponse {
        <RandPasswordResponse as ::protobuf::Message>::default_instance()
    }
}

impl RandPasswordResponse {
    pub fn new() -> RandPasswordResponse {
        ::std::default::Default::default()
    }

    // string password = 1;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RandPasswordResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.password.is_empty() {
            os.write_string(1, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RandPasswordResponse {
        RandPasswordResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "password",
                |m: &RandPasswordResponse| { &m.password },
                |m: &mut RandPasswordResponse| { &mut m.password },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RandPasswordResponse>(
                "RandPasswordResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RandPasswordResponse {
        static instance: ::protobuf::rt::LazyV2<RandPasswordResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RandPasswordResponse::new)
    }
}

impl ::protobuf::Clear for RandPasswordResponse {
    fn clear(&mut self) {
        self.password.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RandPasswordResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RandPasswordResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PullRequest {
    // message fields
    pub key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PullRequest {
    fn default() -> &'a PullRequest {
        <PullRequest as ::protobuf::Message>::default_instance()
    }
}

impl PullRequest {
    pub fn new() -> PullRequest {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PullRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PullRequest {
        PullRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &PullRequest| { &m.key },
                |m: &mut PullRequest| { &mut m.key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PullRequest>(
                "PullRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PullRequest {
        static instance: ::protobuf::rt::LazyV2<PullRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PullRequest::new)
    }
}

impl ::protobuf::Clear for PullRequest {
    fn clear(&mut self) {
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PullRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PullRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PullResponse {
    // message fields
    pub kids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PullResponse {
    fn default() -> &'a PullResponse {
        <PullResponse as ::protobuf::Message>::default_instance()
    }
}

impl PullResponse {
    pub fn new() -> PullResponse {
        ::std::default::Default::default()
    }

    // repeated string kids = 1;


    pub fn get_kids(&self) -> &[::std::string::String] {
        &self.kids
    }
    pub fn clear_kids(&mut self) {
        self.kids.clear();
    }

    // Param is passed by value, moved
    pub fn set_kids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.kids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_kids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.kids
    }

    // Take field
    pub fn take_kids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.kids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PullResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.kids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.kids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.kids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PullResponse {
        PullResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kids",
                |m: &PullResponse| { &m.kids },
                |m: &mut PullResponse| { &mut m.kids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PullResponse>(
                "PullResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PullResponse {
        static instance: ::protobuf::rt::LazyV2<PullResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PullResponse::new)
    }
}

impl ::protobuf::Clear for PullResponse {
    fn clear(&mut self) {
        self.kids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PullResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PullResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PushRequest {
    // message fields
    pub key: ::std::string::String,
    pub remoteCheck: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PushRequest {
    fn default() -> &'a PushRequest {
        <PushRequest as ::protobuf::Message>::default_instance()
    }
}

impl PushRequest {
    pub fn new() -> PushRequest {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // bool remoteCheck = 2;


    pub fn get_remoteCheck(&self) -> bool {
        self.remoteCheck
    }
    pub fn clear_remoteCheck(&mut self) {
        self.remoteCheck = false;
    }

    // Param is passed by value, moved
    pub fn set_remoteCheck(&mut self, v: bool) {
        self.remoteCheck = v;
    }
}

impl ::protobuf::Message for PushRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.remoteCheck = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if self.remoteCheck != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if self.remoteCheck != false {
            os.write_bool(2, self.remoteCheck)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PushRequest {
        PushRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &PushRequest| { &m.key },
                |m: &mut PushRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "remoteCheck",
                |m: &PushRequest| { &m.remoteCheck },
                |m: &mut PushRequest| { &mut m.remoteCheck },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PushRequest>(
                "PushRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PushRequest {
        static instance: ::protobuf::rt::LazyV2<PushRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PushRequest::new)
    }
}

impl ::protobuf::Clear for PushRequest {
    fn clear(&mut self) {
        self.key.clear();
        self.remoteCheck = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PushRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PushRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PushResponse {
    // message fields
    pub kid: ::std::string::String,
    pub urls: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PushResponse {
    fn default() -> &'a PushResponse {
        <PushResponse as ::protobuf::Message>::default_instance()
    }
}

impl PushResponse {
    pub fn new() -> PushResponse {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // repeated string urls = 2;


    pub fn get_urls(&self) -> &[::std::string::String] {
        &self.urls
    }
    pub fn clear_urls(&mut self) {
        self.urls.clear();
    }

    // Param is passed by value, moved
    pub fn set_urls(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.urls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_urls(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.urls
    }

    // Take field
    pub fn take_urls(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.urls, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PushResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.urls)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        for value in &self.urls {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        for v in &self.urls {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PushResponse {
        PushResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kid",
                |m: &PushResponse| { &m.kid },
                |m: &mut PushResponse| { &mut m.kid },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "urls",
                |m: &PushResponse| { &m.urls },
                |m: &mut PushResponse| { &mut m.urls },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PushResponse>(
                "PushResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PushResponse {
        static instance: ::protobuf::rt::LazyV2<PushResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PushResponse::new)
    }
}

impl ::protobuf::Clear for PushResponse {
    fn clear(&mut self) {
        self.kid.clear();
        self.urls.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PushResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PushResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Collection {
    // message fields
    pub path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Collection {
    fn default() -> &'a Collection {
        <Collection as ::protobuf::Message>::default_instance()
    }
}

impl Collection {
    pub fn new() -> Collection {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Collection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Collection {
        Collection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &Collection| { &m.path },
                |m: &mut Collection| { &mut m.path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Collection>(
                "Collection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Collection {
        static instance: ::protobuf::rt::LazyV2<Collection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Collection::new)
    }
}

impl ::protobuf::Clear for Collection {
    fn clear(&mut self) {
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Collection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Collection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CollectionsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub db: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CollectionsRequest {
    fn default() -> &'a CollectionsRequest {
        <CollectionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl CollectionsRequest {
    pub fn new() -> CollectionsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string db = 5;


    pub fn get_db(&self) -> &str {
        &self.db
    }
    pub fn clear_db(&mut self) {
        self.db.clear();
    }

    // Param is passed by value, moved
    pub fn set_db(&mut self, v: ::std::string::String) {
        self.db = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_db(&mut self) -> &mut ::std::string::String {
        &mut self.db
    }

    // Take field
    pub fn take_db(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.db, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CollectionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.db)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.db.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.db);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.db.is_empty() {
            os.write_string(5, &self.db)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CollectionsRequest {
        CollectionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &CollectionsRequest| { &m.parent },
                |m: &mut CollectionsRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "db",
                |m: &CollectionsRequest| { &m.db },
                |m: &mut CollectionsRequest| { &mut m.db },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CollectionsRequest>(
                "CollectionsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CollectionsRequest {
        static instance: ::protobuf::rt::LazyV2<CollectionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CollectionsRequest::new)
    }
}

impl ::protobuf::Clear for CollectionsRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.db.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CollectionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CollectionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CollectionsResponse {
    // message fields
    pub collections: ::protobuf::RepeatedField<Collection>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CollectionsResponse {
    fn default() -> &'a CollectionsResponse {
        <CollectionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CollectionsResponse {
    pub fn new() -> CollectionsResponse {
        ::std::default::Default::default()
    }

    // repeated .service.Collection collections = 1;


    pub fn get_collections(&self) -> &[Collection] {
        &self.collections
    }
    pub fn clear_collections(&mut self) {
        self.collections.clear();
    }

    // Param is passed by value, moved
    pub fn set_collections(&mut self, v: ::protobuf::RepeatedField<Collection>) {
        self.collections = v;
    }

    // Mutable pointer to the field.
    pub fn mut_collections(&mut self) -> &mut ::protobuf::RepeatedField<Collection> {
        &mut self.collections
    }

    // Take field
    pub fn take_collections(&mut self) -> ::protobuf::RepeatedField<Collection> {
        ::std::mem::replace(&mut self.collections, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CollectionsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.collections {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.collections)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.collections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.collections {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CollectionsResponse {
        CollectionsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Collection>>(
                "collections",
                |m: &CollectionsResponse| { &m.collections },
                |m: &mut CollectionsResponse| { &mut m.collections },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CollectionsResponse>(
                "CollectionsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CollectionsResponse {
        static instance: ::protobuf::rt::LazyV2<CollectionsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CollectionsResponse::new)
    }
}

impl ::protobuf::Clear for CollectionsResponse {
    fn clear(&mut self) {
        self.collections.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CollectionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CollectionsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Document {
    // message fields
    pub path: ::std::string::String,
    pub value: ::std::string::String,
    pub createdAt: i64,
    pub updatedAt: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Document {
    fn default() -> &'a Document {
        <Document as ::protobuf::Message>::default_instance()
    }
}

impl Document {
    pub fn new() -> Document {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    // int64 createdAt = 10;


    pub fn get_createdAt(&self) -> i64 {
        self.createdAt
    }
    pub fn clear_createdAt(&mut self) {
        self.createdAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_createdAt(&mut self, v: i64) {
        self.createdAt = v;
    }

    // int64 updatedAt = 11;


    pub fn get_updatedAt(&self) -> i64 {
        self.updatedAt
    }
    pub fn clear_updatedAt(&mut self) {
        self.updatedAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_updatedAt(&mut self, v: i64) {
        self.updatedAt = v;
    }
}

impl ::protobuf::Message for Document {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.createdAt = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.updatedAt = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        if self.createdAt != 0 {
            my_size += ::protobuf::rt::value_size(10, self.createdAt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.updatedAt != 0 {
            my_size += ::protobuf::rt::value_size(11, self.updatedAt, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        if self.createdAt != 0 {
            os.write_int64(10, self.createdAt)?;
        }
        if self.updatedAt != 0 {
            os.write_int64(11, self.updatedAt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Document {
        Document::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &Document| { &m.path },
                |m: &mut Document| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &Document| { &m.value },
                |m: &mut Document| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "createdAt",
                |m: &Document| { &m.createdAt },
                |m: &mut Document| { &mut m.createdAt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "updatedAt",
                |m: &Document| { &m.updatedAt },
                |m: &mut Document| { &mut m.updatedAt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Document>(
                "Document",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Document {
        static instance: ::protobuf::rt::LazyV2<Document> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Document::new)
    }
}

impl ::protobuf::Clear for Document {
    fn clear(&mut self) {
        self.path.clear();
        self.value.clear();
        self.createdAt = 0;
        self.updatedAt = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Document {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Document {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DocumentsRequest {
    // message fields
    pub prefix: ::std::string::String,
    pub db: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DocumentsRequest {
    fn default() -> &'a DocumentsRequest {
        <DocumentsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DocumentsRequest {
    pub fn new() -> DocumentsRequest {
        ::std::default::Default::default()
    }

    // string prefix = 1;


    pub fn get_prefix(&self) -> &str {
        &self.prefix
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.prefix
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prefix, ::std::string::String::new())
    }

    // string db = 5;


    pub fn get_db(&self) -> &str {
        &self.db
    }
    pub fn clear_db(&mut self) {
        self.db.clear();
    }

    // Param is passed by value, moved
    pub fn set_db(&mut self, v: ::std::string::String) {
        self.db = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_db(&mut self) -> &mut ::std::string::String {
        &mut self.db
    }

    // Take field
    pub fn take_db(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.db, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DocumentsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prefix)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.db)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.prefix);
        }
        if !self.db.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.db);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.prefix.is_empty() {
            os.write_string(1, &self.prefix)?;
        }
        if !self.db.is_empty() {
            os.write_string(5, &self.db)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocumentsRequest {
        DocumentsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "prefix",
                |m: &DocumentsRequest| { &m.prefix },
                |m: &mut DocumentsRequest| { &mut m.prefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "db",
                |m: &DocumentsRequest| { &m.db },
                |m: &mut DocumentsRequest| { &mut m.db },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DocumentsRequest>(
                "DocumentsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DocumentsRequest {
        static instance: ::protobuf::rt::LazyV2<DocumentsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DocumentsRequest::new)
    }
}

impl ::protobuf::Clear for DocumentsRequest {
    fn clear(&mut self) {
        self.prefix.clear();
        self.db.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocumentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DocumentsResponse {
    // message fields
    pub documents: ::protobuf::RepeatedField<Document>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DocumentsResponse {
    fn default() -> &'a DocumentsResponse {
        <DocumentsResponse as ::protobuf::Message>::default_instance()
    }
}

impl DocumentsResponse {
    pub fn new() -> DocumentsResponse {
        ::std::default::Default::default()
    }

    // repeated .service.Document documents = 1;


    pub fn get_documents(&self) -> &[Document] {
        &self.documents
    }
    pub fn clear_documents(&mut self) {
        self.documents.clear();
    }

    // Param is passed by value, moved
    pub fn set_documents(&mut self, v: ::protobuf::RepeatedField<Document>) {
        self.documents = v;
    }

    // Mutable pointer to the field.
    pub fn mut_documents(&mut self) -> &mut ::protobuf::RepeatedField<Document> {
        &mut self.documents
    }

    // Take field
    pub fn take_documents(&mut self) -> ::protobuf::RepeatedField<Document> {
        ::std::mem::replace(&mut self.documents, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DocumentsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.documents {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.documents)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.documents {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.documents {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocumentsResponse {
        DocumentsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Document>>(
                "documents",
                |m: &DocumentsResponse| { &m.documents },
                |m: &mut DocumentsResponse| { &mut m.documents },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DocumentsResponse>(
                "DocumentsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DocumentsResponse {
        static instance: ::protobuf::rt::LazyV2<DocumentsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DocumentsResponse::new)
    }
}

impl ::protobuf::Clear for DocumentsResponse {
    fn clear(&mut self) {
        self.documents.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocumentsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DocumentDeleteRequest {
    // message fields
    pub path: ::std::string::String,
    pub db: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DocumentDeleteRequest {
    fn default() -> &'a DocumentDeleteRequest {
        <DocumentDeleteRequest as ::protobuf::Message>::default_instance()
    }
}

impl DocumentDeleteRequest {
    pub fn new() -> DocumentDeleteRequest {
        ::std::default::Default::default()
    }

    // string path = 1;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // string db = 5;


    pub fn get_db(&self) -> &str {
        &self.db
    }
    pub fn clear_db(&mut self) {
        self.db.clear();
    }

    // Param is passed by value, moved
    pub fn set_db(&mut self, v: ::std::string::String) {
        self.db = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_db(&mut self) -> &mut ::std::string::String {
        &mut self.db
    }

    // Take field
    pub fn take_db(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.db, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DocumentDeleteRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.db)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.path);
        }
        if !self.db.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.db);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.path.is_empty() {
            os.write_string(1, &self.path)?;
        }
        if !self.db.is_empty() {
            os.write_string(5, &self.db)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocumentDeleteRequest {
        DocumentDeleteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &DocumentDeleteRequest| { &m.path },
                |m: &mut DocumentDeleteRequest| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "db",
                |m: &DocumentDeleteRequest| { &m.db },
                |m: &mut DocumentDeleteRequest| { &mut m.db },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DocumentDeleteRequest>(
                "DocumentDeleteRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DocumentDeleteRequest {
        static instance: ::protobuf::rt::LazyV2<DocumentDeleteRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DocumentDeleteRequest::new)
    }
}

impl ::protobuf::Clear for DocumentDeleteRequest {
    fn clear(&mut self) {
        self.path.clear();
        self.db.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocumentDeleteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentDeleteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DocumentDeleteResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DocumentDeleteResponse {
    fn default() -> &'a DocumentDeleteResponse {
        <DocumentDeleteResponse as ::protobuf::Message>::default_instance()
    }
}

impl DocumentDeleteResponse {
    pub fn new() -> DocumentDeleteResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DocumentDeleteResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DocumentDeleteResponse {
        DocumentDeleteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DocumentDeleteResponse>(
                "DocumentDeleteResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DocumentDeleteResponse {
        static instance: ::protobuf::rt::LazyV2<DocumentDeleteResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DocumentDeleteResponse::new)
    }
}

impl ::protobuf::Clear for DocumentDeleteResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DocumentDeleteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DocumentDeleteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct User {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub kid: ::std::string::String,
    pub seq: i32,
    pub service: ::std::string::String,
    pub url: ::std::string::String,
    pub status: UserStatus,
    pub verifiedAt: i64,
    pub timestamp: i64,
    pub proxied: bool,
    pub err: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a User {
    fn default() -> &'a User {
        <User as ::protobuf::Message>::default_instance()
    }
}

impl User {
    pub fn new() -> User {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string kid = 3;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // int32 seq = 4;


    pub fn get_seq(&self) -> i32 {
        self.seq
    }
    pub fn clear_seq(&mut self) {
        self.seq = 0;
    }

    // Param is passed by value, moved
    pub fn set_seq(&mut self, v: i32) {
        self.seq = v;
    }

    // string service = 5;


    pub fn get_service(&self) -> &str {
        &self.service
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }

    // string url = 6;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // .service.UserStatus status = 10;


    pub fn get_status(&self) -> UserStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = UserStatus::USER_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: UserStatus) {
        self.status = v;
    }

    // int64 verifiedAt = 11;


    pub fn get_verifiedAt(&self) -> i64 {
        self.verifiedAt
    }
    pub fn clear_verifiedAt(&mut self) {
        self.verifiedAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_verifiedAt(&mut self, v: i64) {
        self.verifiedAt = v;
    }

    // int64 timestamp = 12;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // bool proxied = 13;


    pub fn get_proxied(&self) -> bool {
        self.proxied
    }
    pub fn clear_proxied(&mut self) {
        self.proxied = false;
    }

    // Param is passed by value, moved
    pub fn set_proxied(&mut self, v: bool) {
        self.proxied = v;
    }

    // string err = 20;


    pub fn get_err(&self) -> &str {
        &self.err
    }
    pub fn clear_err(&mut self) {
        self.err.clear();
    }

    // Param is passed by value, moved
    pub fn set_err(&mut self, v: ::std::string::String) {
        self.err = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_err(&mut self) -> &mut ::std::string::String {
        &mut self.err
    }

    // Take field
    pub fn take_err(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.err, ::std::string::String::new())
    }
}

impl ::protobuf::Message for User {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seq = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 10, &mut self.unknown_fields)?
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.verifiedAt = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.proxied = tmp;
                },
                20 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.err)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.kid);
        }
        if self.seq != 0 {
            my_size += ::protobuf::rt::value_size(4, self.seq, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.service);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.url);
        }
        if self.status != UserStatus::USER_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(10, self.status);
        }
        if self.verifiedAt != 0 {
            my_size += ::protobuf::rt::value_size(11, self.verifiedAt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(12, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.proxied != false {
            my_size += 2;
        }
        if !self.err.is_empty() {
            my_size += ::protobuf::rt::string_size(20, &self.err);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.kid.is_empty() {
            os.write_string(3, &self.kid)?;
        }
        if self.seq != 0 {
            os.write_int32(4, self.seq)?;
        }
        if !self.service.is_empty() {
            os.write_string(5, &self.service)?;
        }
        if !self.url.is_empty() {
            os.write_string(6, &self.url)?;
        }
        if self.status != UserStatus::USER_UNKNOWN {
            os.write_enum(10, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if self.verifiedAt != 0 {
            os.write_int64(11, self.verifiedAt)?;
        }
        if self.timestamp != 0 {
            os.write_int64(12, self.timestamp)?;
        }
        if self.proxied != false {
            os.write_bool(13, self.proxied)?;
        }
        if !self.err.is_empty() {
            os.write_string(20, &self.err)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> User {
        User::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &User| { &m.id },
                |m: &mut User| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &User| { &m.name },
                |m: &mut User| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kid",
                |m: &User| { &m.kid },
                |m: &mut User| { &mut m.kid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "seq",
                |m: &User| { &m.seq },
                |m: &mut User| { &mut m.seq },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service",
                |m: &User| { &m.service },
                |m: &mut User| { &mut m.service },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &User| { &m.url },
                |m: &mut User| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<UserStatus>>(
                "status",
                |m: &User| { &m.status },
                |m: &mut User| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "verifiedAt",
                |m: &User| { &m.verifiedAt },
                |m: &mut User| { &mut m.verifiedAt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timestamp",
                |m: &User| { &m.timestamp },
                |m: &mut User| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "proxied",
                |m: &User| { &m.proxied },
                |m: &mut User| { &mut m.proxied },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "err",
                |m: &User| { &m.err },
                |m: &mut User| { &mut m.err },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<User>(
                "User",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static User {
        static instance: ::protobuf::rt::LazyV2<User> = ::protobuf::rt::LazyV2::INIT;
        instance.get(User::new)
    }
}

impl ::protobuf::Clear for User {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.kid.clear();
        self.seq = 0;
        self.service.clear();
        self.url.clear();
        self.status = UserStatus::USER_UNKNOWN;
        self.verifiedAt = 0;
        self.timestamp = 0;
        self.proxied = false;
        self.err.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for User {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for User {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserRequest {
    // message fields
    pub kid: ::std::string::String,
    pub local: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserRequest {
    fn default() -> &'a UserRequest {
        <UserRequest as ::protobuf::Message>::default_instance()
    }
}

impl UserRequest {
    pub fn new() -> UserRequest {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // bool local = 4;


    pub fn get_local(&self) -> bool {
        self.local
    }
    pub fn clear_local(&mut self) {
        self.local = false;
    }

    // Param is passed by value, moved
    pub fn set_local(&mut self, v: bool) {
        self.local = v;
    }
}

impl ::protobuf::Message for UserRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.local = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        if self.local != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        if self.local != false {
            os.write_bool(4, self.local)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserRequest {
        UserRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kid",
                |m: &UserRequest| { &m.kid },
                |m: &mut UserRequest| { &mut m.kid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "local",
                |m: &UserRequest| { &m.local },
                |m: &mut UserRequest| { &mut m.local },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserRequest>(
                "UserRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserRequest {
        static instance: ::protobuf::rt::LazyV2<UserRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserRequest::new)
    }
}

impl ::protobuf::Clear for UserRequest {
    fn clear(&mut self) {
        self.kid.clear();
        self.local = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserResponse {
    // message fields
    pub user: ::protobuf::SingularPtrField<User>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserResponse {
    fn default() -> &'a UserResponse {
        <UserResponse as ::protobuf::Message>::default_instance()
    }
}

impl UserResponse {
    pub fn new() -> UserResponse {
        ::std::default::Default::default()
    }

    // .service.User user = 1;


    pub fn get_user(&self) -> &User {
        self.user.as_ref().unwrap_or_else(|| <User as ::protobuf::Message>::default_instance())
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: User) {
        self.user = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut User {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> User {
        self.user.take().unwrap_or_else(|| User::new())
    }
}

impl ::protobuf::Message for UserResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.user {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserResponse {
        UserResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                "user",
                |m: &UserResponse| { &m.user },
                |m: &mut UserResponse| { &mut m.user },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserResponse>(
                "UserResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserResponse {
        static instance: ::protobuf::rt::LazyV2<UserResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserResponse::new)
    }
}

impl ::protobuf::Clear for UserResponse {
    fn clear(&mut self) {
        self.user.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserSearchRequest {
    // message fields
    pub query: ::std::string::String,
    pub limit: i32,
    pub local: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserSearchRequest {
    fn default() -> &'a UserSearchRequest {
        <UserSearchRequest as ::protobuf::Message>::default_instance()
    }
}

impl UserSearchRequest {
    pub fn new() -> UserSearchRequest {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }

    // int32 limit = 3;


    pub fn get_limit(&self) -> i32 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i32) {
        self.limit = v;
    }

    // bool local = 4;


    pub fn get_local(&self) -> bool {
        self.local
    }
    pub fn clear_local(&mut self) {
        self.local = false;
    }

    // Param is passed by value, moved
    pub fn set_local(&mut self, v: bool) {
        self.local = v;
    }
}

impl ::protobuf::Message for UserSearchRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.limit = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.local = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(3, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.local != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        if self.limit != 0 {
            os.write_int32(3, self.limit)?;
        }
        if self.local != false {
            os.write_bool(4, self.local)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserSearchRequest {
        UserSearchRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &UserSearchRequest| { &m.query },
                |m: &mut UserSearchRequest| { &mut m.query },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "limit",
                |m: &UserSearchRequest| { &m.limit },
                |m: &mut UserSearchRequest| { &mut m.limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "local",
                |m: &UserSearchRequest| { &m.local },
                |m: &mut UserSearchRequest| { &mut m.local },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserSearchRequest>(
                "UserSearchRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserSearchRequest {
        static instance: ::protobuf::rt::LazyV2<UserSearchRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserSearchRequest::new)
    }
}

impl ::protobuf::Clear for UserSearchRequest {
    fn clear(&mut self) {
        self.query.clear();
        self.limit = 0;
        self.local = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserSearchRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserSearchRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UserSearchResponse {
    // message fields
    pub users: ::protobuf::RepeatedField<User>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UserSearchResponse {
    fn default() -> &'a UserSearchResponse {
        <UserSearchResponse as ::protobuf::Message>::default_instance()
    }
}

impl UserSearchResponse {
    pub fn new() -> UserSearchResponse {
        ::std::default::Default::default()
    }

    // repeated .service.User users = 1;


    pub fn get_users(&self) -> &[User] {
        &self.users
    }
    pub fn clear_users(&mut self) {
        self.users.clear();
    }

    // Param is passed by value, moved
    pub fn set_users(&mut self, v: ::protobuf::RepeatedField<User>) {
        self.users = v;
    }

    // Mutable pointer to the field.
    pub fn mut_users(&mut self) -> &mut ::protobuf::RepeatedField<User> {
        &mut self.users
    }

    // Take field
    pub fn take_users(&mut self) -> ::protobuf::RepeatedField<User> {
        ::std::mem::replace(&mut self.users, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UserSearchResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.users {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.users)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.users {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.users {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UserSearchResponse {
        UserSearchResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<User>>(
                "users",
                |m: &UserSearchResponse| { &m.users },
                |m: &mut UserSearchResponse| { &mut m.users },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UserSearchResponse>(
                "UserSearchResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UserSearchResponse {
        static instance: ::protobuf::rt::LazyV2<UserSearchResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UserSearchResponse::new)
    }
}

impl ::protobuf::Clear for UserSearchResponse {
    fn clear(&mut self) {
        self.users.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UserSearchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserSearchResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SearchRequest {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SearchRequest {
    fn default() -> &'a SearchRequest {
        <SearchRequest as ::protobuf::Message>::default_instance()
    }
}

impl SearchRequest {
    pub fn new() -> SearchRequest {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SearchRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchRequest {
        SearchRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "query",
                |m: &SearchRequest| { &m.query },
                |m: &mut SearchRequest| { &mut m.query },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SearchRequest>(
                "SearchRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SearchRequest {
        static instance: ::protobuf::rt::LazyV2<SearchRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SearchRequest::new)
    }
}

impl ::protobuf::Clear for SearchRequest {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SearchResponse {
    // message fields
    pub keys: ::protobuf::RepeatedField<Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SearchResponse {
    fn default() -> &'a SearchResponse {
        <SearchResponse as ::protobuf::Message>::default_instance()
    }
}

impl SearchResponse {
    pub fn new() -> SearchResponse {
        ::std::default::Default::default()
    }

    // repeated .service.Key keys = 1;


    pub fn get_keys(&self) -> &[Key] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<Key>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<Key> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<Key> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SearchResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.keys {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SearchResponse {
        SearchResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                "keys",
                |m: &SearchResponse| { &m.keys },
                |m: &mut SearchResponse| { &mut m.keys },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SearchResponse>(
                "SearchResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SearchResponse {
        static instance: ::protobuf::rt::LazyV2<SearchResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SearchResponse::new)
    }
}

impl ::protobuf::Clear for SearchResponse {
    fn clear(&mut self) {
        self.keys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SearchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SearchResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VaultSyncRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VaultSyncRequest {
    fn default() -> &'a VaultSyncRequest {
        <VaultSyncRequest as ::protobuf::Message>::default_instance()
    }
}

impl VaultSyncRequest {
    pub fn new() -> VaultSyncRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VaultSyncRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VaultSyncRequest {
        VaultSyncRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VaultSyncRequest>(
                "VaultSyncRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VaultSyncRequest {
        static instance: ::protobuf::rt::LazyV2<VaultSyncRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VaultSyncRequest::new)
    }
}

impl ::protobuf::Clear for VaultSyncRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VaultSyncRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VaultSyncRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VaultSyncResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VaultSyncResponse {
    fn default() -> &'a VaultSyncResponse {
        <VaultSyncResponse as ::protobuf::Message>::default_instance()
    }
}

impl VaultSyncResponse {
    pub fn new() -> VaultSyncResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VaultSyncResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VaultSyncResponse {
        VaultSyncResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VaultSyncResponse>(
                "VaultSyncResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VaultSyncResponse {
        static instance: ::protobuf::rt::LazyV2<VaultSyncResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VaultSyncResponse::new)
    }
}

impl ::protobuf::Clear for VaultSyncResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VaultSyncResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VaultSyncResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VaultUnsyncRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VaultUnsyncRequest {
    fn default() -> &'a VaultUnsyncRequest {
        <VaultUnsyncRequest as ::protobuf::Message>::default_instance()
    }
}

impl VaultUnsyncRequest {
    pub fn new() -> VaultUnsyncRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VaultUnsyncRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VaultUnsyncRequest {
        VaultUnsyncRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VaultUnsyncRequest>(
                "VaultUnsyncRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VaultUnsyncRequest {
        static instance: ::protobuf::rt::LazyV2<VaultUnsyncRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VaultUnsyncRequest::new)
    }
}

impl ::protobuf::Clear for VaultUnsyncRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VaultUnsyncRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VaultUnsyncRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VaultUnsyncResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VaultUnsyncResponse {
    fn default() -> &'a VaultUnsyncResponse {
        <VaultUnsyncResponse as ::protobuf::Message>::default_instance()
    }
}

impl VaultUnsyncResponse {
    pub fn new() -> VaultUnsyncResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VaultUnsyncResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VaultUnsyncResponse {
        VaultUnsyncResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VaultUnsyncResponse>(
                "VaultUnsyncResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VaultUnsyncResponse {
        static instance: ::protobuf::rt::LazyV2<VaultUnsyncResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VaultUnsyncResponse::new)
    }
}

impl ::protobuf::Clear for VaultUnsyncResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VaultUnsyncResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VaultUnsyncResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VaultAuthRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VaultAuthRequest {
    fn default() -> &'a VaultAuthRequest {
        <VaultAuthRequest as ::protobuf::Message>::default_instance()
    }
}

impl VaultAuthRequest {
    pub fn new() -> VaultAuthRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VaultAuthRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VaultAuthRequest {
        VaultAuthRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VaultAuthRequest>(
                "VaultAuthRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VaultAuthRequest {
        static instance: ::protobuf::rt::LazyV2<VaultAuthRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VaultAuthRequest::new)
    }
}

impl ::protobuf::Clear for VaultAuthRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VaultAuthRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VaultAuthRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VaultAuthResponse {
    // message fields
    pub phrase: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VaultAuthResponse {
    fn default() -> &'a VaultAuthResponse {
        <VaultAuthResponse as ::protobuf::Message>::default_instance()
    }
}

impl VaultAuthResponse {
    pub fn new() -> VaultAuthResponse {
        ::std::default::Default::default()
    }

    // string phrase = 1;


    pub fn get_phrase(&self) -> &str {
        &self.phrase
    }
    pub fn clear_phrase(&mut self) {
        self.phrase.clear();
    }

    // Param is passed by value, moved
    pub fn set_phrase(&mut self, v: ::std::string::String) {
        self.phrase = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phrase(&mut self) -> &mut ::std::string::String {
        &mut self.phrase
    }

    // Take field
    pub fn take_phrase(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.phrase, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VaultAuthResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.phrase)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.phrase.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.phrase);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.phrase.is_empty() {
            os.write_string(1, &self.phrase)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VaultAuthResponse {
        VaultAuthResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "phrase",
                |m: &VaultAuthResponse| { &m.phrase },
                |m: &mut VaultAuthResponse| { &mut m.phrase },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VaultAuthResponse>(
                "VaultAuthResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VaultAuthResponse {
        static instance: ::protobuf::rt::LazyV2<VaultAuthResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VaultAuthResponse::new)
    }
}

impl ::protobuf::Clear for VaultAuthResponse {
    fn clear(&mut self) {
        self.phrase.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VaultAuthResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VaultAuthResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VaultStatusRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VaultStatusRequest {
    fn default() -> &'a VaultStatusRequest {
        <VaultStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl VaultStatusRequest {
    pub fn new() -> VaultStatusRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VaultStatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VaultStatusRequest {
        VaultStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VaultStatusRequest>(
                "VaultStatusRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VaultStatusRequest {
        static instance: ::protobuf::rt::LazyV2<VaultStatusRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VaultStatusRequest::new)
    }
}

impl ::protobuf::Clear for VaultStatusRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VaultStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VaultStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VaultStatusResponse {
    // message fields
    pub kid: ::std::string::String,
    pub syncedAt: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VaultStatusResponse {
    fn default() -> &'a VaultStatusResponse {
        <VaultStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl VaultStatusResponse {
    pub fn new() -> VaultStatusResponse {
        ::std::default::Default::default()
    }

    // string kid = 1;


    pub fn get_kid(&self) -> &str {
        &self.kid
    }
    pub fn clear_kid(&mut self) {
        self.kid.clear();
    }

    // Param is passed by value, moved
    pub fn set_kid(&mut self, v: ::std::string::String) {
        self.kid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kid(&mut self) -> &mut ::std::string::String {
        &mut self.kid
    }

    // Take field
    pub fn take_kid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kid, ::std::string::String::new())
    }

    // int64 syncedAt = 2;


    pub fn get_syncedAt(&self) -> i64 {
        self.syncedAt
    }
    pub fn clear_syncedAt(&mut self) {
        self.syncedAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_syncedAt(&mut self, v: i64) {
        self.syncedAt = v;
    }
}

impl ::protobuf::Message for VaultStatusResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.syncedAt = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kid);
        }
        if self.syncedAt != 0 {
            my_size += ::protobuf::rt::value_size(2, self.syncedAt, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.kid.is_empty() {
            os.write_string(1, &self.kid)?;
        }
        if self.syncedAt != 0 {
            os.write_int64(2, self.syncedAt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VaultStatusResponse {
        VaultStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kid",
                |m: &VaultStatusResponse| { &m.kid },
                |m: &mut VaultStatusResponse| { &mut m.kid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "syncedAt",
                |m: &VaultStatusResponse| { &m.syncedAt },
                |m: &mut VaultStatusResponse| { &mut m.syncedAt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VaultStatusResponse>(
                "VaultStatusResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VaultStatusResponse {
        static instance: ::protobuf::rt::LazyV2<VaultStatusResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VaultStatusResponse::new)
    }
}

impl ::protobuf::Clear for VaultStatusResponse {
    fn clear(&mut self) {
        self.kid.clear();
        self.syncedAt = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VaultStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VaultStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VaultUpdateRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VaultUpdateRequest {
    fn default() -> &'a VaultUpdateRequest {
        <VaultUpdateRequest as ::protobuf::Message>::default_instance()
    }
}

impl VaultUpdateRequest {
    pub fn new() -> VaultUpdateRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VaultUpdateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VaultUpdateRequest {
        VaultUpdateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VaultUpdateRequest>(
                "VaultUpdateRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VaultUpdateRequest {
        static instance: ::protobuf::rt::LazyV2<VaultUpdateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VaultUpdateRequest::new)
    }
}

impl ::protobuf::Clear for VaultUpdateRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VaultUpdateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VaultUpdateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VaultUpdateResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VaultUpdateResponse {
    fn default() -> &'a VaultUpdateResponse {
        <VaultUpdateResponse as ::protobuf::Message>::default_instance()
    }
}

impl VaultUpdateResponse {
    pub fn new() -> VaultUpdateResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for VaultUpdateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VaultUpdateResponse {
        VaultUpdateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VaultUpdateResponse>(
                "VaultUpdateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VaultUpdateResponse {
        static instance: ::protobuf::rt::LazyV2<VaultUpdateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VaultUpdateResponse::new)
    }
}

impl ::protobuf::Clear for VaultUpdateResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VaultUpdateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VaultUpdateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Message {
    // message fields
    pub id: ::std::string::String,
    pub sender: ::protobuf::SingularPtrField<Key>,
    pub text: ::protobuf::RepeatedField<::std::string::String>,
    pub status: MessageStatus,
    pub createdAt: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Message {
    fn default() -> &'a Message {
        <Message as ::protobuf::Message>::default_instance()
    }
}

impl Message {
    pub fn new() -> Message {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .service.Key sender = 2;


    pub fn get_sender(&self) -> &Key {
        self.sender.as_ref().unwrap_or_else(|| <Key as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    pub fn has_sender(&self) -> bool {
        self.sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: Key) {
        self.sender = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut Key {
        if self.sender.is_none() {
            self.sender.set_default();
        }
        self.sender.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender(&mut self) -> Key {
        self.sender.take().unwrap_or_else(|| Key::new())
    }

    // repeated string text = 10;


    pub fn get_text(&self) -> &[::std::string::String] {
        &self.text
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.text = v;
    }

    // Mutable pointer to the field.
    pub fn mut_text(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.text, ::protobuf::RepeatedField::new())
    }

    // .service.MessageStatus status = 20;


    pub fn get_status(&self) -> MessageStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = MessageStatus::MESSAGE_SENT;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: MessageStatus) {
        self.status = v;
    }

    // int64 createdAt = 31;


    pub fn get_createdAt(&self) -> i64 {
        self.createdAt
    }
    pub fn clear_createdAt(&mut self) {
        self.createdAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_createdAt(&mut self, v: i64) {
        self.createdAt = v;
    }
}

impl ::protobuf::Message for Message {
    fn is_initialized(&self) -> bool {
        for v in &self.sender {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sender)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.text)?;
                },
                20 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 20, &mut self.unknown_fields)?
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.createdAt = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.sender.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.text {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if self.status != MessageStatus::MESSAGE_SENT {
            my_size += ::protobuf::rt::enum_size(20, self.status);
        }
        if self.createdAt != 0 {
            my_size += ::protobuf::rt::value_size(31, self.createdAt, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.sender.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.text {
            os.write_string(10, &v)?;
        };
        if self.status != MessageStatus::MESSAGE_SENT {
            os.write_enum(20, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if self.createdAt != 0 {
            os.write_int64(31, self.createdAt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Message {
        Message::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Message| { &m.id },
                |m: &mut Message| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                "sender",
                |m: &Message| { &m.sender },
                |m: &mut Message| { &mut m.sender },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &Message| { &m.text },
                |m: &mut Message| { &mut m.text },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MessageStatus>>(
                "status",
                |m: &Message| { &m.status },
                |m: &mut Message| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "createdAt",
                |m: &Message| { &m.createdAt },
                |m: &mut Message| { &mut m.createdAt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Message>(
                "Message",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Message {
        static instance: ::protobuf::rt::LazyV2<Message> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Message::new)
    }
}

impl ::protobuf::Clear for Message {
    fn clear(&mut self) {
        self.id.clear();
        self.sender.clear();
        self.text.clear();
        self.status = MessageStatus::MESSAGE_SENT;
        self.createdAt = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Message {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessagePrepareRequest {
    // message fields
    pub sender: ::std::string::String,
    pub channel: ::std::string::String,
    pub text: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessagePrepareRequest {
    fn default() -> &'a MessagePrepareRequest {
        <MessagePrepareRequest as ::protobuf::Message>::default_instance()
    }
}

impl MessagePrepareRequest {
    pub fn new() -> MessagePrepareRequest {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string channel = 2;


    pub fn get_channel(&self) -> &str {
        &self.channel
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: ::std::string::String) {
        self.channel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut ::std::string::String {
        &mut self.channel
    }

    // Take field
    pub fn take_channel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel, ::std::string::String::new())
    }

    // string text = 11;


    pub fn get_text(&self) -> &str {
        &self.text
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.text, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MessagePrepareRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.channel.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel);
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.channel.is_empty() {
            os.write_string(2, &self.channel)?;
        }
        if !self.text.is_empty() {
            os.write_string(11, &self.text)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessagePrepareRequest {
        MessagePrepareRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sender",
                |m: &MessagePrepareRequest| { &m.sender },
                |m: &mut MessagePrepareRequest| { &mut m.sender },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "channel",
                |m: &MessagePrepareRequest| { &m.channel },
                |m: &mut MessagePrepareRequest| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &MessagePrepareRequest| { &m.text },
                |m: &mut MessagePrepareRequest| { &mut m.text },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessagePrepareRequest>(
                "MessagePrepareRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MessagePrepareRequest {
        static instance: ::protobuf::rt::LazyV2<MessagePrepareRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MessagePrepareRequest::new)
    }
}

impl ::protobuf::Clear for MessagePrepareRequest {
    fn clear(&mut self) {
        self.sender.clear();
        self.channel.clear();
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessagePrepareRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessagePrepareRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessagePrepareResponse {
    // message fields
    pub message: ::protobuf::SingularPtrField<Message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessagePrepareResponse {
    fn default() -> &'a MessagePrepareResponse {
        <MessagePrepareResponse as ::protobuf::Message>::default_instance()
    }
}

impl MessagePrepareResponse {
    pub fn new() -> MessagePrepareResponse {
        ::std::default::Default::default()
    }

    // .service.Message message = 1;


    pub fn get_message(&self) -> &Message {
        self.message.as_ref().unwrap_or_else(|| <Message as ::protobuf::Message>::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: Message) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut Message {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> Message {
        self.message.take().unwrap_or_else(|| Message::new())
    }
}

impl ::protobuf::Message for MessagePrepareResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessagePrepareResponse {
        MessagePrepareResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Message>>(
                "message",
                |m: &MessagePrepareResponse| { &m.message },
                |m: &mut MessagePrepareResponse| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessagePrepareResponse>(
                "MessagePrepareResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MessagePrepareResponse {
        static instance: ::protobuf::rt::LazyV2<MessagePrepareResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MessagePrepareResponse::new)
    }
}

impl ::protobuf::Clear for MessagePrepareResponse {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessagePrepareResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessagePrepareResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageCreateRequest {
    // message fields
    pub sender: ::std::string::String,
    pub channel: ::std::string::String,
    pub id: ::std::string::String,
    pub text: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageCreateRequest {
    fn default() -> &'a MessageCreateRequest {
        <MessageCreateRequest as ::protobuf::Message>::default_instance()
    }
}

impl MessageCreateRequest {
    pub fn new() -> MessageCreateRequest {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string channel = 2;


    pub fn get_channel(&self) -> &str {
        &self.channel
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: ::std::string::String) {
        self.channel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut ::std::string::String {
        &mut self.channel
    }

    // Take field
    pub fn take_channel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel, ::std::string::String::new())
    }

    // string id = 10;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string text = 11;


    pub fn get_text(&self) -> &str {
        &self.text
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.text, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MessageCreateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.channel.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.id);
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.channel.is_empty() {
            os.write_string(2, &self.channel)?;
        }
        if !self.id.is_empty() {
            os.write_string(10, &self.id)?;
        }
        if !self.text.is_empty() {
            os.write_string(11, &self.text)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageCreateRequest {
        MessageCreateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sender",
                |m: &MessageCreateRequest| { &m.sender },
                |m: &mut MessageCreateRequest| { &mut m.sender },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "channel",
                |m: &MessageCreateRequest| { &m.channel },
                |m: &mut MessageCreateRequest| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &MessageCreateRequest| { &m.id },
                |m: &mut MessageCreateRequest| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &MessageCreateRequest| { &m.text },
                |m: &mut MessageCreateRequest| { &mut m.text },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessageCreateRequest>(
                "MessageCreateRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MessageCreateRequest {
        static instance: ::protobuf::rt::LazyV2<MessageCreateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MessageCreateRequest::new)
    }
}

impl ::protobuf::Clear for MessageCreateRequest {
    fn clear(&mut self) {
        self.sender.clear();
        self.channel.clear();
        self.id.clear();
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageCreateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageCreateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessageCreateResponse {
    // message fields
    pub message: ::protobuf::SingularPtrField<Message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessageCreateResponse {
    fn default() -> &'a MessageCreateResponse {
        <MessageCreateResponse as ::protobuf::Message>::default_instance()
    }
}

impl MessageCreateResponse {
    pub fn new() -> MessageCreateResponse {
        ::std::default::Default::default()
    }

    // .service.Message message = 1;


    pub fn get_message(&self) -> &Message {
        self.message.as_ref().unwrap_or_else(|| <Message as ::protobuf::Message>::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: Message) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut Message {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> Message {
        self.message.take().unwrap_or_else(|| Message::new())
    }
}

impl ::protobuf::Message for MessageCreateResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessageCreateResponse {
        MessageCreateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Message>>(
                "message",
                |m: &MessageCreateResponse| { &m.message },
                |m: &mut MessageCreateResponse| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessageCreateResponse>(
                "MessageCreateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MessageCreateResponse {
        static instance: ::protobuf::rt::LazyV2<MessageCreateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MessageCreateResponse::new)
    }
}

impl ::protobuf::Clear for MessageCreateResponse {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessageCreateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageCreateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessagesRequest {
    // message fields
    pub channel: ::std::string::String,
    pub update: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessagesRequest {
    fn default() -> &'a MessagesRequest {
        <MessagesRequest as ::protobuf::Message>::default_instance()
    }
}

impl MessagesRequest {
    pub fn new() -> MessagesRequest {
        ::std::default::Default::default()
    }

    // string channel = 1;


    pub fn get_channel(&self) -> &str {
        &self.channel
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: ::std::string::String) {
        self.channel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut ::std::string::String {
        &mut self.channel
    }

    // Take field
    pub fn take_channel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel, ::std::string::String::new())
    }

    // bool update = 5;


    pub fn get_update(&self) -> bool {
        self.update
    }
    pub fn clear_update(&mut self) {
        self.update = false;
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: bool) {
        self.update = v;
    }
}

impl ::protobuf::Message for MessagesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.update = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.channel.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel);
        }
        if self.update != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.channel.is_empty() {
            os.write_string(1, &self.channel)?;
        }
        if self.update != false {
            os.write_bool(5, self.update)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessagesRequest {
        MessagesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "channel",
                |m: &MessagesRequest| { &m.channel },
                |m: &mut MessagesRequest| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "update",
                |m: &MessagesRequest| { &m.update },
                |m: &mut MessagesRequest| { &mut m.update },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessagesRequest>(
                "MessagesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MessagesRequest {
        static instance: ::protobuf::rt::LazyV2<MessagesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MessagesRequest::new)
    }
}

impl ::protobuf::Clear for MessagesRequest {
    fn clear(&mut self) {
        self.channel.clear();
        self.update = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessagesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessagesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MessagesResponse {
    // message fields
    pub messages: ::protobuf::RepeatedField<Message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MessagesResponse {
    fn default() -> &'a MessagesResponse {
        <MessagesResponse as ::protobuf::Message>::default_instance()
    }
}

impl MessagesResponse {
    pub fn new() -> MessagesResponse {
        ::std::default::Default::default()
    }

    // repeated .service.Message messages = 1;


    pub fn get_messages(&self) -> &[Message] {
        &self.messages
    }
    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::protobuf::RepeatedField<Message>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::protobuf::RepeatedField<Message> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::protobuf::RepeatedField<Message> {
        ::std::mem::replace(&mut self.messages, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MessagesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.messages {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.messages)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.messages {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MessagesResponse {
        MessagesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Message>>(
                "messages",
                |m: &MessagesResponse| { &m.messages },
                |m: &mut MessagesResponse| { &mut m.messages },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MessagesResponse>(
                "MessagesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MessagesResponse {
        static instance: ::protobuf::rt::LazyV2<MessagesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MessagesResponse::new)
    }
}

impl ::protobuf::Clear for MessagesResponse {
    fn clear(&mut self) {
        self.messages.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MessagesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessagesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelayRequest {
    // message fields
    pub keys: ::protobuf::RepeatedField<::std::string::String>,
    pub user: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelayRequest {
    fn default() -> &'a RelayRequest {
        <RelayRequest as ::protobuf::Message>::default_instance()
    }
}

impl RelayRequest {
    pub fn new() -> RelayRequest {
        ::std::default::Default::default()
    }

    // repeated string keys = 1;


    pub fn get_keys(&self) -> &[::std::string::String] {
        &self.keys
    }
    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }

    // string user = 2;


    pub fn get_user(&self) -> &str {
        &self.user
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        &mut self.user
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RelayRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.keys)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.keys {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.user.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.user);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.keys {
            os.write_string(1, &v)?;
        };
        if !self.user.is_empty() {
            os.write_string(2, &self.user)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelayRequest {
        RelayRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "keys",
                |m: &RelayRequest| { &m.keys },
                |m: &mut RelayRequest| { &mut m.keys },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user",
                |m: &RelayRequest| { &m.user },
                |m: &mut RelayRequest| { &mut m.user },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RelayRequest>(
                "RelayRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RelayRequest {
        static instance: ::protobuf::rt::LazyV2<RelayRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RelayRequest::new)
    }
}

impl ::protobuf::Clear for RelayRequest {
    fn clear(&mut self) {
        self.keys.clear();
        self.user.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelayRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelayRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RelayOutput {
    // message fields
    pub channel: ::std::string::String,
    pub user: ::std::string::String,
    pub index: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RelayOutput {
    fn default() -> &'a RelayOutput {
        <RelayOutput as ::protobuf::Message>::default_instance()
    }
}

impl RelayOutput {
    pub fn new() -> RelayOutput {
        ::std::default::Default::default()
    }

    // string channel = 1;


    pub fn get_channel(&self) -> &str {
        &self.channel
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: ::std::string::String) {
        self.channel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut ::std::string::String {
        &mut self.channel
    }

    // Take field
    pub fn take_channel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel, ::std::string::String::new())
    }

    // string user = 2;


    pub fn get_user(&self) -> &str {
        &self.user
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        &mut self.user
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user, ::std::string::String::new())
    }

    // int64 index = 3;


    pub fn get_index(&self) -> i64 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i64) {
        self.index = v;
    }
}

impl ::protobuf::Message for RelayOutput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.channel.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel);
        }
        if !self.user.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.user);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(3, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.channel.is_empty() {
            os.write_string(1, &self.channel)?;
        }
        if !self.user.is_empty() {
            os.write_string(2, &self.user)?;
        }
        if self.index != 0 {
            os.write_int64(3, self.index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RelayOutput {
        RelayOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "channel",
                |m: &RelayOutput| { &m.channel },
                |m: &mut RelayOutput| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user",
                |m: &RelayOutput| { &m.user },
                |m: &mut RelayOutput| { &mut m.user },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "index",
                |m: &RelayOutput| { &m.index },
                |m: &mut RelayOutput| { &mut m.index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RelayOutput>(
                "RelayOutput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RelayOutput {
        static instance: ::protobuf::rt::LazyV2<RelayOutput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RelayOutput::new)
    }
}

impl ::protobuf::Clear for RelayOutput {
    fn clear(&mut self) {
        self.channel.clear();
        self.user.clear();
        self.index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RelayOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelayOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Channel {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub snippet: ::std::string::String,
    pub updatedAt: i64,
    pub index: i64,
    pub readIndex: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Channel {
    fn default() -> &'a Channel {
        <Channel as ::protobuf::Message>::default_instance()
    }
}

impl Channel {
    pub fn new() -> Channel {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string snippet = 3;


    pub fn get_snippet(&self) -> &str {
        &self.snippet
    }
    pub fn clear_snippet(&mut self) {
        self.snippet.clear();
    }

    // Param is passed by value, moved
    pub fn set_snippet(&mut self, v: ::std::string::String) {
        self.snippet = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_snippet(&mut self) -> &mut ::std::string::String {
        &mut self.snippet
    }

    // Take field
    pub fn take_snippet(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.snippet, ::std::string::String::new())
    }

    // int64 updatedAt = 4;


    pub fn get_updatedAt(&self) -> i64 {
        self.updatedAt
    }
    pub fn clear_updatedAt(&mut self) {
        self.updatedAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_updatedAt(&mut self, v: i64) {
        self.updatedAt = v;
    }

    // int64 index = 5;


    pub fn get_index(&self) -> i64 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i64) {
        self.index = v;
    }

    // int64 readIndex = 10;


    pub fn get_readIndex(&self) -> i64 {
        self.readIndex
    }
    pub fn clear_readIndex(&mut self) {
        self.readIndex = 0;
    }

    // Param is passed by value, moved
    pub fn set_readIndex(&mut self, v: i64) {
        self.readIndex = v;
    }
}

impl ::protobuf::Message for Channel {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.snippet)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.updatedAt = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.index = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.readIndex = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.snippet.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.snippet);
        }
        if self.updatedAt != 0 {
            my_size += ::protobuf::rt::value_size(4, self.updatedAt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(5, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.readIndex != 0 {
            my_size += ::protobuf::rt::value_size(10, self.readIndex, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.snippet.is_empty() {
            os.write_string(3, &self.snippet)?;
        }
        if self.updatedAt != 0 {
            os.write_int64(4, self.updatedAt)?;
        }
        if self.index != 0 {
            os.write_int64(5, self.index)?;
        }
        if self.readIndex != 0 {
            os.write_int64(10, self.readIndex)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Channel {
        Channel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Channel| { &m.id },
                |m: &mut Channel| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Channel| { &m.name },
                |m: &mut Channel| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "snippet",
                |m: &Channel| { &m.snippet },
                |m: &mut Channel| { &mut m.snippet },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "updatedAt",
                |m: &Channel| { &m.updatedAt },
                |m: &mut Channel| { &mut m.updatedAt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "index",
                |m: &Channel| { &m.index },
                |m: &mut Channel| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "readIndex",
                |m: &Channel| { &m.readIndex },
                |m: &mut Channel| { &mut m.readIndex },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Channel>(
                "Channel",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Channel {
        static instance: ::protobuf::rt::LazyV2<Channel> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Channel::new)
    }
}

impl ::protobuf::Clear for Channel {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.snippet.clear();
        self.updatedAt = 0;
        self.index = 0;
        self.readIndex = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Channel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Channel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelsRequest {
    // message fields
    pub user: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelsRequest {
    fn default() -> &'a ChannelsRequest {
        <ChannelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ChannelsRequest {
    pub fn new() -> ChannelsRequest {
        ::std::default::Default::default()
    }

    // string user = 1;


    pub fn get_user(&self) -> &str {
        &self.user
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        &mut self.user
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ChannelsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.user.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.user);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.user.is_empty() {
            os.write_string(1, &self.user)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelsRequest {
        ChannelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user",
                |m: &ChannelsRequest| { &m.user },
                |m: &mut ChannelsRequest| { &mut m.user },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelsRequest>(
                "ChannelsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelsRequest {
        static instance: ::protobuf::rt::LazyV2<ChannelsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelsRequest::new)
    }
}

impl ::protobuf::Clear for ChannelsRequest {
    fn clear(&mut self) {
        self.user.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelsResponse {
    // message fields
    pub channels: ::protobuf::RepeatedField<Channel>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelsResponse {
    fn default() -> &'a ChannelsResponse {
        <ChannelsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ChannelsResponse {
    pub fn new() -> ChannelsResponse {
        ::std::default::Default::default()
    }

    // repeated .service.Channel channels = 1;


    pub fn get_channels(&self) -> &[Channel] {
        &self.channels
    }
    pub fn clear_channels(&mut self) {
        self.channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: ::protobuf::RepeatedField<Channel>) {
        self.channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channels(&mut self) -> &mut ::protobuf::RepeatedField<Channel> {
        &mut self.channels
    }

    // Take field
    pub fn take_channels(&mut self) -> ::protobuf::RepeatedField<Channel> {
        ::std::mem::replace(&mut self.channels, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ChannelsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.channels {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.channels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.channels {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelsResponse {
        ChannelsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Channel>>(
                "channels",
                |m: &ChannelsResponse| { &m.channels },
                |m: &mut ChannelsResponse| { &mut m.channels },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelsResponse>(
                "ChannelsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelsResponse {
        static instance: ::protobuf::rt::LazyV2<ChannelsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelsResponse::new)
    }
}

impl ::protobuf::Clear for ChannelsResponse {
    fn clear(&mut self) {
        self.channels.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelCreateRequest {
    // message fields
    pub name: ::std::string::String,
    pub user: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelCreateRequest {
    fn default() -> &'a ChannelCreateRequest {
        <ChannelCreateRequest as ::protobuf::Message>::default_instance()
    }
}

impl ChannelCreateRequest {
    pub fn new() -> ChannelCreateRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string user = 2;


    pub fn get_user(&self) -> &str {
        &self.user
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        &mut self.user
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.user, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ChannelCreateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.user)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.user.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.user);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.user.is_empty() {
            os.write_string(2, &self.user)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelCreateRequest {
        ChannelCreateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ChannelCreateRequest| { &m.name },
                |m: &mut ChannelCreateRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user",
                |m: &ChannelCreateRequest| { &m.user },
                |m: &mut ChannelCreateRequest| { &mut m.user },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelCreateRequest>(
                "ChannelCreateRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelCreateRequest {
        static instance: ::protobuf::rt::LazyV2<ChannelCreateRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelCreateRequest::new)
    }
}

impl ::protobuf::Clear for ChannelCreateRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.user.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelCreateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelCreateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelCreateResponse {
    // message fields
    pub channel: ::protobuf::SingularPtrField<Channel>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelCreateResponse {
    fn default() -> &'a ChannelCreateResponse {
        <ChannelCreateResponse as ::protobuf::Message>::default_instance()
    }
}

impl ChannelCreateResponse {
    pub fn new() -> ChannelCreateResponse {
        ::std::default::Default::default()
    }

    // .service.Channel channel = 1;


    pub fn get_channel(&self) -> &Channel {
        self.channel.as_ref().unwrap_or_else(|| <Channel as ::protobuf::Message>::default_instance())
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: Channel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut Channel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> Channel {
        self.channel.take().unwrap_or_else(|| Channel::new())
    }
}

impl ::protobuf::Message for ChannelCreateResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelCreateResponse {
        ChannelCreateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Channel>>(
                "channel",
                |m: &ChannelCreateResponse| { &m.channel },
                |m: &mut ChannelCreateResponse| { &mut m.channel },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelCreateResponse>(
                "ChannelCreateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelCreateResponse {
        static instance: ::protobuf::rt::LazyV2<ChannelCreateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelCreateResponse::new)
    }
}

impl ::protobuf::Clear for ChannelCreateResponse {
    fn clear(&mut self) {
        self.channel.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelCreateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelCreateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelLeaveRequest {
    // message fields
    pub channel: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelLeaveRequest {
    fn default() -> &'a ChannelLeaveRequest {
        <ChannelLeaveRequest as ::protobuf::Message>::default_instance()
    }
}

impl ChannelLeaveRequest {
    pub fn new() -> ChannelLeaveRequest {
        ::std::default::Default::default()
    }

    // string channel = 1;


    pub fn get_channel(&self) -> &str {
        &self.channel
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: ::std::string::String) {
        self.channel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut ::std::string::String {
        &mut self.channel
    }

    // Take field
    pub fn take_channel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ChannelLeaveRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.channel.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.channel.is_empty() {
            os.write_string(1, &self.channel)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelLeaveRequest {
        ChannelLeaveRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "channel",
                |m: &ChannelLeaveRequest| { &m.channel },
                |m: &mut ChannelLeaveRequest| { &mut m.channel },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelLeaveRequest>(
                "ChannelLeaveRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelLeaveRequest {
        static instance: ::protobuf::rt::LazyV2<ChannelLeaveRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelLeaveRequest::new)
    }
}

impl ::protobuf::Clear for ChannelLeaveRequest {
    fn clear(&mut self) {
        self.channel.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelLeaveRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelLeaveRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelLeaveResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelLeaveResponse {
    fn default() -> &'a ChannelLeaveResponse {
        <ChannelLeaveResponse as ::protobuf::Message>::default_instance()
    }
}

impl ChannelLeaveResponse {
    pub fn new() -> ChannelLeaveResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ChannelLeaveResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelLeaveResponse {
        ChannelLeaveResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelLeaveResponse>(
                "ChannelLeaveResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelLeaveResponse {
        static instance: ::protobuf::rt::LazyV2<ChannelLeaveResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelLeaveResponse::new)
    }
}

impl ::protobuf::Clear for ChannelLeaveResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelLeaveResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelLeaveResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelReadRequest {
    // message fields
    pub channel: ::std::string::String,
    pub index: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelReadRequest {
    fn default() -> &'a ChannelReadRequest {
        <ChannelReadRequest as ::protobuf::Message>::default_instance()
    }
}

impl ChannelReadRequest {
    pub fn new() -> ChannelReadRequest {
        ::std::default::Default::default()
    }

    // string channel = 1;


    pub fn get_channel(&self) -> &str {
        &self.channel
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: ::std::string::String) {
        self.channel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut ::std::string::String {
        &mut self.channel
    }

    // Take field
    pub fn take_channel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel, ::std::string::String::new())
    }

    // int64 index = 2;


    pub fn get_index(&self) -> i64 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i64) {
        self.index = v;
    }
}

impl ::protobuf::Message for ChannelReadRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.channel.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.channel.is_empty() {
            os.write_string(1, &self.channel)?;
        }
        if self.index != 0 {
            os.write_int64(2, self.index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelReadRequest {
        ChannelReadRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "channel",
                |m: &ChannelReadRequest| { &m.channel },
                |m: &mut ChannelReadRequest| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "index",
                |m: &ChannelReadRequest| { &m.index },
                |m: &mut ChannelReadRequest| { &mut m.index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelReadRequest>(
                "ChannelReadRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelReadRequest {
        static instance: ::protobuf::rt::LazyV2<ChannelReadRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelReadRequest::new)
    }
}

impl ::protobuf::Clear for ChannelReadRequest {
    fn clear(&mut self) {
        self.channel.clear();
        self.index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelReadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelReadRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelReadResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelReadResponse {
    fn default() -> &'a ChannelReadResponse {
        <ChannelReadResponse as ::protobuf::Message>::default_instance()
    }
}

impl ChannelReadResponse {
    pub fn new() -> ChannelReadResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ChannelReadResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelReadResponse {
        ChannelReadResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelReadResponse>(
                "ChannelReadResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelReadResponse {
        static instance: ::protobuf::rt::LazyV2<ChannelReadResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelReadResponse::new)
    }
}

impl ::protobuf::Clear for ChannelReadResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelReadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelReadResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelInviteRequest {
    // message fields
    pub channel: ::std::string::String,
    pub recipients: ::protobuf::RepeatedField<::std::string::String>,
    pub sender: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelInviteRequest {
    fn default() -> &'a ChannelInviteRequest {
        <ChannelInviteRequest as ::protobuf::Message>::default_instance()
    }
}

impl ChannelInviteRequest {
    pub fn new() -> ChannelInviteRequest {
        ::std::default::Default::default()
    }

    // string channel = 1;


    pub fn get_channel(&self) -> &str {
        &self.channel
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: ::std::string::String) {
        self.channel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut ::std::string::String {
        &mut self.channel
    }

    // Take field
    pub fn take_channel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel, ::std::string::String::new())
    }

    // repeated string recipients = 2;


    pub fn get_recipients(&self) -> &[::std::string::String] {
        &self.recipients
    }
    pub fn clear_recipients(&mut self) {
        self.recipients.clear();
    }

    // Param is passed by value, moved
    pub fn set_recipients(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.recipients = v;
    }

    // Mutable pointer to the field.
    pub fn mut_recipients(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.recipients
    }

    // Take field
    pub fn take_recipients(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.recipients, ::protobuf::RepeatedField::new())
    }

    // string sender = 3;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ChannelInviteRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.recipients)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.channel.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel);
        }
        for value in &self.recipients {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.sender);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.channel.is_empty() {
            os.write_string(1, &self.channel)?;
        }
        for v in &self.recipients {
            os.write_string(2, &v)?;
        };
        if !self.sender.is_empty() {
            os.write_string(3, &self.sender)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelInviteRequest {
        ChannelInviteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "channel",
                |m: &ChannelInviteRequest| { &m.channel },
                |m: &mut ChannelInviteRequest| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "recipients",
                |m: &ChannelInviteRequest| { &m.recipients },
                |m: &mut ChannelInviteRequest| { &mut m.recipients },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sender",
                |m: &ChannelInviteRequest| { &m.sender },
                |m: &mut ChannelInviteRequest| { &mut m.sender },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelInviteRequest>(
                "ChannelInviteRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelInviteRequest {
        static instance: ::protobuf::rt::LazyV2<ChannelInviteRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelInviteRequest::new)
    }
}

impl ::protobuf::Clear for ChannelInviteRequest {
    fn clear(&mut self) {
        self.channel.clear();
        self.recipients.clear();
        self.sender.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelInviteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelInviteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelInviteResponse {
    // message fields
    pub message: ::protobuf::SingularPtrField<Message>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelInviteResponse {
    fn default() -> &'a ChannelInviteResponse {
        <ChannelInviteResponse as ::protobuf::Message>::default_instance()
    }
}

impl ChannelInviteResponse {
    pub fn new() -> ChannelInviteResponse {
        ::std::default::Default::default()
    }

    // .service.Message message = 1;


    pub fn get_message(&self) -> &Message {
        self.message.as_ref().unwrap_or_else(|| <Message as ::protobuf::Message>::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: Message) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut Message {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> Message {
        self.message.take().unwrap_or_else(|| Message::new())
    }
}

impl ::protobuf::Message for ChannelInviteResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelInviteResponse {
        ChannelInviteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Message>>(
                "message",
                |m: &ChannelInviteResponse| { &m.message },
                |m: &mut ChannelInviteResponse| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelInviteResponse>(
                "ChannelInviteResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelInviteResponse {
        static instance: ::protobuf::rt::LazyV2<ChannelInviteResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelInviteResponse::new)
    }
}

impl ::protobuf::Clear for ChannelInviteResponse {
    fn clear(&mut self) {
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelInviteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelInviteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Follow {
    // message fields
    pub recipient: ::std::string::String,
    pub sender: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Follow {
    fn default() -> &'a Follow {
        <Follow as ::protobuf::Message>::default_instance()
    }
}

impl Follow {
    pub fn new() -> Follow {
        ::std::default::Default::default()
    }

    // string recipient = 1;


    pub fn get_recipient(&self) -> &str {
        &self.recipient
    }
    pub fn clear_recipient(&mut self) {
        self.recipient.clear();
    }

    // Param is passed by value, moved
    pub fn set_recipient(&mut self, v: ::std::string::String) {
        self.recipient = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recipient(&mut self) -> &mut ::std::string::String {
        &mut self.recipient
    }

    // Take field
    pub fn take_recipient(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.recipient, ::std::string::String::new())
    }

    // string sender = 2;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Follow {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.recipient)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.recipient.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.recipient);
        }
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sender);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.recipient.is_empty() {
            os.write_string(1, &self.recipient)?;
        }
        if !self.sender.is_empty() {
            os.write_string(2, &self.sender)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Follow {
        Follow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "recipient",
                |m: &Follow| { &m.recipient },
                |m: &mut Follow| { &mut m.recipient },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sender",
                |m: &Follow| { &m.sender },
                |m: &mut Follow| { &mut m.sender },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Follow>(
                "Follow",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Follow {
        static instance: ::protobuf::rt::LazyV2<Follow> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Follow::new)
    }
}

impl ::protobuf::Clear for Follow {
    fn clear(&mut self) {
        self.recipient.clear();
        self.sender.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Follow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Follow {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FollowRequest {
    // message fields
    pub recipient: ::std::string::String,
    pub sender: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FollowRequest {
    fn default() -> &'a FollowRequest {
        <FollowRequest as ::protobuf::Message>::default_instance()
    }
}

impl FollowRequest {
    pub fn new() -> FollowRequest {
        ::std::default::Default::default()
    }

    // string recipient = 1;


    pub fn get_recipient(&self) -> &str {
        &self.recipient
    }
    pub fn clear_recipient(&mut self) {
        self.recipient.clear();
    }

    // Param is passed by value, moved
    pub fn set_recipient(&mut self, v: ::std::string::String) {
        self.recipient = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recipient(&mut self) -> &mut ::std::string::String {
        &mut self.recipient
    }

    // Take field
    pub fn take_recipient(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.recipient, ::std::string::String::new())
    }

    // string sender = 2;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }
}

impl ::protobuf::Message for FollowRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.recipient)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.recipient.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.recipient);
        }
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sender);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.recipient.is_empty() {
            os.write_string(1, &self.recipient)?;
        }
        if !self.sender.is_empty() {
            os.write_string(2, &self.sender)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FollowRequest {
        FollowRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "recipient",
                |m: &FollowRequest| { &m.recipient },
                |m: &mut FollowRequest| { &mut m.recipient },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sender",
                |m: &FollowRequest| { &m.sender },
                |m: &mut FollowRequest| { &mut m.sender },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FollowRequest>(
                "FollowRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FollowRequest {
        static instance: ::protobuf::rt::LazyV2<FollowRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FollowRequest::new)
    }
}

impl ::protobuf::Clear for FollowRequest {
    fn clear(&mut self) {
        self.recipient.clear();
        self.sender.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FollowRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FollowRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FollowResponse {
    // message fields
    pub follow: ::protobuf::SingularPtrField<Follow>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FollowResponse {
    fn default() -> &'a FollowResponse {
        <FollowResponse as ::protobuf::Message>::default_instance()
    }
}

impl FollowResponse {
    pub fn new() -> FollowResponse {
        ::std::default::Default::default()
    }

    // .service.Follow follow = 1;


    pub fn get_follow(&self) -> &Follow {
        self.follow.as_ref().unwrap_or_else(|| <Follow as ::protobuf::Message>::default_instance())
    }
    pub fn clear_follow(&mut self) {
        self.follow.clear();
    }

    pub fn has_follow(&self) -> bool {
        self.follow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_follow(&mut self, v: Follow) {
        self.follow = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_follow(&mut self) -> &mut Follow {
        if self.follow.is_none() {
            self.follow.set_default();
        }
        self.follow.as_mut().unwrap()
    }

    // Take field
    pub fn take_follow(&mut self) -> Follow {
        self.follow.take().unwrap_or_else(|| Follow::new())
    }
}

impl ::protobuf::Message for FollowResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.follow {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.follow)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.follow.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.follow.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FollowResponse {
        FollowResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Follow>>(
                "follow",
                |m: &FollowResponse| { &m.follow },
                |m: &mut FollowResponse| { &mut m.follow },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FollowResponse>(
                "FollowResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FollowResponse {
        static instance: ::protobuf::rt::LazyV2<FollowResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FollowResponse::new)
    }
}

impl ::protobuf::Clear for FollowResponse {
    fn clear(&mut self) {
        self.follow.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FollowResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FollowResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FollowsRequest {
    // message fields
    pub recipient: ::std::string::String,
    pub update: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FollowsRequest {
    fn default() -> &'a FollowsRequest {
        <FollowsRequest as ::protobuf::Message>::default_instance()
    }
}

impl FollowsRequest {
    pub fn new() -> FollowsRequest {
        ::std::default::Default::default()
    }

    // string recipient = 1;


    pub fn get_recipient(&self) -> &str {
        &self.recipient
    }
    pub fn clear_recipient(&mut self) {
        self.recipient.clear();
    }

    // Param is passed by value, moved
    pub fn set_recipient(&mut self, v: ::std::string::String) {
        self.recipient = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recipient(&mut self) -> &mut ::std::string::String {
        &mut self.recipient
    }

    // Take field
    pub fn take_recipient(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.recipient, ::std::string::String::new())
    }

    // bool update = 2;


    pub fn get_update(&self) -> bool {
        self.update
    }
    pub fn clear_update(&mut self) {
        self.update = false;
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: bool) {
        self.update = v;
    }
}

impl ::protobuf::Message for FollowsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.recipient)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.update = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.recipient.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.recipient);
        }
        if self.update != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.recipient.is_empty() {
            os.write_string(1, &self.recipient)?;
        }
        if self.update != false {
            os.write_bool(2, self.update)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FollowsRequest {
        FollowsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "recipient",
                |m: &FollowsRequest| { &m.recipient },
                |m: &mut FollowsRequest| { &mut m.recipient },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "update",
                |m: &FollowsRequest| { &m.update },
                |m: &mut FollowsRequest| { &mut m.update },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FollowsRequest>(
                "FollowsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FollowsRequest {
        static instance: ::protobuf::rt::LazyV2<FollowsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FollowsRequest::new)
    }
}

impl ::protobuf::Clear for FollowsRequest {
    fn clear(&mut self) {
        self.recipient.clear();
        self.update = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FollowsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FollowsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FollowsResponse {
    // message fields
    pub follows: ::protobuf::RepeatedField<Follow>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FollowsResponse {
    fn default() -> &'a FollowsResponse {
        <FollowsResponse as ::protobuf::Message>::default_instance()
    }
}

impl FollowsResponse {
    pub fn new() -> FollowsResponse {
        ::std::default::Default::default()
    }

    // repeated .service.Follow follows = 1;


    pub fn get_follows(&self) -> &[Follow] {
        &self.follows
    }
    pub fn clear_follows(&mut self) {
        self.follows.clear();
    }

    // Param is passed by value, moved
    pub fn set_follows(&mut self, v: ::protobuf::RepeatedField<Follow>) {
        self.follows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_follows(&mut self) -> &mut ::protobuf::RepeatedField<Follow> {
        &mut self.follows
    }

    // Take field
    pub fn take_follows(&mut self) -> ::protobuf::RepeatedField<Follow> {
        ::std::mem::replace(&mut self.follows, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FollowsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.follows {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.follows)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.follows {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.follows {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FollowsResponse {
        FollowsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Follow>>(
                "follows",
                |m: &FollowsResponse| { &m.follows },
                |m: &mut FollowsResponse| { &mut m.follows },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FollowsResponse>(
                "FollowsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FollowsResponse {
        static instance: ::protobuf::rt::LazyV2<FollowsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FollowsResponse::new)
    }
}

impl ::protobuf::Clear for FollowsResponse {
    fn clear(&mut self) {
        self.follows.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FollowsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FollowsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AdminSignURLRequest {
    // message fields
    pub signer: ::std::string::String,
    pub method: ::std::string::String,
    pub url: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AdminSignURLRequest {
    fn default() -> &'a AdminSignURLRequest {
        <AdminSignURLRequest as ::protobuf::Message>::default_instance()
    }
}

impl AdminSignURLRequest {
    pub fn new() -> AdminSignURLRequest {
        ::std::default::Default::default()
    }

    // string signer = 1;


    pub fn get_signer(&self) -> &str {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::string::String) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::string::String {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signer, ::std::string::String::new())
    }

    // string method = 2;


    pub fn get_method(&self) -> &str {
        &self.method
    }
    pub fn clear_method(&mut self) {
        self.method.clear();
    }

    // Param is passed by value, moved
    pub fn set_method(&mut self, v: ::std::string::String) {
        self.method = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method(&mut self) -> &mut ::std::string::String {
        &mut self.method
    }

    // Take field
    pub fn take_method(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.method, ::std::string::String::new())
    }

    // string url = 3;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AdminSignURLRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signer)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.method)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.signer);
        }
        if !self.method.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.method);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.signer.is_empty() {
            os.write_string(1, &self.signer)?;
        }
        if !self.method.is_empty() {
            os.write_string(2, &self.method)?;
        }
        if !self.url.is_empty() {
            os.write_string(3, &self.url)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AdminSignURLRequest {
        AdminSignURLRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signer",
                |m: &AdminSignURLRequest| { &m.signer },
                |m: &mut AdminSignURLRequest| { &mut m.signer },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "method",
                |m: &AdminSignURLRequest| { &m.method },
                |m: &mut AdminSignURLRequest| { &mut m.method },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &AdminSignURLRequest| { &m.url },
                |m: &mut AdminSignURLRequest| { &mut m.url },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AdminSignURLRequest>(
                "AdminSignURLRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AdminSignURLRequest {
        static instance: ::protobuf::rt::LazyV2<AdminSignURLRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AdminSignURLRequest::new)
    }
}

impl ::protobuf::Clear for AdminSignURLRequest {
    fn clear(&mut self) {
        self.signer.clear();
        self.method.clear();
        self.url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AdminSignURLRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdminSignURLRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AdminSignURLResponse {
    // message fields
    pub auth: ::std::string::String,
    pub url: ::std::string::String,
    pub curl: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AdminSignURLResponse {
    fn default() -> &'a AdminSignURLResponse {
        <AdminSignURLResponse as ::protobuf::Message>::default_instance()
    }
}

impl AdminSignURLResponse {
    pub fn new() -> AdminSignURLResponse {
        ::std::default::Default::default()
    }

    // string auth = 1;


    pub fn get_auth(&self) -> &str {
        &self.auth
    }
    pub fn clear_auth(&mut self) {
        self.auth.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth(&mut self, v: ::std::string::String) {
        self.auth = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth(&mut self) -> &mut ::std::string::String {
        &mut self.auth
    }

    // Take field
    pub fn take_auth(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.auth, ::std::string::String::new())
    }

    // string url = 2;


    pub fn get_url(&self) -> &str {
        &self.url
    }
    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        &mut self.url
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.url, ::std::string::String::new())
    }

    // string curl = 3;


    pub fn get_curl(&self) -> &str {
        &self.curl
    }
    pub fn clear_curl(&mut self) {
        self.curl.clear();
    }

    // Param is passed by value, moved
    pub fn set_curl(&mut self, v: ::std::string::String) {
        self.curl = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_curl(&mut self) -> &mut ::std::string::String {
        &mut self.curl
    }

    // Take field
    pub fn take_curl(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.curl, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AdminSignURLResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.auth)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.url)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.curl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.auth.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.auth);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.url);
        }
        if !self.curl.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.curl);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.auth.is_empty() {
            os.write_string(1, &self.auth)?;
        }
        if !self.url.is_empty() {
            os.write_string(2, &self.url)?;
        }
        if !self.curl.is_empty() {
            os.write_string(3, &self.curl)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AdminSignURLResponse {
        AdminSignURLResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "auth",
                |m: &AdminSignURLResponse| { &m.auth },
                |m: &mut AdminSignURLResponse| { &mut m.auth },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "url",
                |m: &AdminSignURLResponse| { &m.url },
                |m: &mut AdminSignURLResponse| { &mut m.url },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "curl",
                |m: &AdminSignURLResponse| { &m.curl },
                |m: &mut AdminSignURLResponse| { &mut m.curl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AdminSignURLResponse>(
                "AdminSignURLResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AdminSignURLResponse {
        static instance: ::protobuf::rt::LazyV2<AdminSignURLResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AdminSignURLResponse::new)
    }
}

impl ::protobuf::Clear for AdminSignURLResponse {
    fn clear(&mut self) {
        self.auth.clear();
        self.url.clear();
        self.curl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AdminSignURLResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdminSignURLResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AdminCheckRequest {
    // message fields
    pub signer: ::std::string::String,
    pub check: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AdminCheckRequest {
    fn default() -> &'a AdminCheckRequest {
        <AdminCheckRequest as ::protobuf::Message>::default_instance()
    }
}

impl AdminCheckRequest {
    pub fn new() -> AdminCheckRequest {
        ::std::default::Default::default()
    }

    // string signer = 1;


    pub fn get_signer(&self) -> &str {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::string::String) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::string::String {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signer, ::std::string::String::new())
    }

    // string check = 2;


    pub fn get_check(&self) -> &str {
        &self.check
    }
    pub fn clear_check(&mut self) {
        self.check.clear();
    }

    // Param is passed by value, moved
    pub fn set_check(&mut self, v: ::std::string::String) {
        self.check = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_check(&mut self) -> &mut ::std::string::String {
        &mut self.check
    }

    // Take field
    pub fn take_check(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.check, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AdminCheckRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signer)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.check)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.signer);
        }
        if !self.check.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.check);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.signer.is_empty() {
            os.write_string(1, &self.signer)?;
        }
        if !self.check.is_empty() {
            os.write_string(2, &self.check)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AdminCheckRequest {
        AdminCheckRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signer",
                |m: &AdminCheckRequest| { &m.signer },
                |m: &mut AdminCheckRequest| { &mut m.signer },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "check",
                |m: &AdminCheckRequest| { &m.check },
                |m: &mut AdminCheckRequest| { &mut m.check },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AdminCheckRequest>(
                "AdminCheckRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AdminCheckRequest {
        static instance: ::protobuf::rt::LazyV2<AdminCheckRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AdminCheckRequest::new)
    }
}

impl ::protobuf::Clear for AdminCheckRequest {
    fn clear(&mut self) {
        self.signer.clear();
        self.check.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AdminCheckRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdminCheckRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AdminCheckResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AdminCheckResponse {
    fn default() -> &'a AdminCheckResponse {
        <AdminCheckResponse as ::protobuf::Message>::default_instance()
    }
}

impl AdminCheckResponse {
    pub fn new() -> AdminCheckResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for AdminCheckResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AdminCheckResponse {
        AdminCheckResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AdminCheckResponse>(
                "AdminCheckResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AdminCheckResponse {
        static instance: ::protobuf::rt::LazyV2<AdminCheckResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AdminCheckResponse::new)
    }
}

impl ::protobuf::Clear for AdminCheckResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AdminCheckResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdminCheckResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Config {
    // message fields
    pub app: ::protobuf::SingularPtrField<Config_App>,
    pub encrypt: ::protobuf::SingularPtrField<Config_Encrypt>,
    pub sign: ::protobuf::SingularPtrField<Config_Sign>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Config {
    fn default() -> &'a Config {
        <Config as ::protobuf::Message>::default_instance()
    }
}

impl Config {
    pub fn new() -> Config {
        ::std::default::Default::default()
    }

    // .service.Config.App app = 1;


    pub fn get_app(&self) -> &Config_App {
        self.app.as_ref().unwrap_or_else(|| <Config_App as ::protobuf::Message>::default_instance())
    }
    pub fn clear_app(&mut self) {
        self.app.clear();
    }

    pub fn has_app(&self) -> bool {
        self.app.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app(&mut self, v: Config_App) {
        self.app = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app(&mut self) -> &mut Config_App {
        if self.app.is_none() {
            self.app.set_default();
        }
        self.app.as_mut().unwrap()
    }

    // Take field
    pub fn take_app(&mut self) -> Config_App {
        self.app.take().unwrap_or_else(|| Config_App::new())
    }

    // .service.Config.Encrypt encrypt = 10;


    pub fn get_encrypt(&self) -> &Config_Encrypt {
        self.encrypt.as_ref().unwrap_or_else(|| <Config_Encrypt as ::protobuf::Message>::default_instance())
    }
    pub fn clear_encrypt(&mut self) {
        self.encrypt.clear();
    }

    pub fn has_encrypt(&self) -> bool {
        self.encrypt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypt(&mut self, v: Config_Encrypt) {
        self.encrypt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypt(&mut self) -> &mut Config_Encrypt {
        if self.encrypt.is_none() {
            self.encrypt.set_default();
        }
        self.encrypt.as_mut().unwrap()
    }

    // Take field
    pub fn take_encrypt(&mut self) -> Config_Encrypt {
        self.encrypt.take().unwrap_or_else(|| Config_Encrypt::new())
    }

    // .service.Config.Sign sign = 11;


    pub fn get_sign(&self) -> &Config_Sign {
        self.sign.as_ref().unwrap_or_else(|| <Config_Sign as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sign(&mut self) {
        self.sign.clear();
    }

    pub fn has_sign(&self) -> bool {
        self.sign.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sign(&mut self, v: Config_Sign) {
        self.sign = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sign(&mut self) -> &mut Config_Sign {
        if self.sign.is_none() {
            self.sign.set_default();
        }
        self.sign.as_mut().unwrap()
    }

    // Take field
    pub fn take_sign(&mut self) -> Config_Sign {
        self.sign.take().unwrap_or_else(|| Config_Sign::new())
    }
}

impl ::protobuf::Message for Config {
    fn is_initialized(&self) -> bool {
        for v in &self.app {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.encrypt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sign {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.app)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encrypt)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sign)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.app.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.encrypt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sign.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.app.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.encrypt.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sign.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Config {
        Config::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Config_App>>(
                "app",
                |m: &Config| { &m.app },
                |m: &mut Config| { &mut m.app },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Config_Encrypt>>(
                "encrypt",
                |m: &Config| { &m.encrypt },
                |m: &mut Config| { &mut m.encrypt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Config_Sign>>(
                "sign",
                |m: &Config| { &m.sign },
                |m: &mut Config| { &mut m.sign },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Config>(
                "Config",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Config {
        static instance: ::protobuf::rt::LazyV2<Config> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Config::new)
    }
}

impl ::protobuf::Clear for Config {
    fn clear(&mut self) {
        self.app.clear();
        self.encrypt.clear();
        self.sign.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Config {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Config {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Config_App {
    // message fields
    pub location: ::std::string::String,
    pub history: ::protobuf::RepeatedField<::std::string::String>,
    pub navMinimized: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Config_App {
    fn default() -> &'a Config_App {
        <Config_App as ::protobuf::Message>::default_instance()
    }
}

impl Config_App {
    pub fn new() -> Config_App {
        ::std::default::Default::default()
    }

    // string location = 1;


    pub fn get_location(&self) -> &str {
        &self.location
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::std::string::String) {
        self.location = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut ::std::string::String {
        &mut self.location
    }

    // Take field
    pub fn take_location(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.location, ::std::string::String::new())
    }

    // repeated string history = 2;


    pub fn get_history(&self) -> &[::std::string::String] {
        &self.history
    }
    pub fn clear_history(&mut self) {
        self.history.clear();
    }

    // Param is passed by value, moved
    pub fn set_history(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.history = v;
    }

    // Mutable pointer to the field.
    pub fn mut_history(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.history
    }

    // Take field
    pub fn take_history(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.history, ::protobuf::RepeatedField::new())
    }

    // bool navMinimized = 100;


    pub fn get_navMinimized(&self) -> bool {
        self.navMinimized
    }
    pub fn clear_navMinimized(&mut self) {
        self.navMinimized = false;
    }

    // Param is passed by value, moved
    pub fn set_navMinimized(&mut self, v: bool) {
        self.navMinimized = v;
    }
}

impl ::protobuf::Message for Config_App {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.location)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.history)?;
                },
                100 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.navMinimized = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.location.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.location);
        }
        for value in &self.history {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.navMinimized != false {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.location.is_empty() {
            os.write_string(1, &self.location)?;
        }
        for v in &self.history {
            os.write_string(2, &v)?;
        };
        if self.navMinimized != false {
            os.write_bool(100, self.navMinimized)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Config_App {
        Config_App::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "location",
                |m: &Config_App| { &m.location },
                |m: &mut Config_App| { &mut m.location },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "history",
                |m: &Config_App| { &m.history },
                |m: &mut Config_App| { &mut m.history },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "navMinimized",
                |m: &Config_App| { &m.navMinimized },
                |m: &mut Config_App| { &mut m.navMinimized },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Config_App>(
                "Config.App",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Config_App {
        static instance: ::protobuf::rt::LazyV2<Config_App> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Config_App::new)
    }
}

impl ::protobuf::Clear for Config_App {
    fn clear(&mut self) {
        self.location.clear();
        self.history.clear();
        self.navMinimized = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Config_App {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Config_App {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Config_Encrypt {
    // message fields
    pub recipients: ::protobuf::RepeatedField<::std::string::String>,
    pub sender: ::std::string::String,
    pub noSenderRecipient: bool,
    pub noSign: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Config_Encrypt {
    fn default() -> &'a Config_Encrypt {
        <Config_Encrypt as ::protobuf::Message>::default_instance()
    }
}

impl Config_Encrypt {
    pub fn new() -> Config_Encrypt {
        ::std::default::Default::default()
    }

    // repeated string recipients = 1;


    pub fn get_recipients(&self) -> &[::std::string::String] {
        &self.recipients
    }
    pub fn clear_recipients(&mut self) {
        self.recipients.clear();
    }

    // Param is passed by value, moved
    pub fn set_recipients(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.recipients = v;
    }

    // Mutable pointer to the field.
    pub fn mut_recipients(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.recipients
    }

    // Take field
    pub fn take_recipients(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.recipients, ::protobuf::RepeatedField::new())
    }

    // string sender = 2;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // bool noSenderRecipient = 3;


    pub fn get_noSenderRecipient(&self) -> bool {
        self.noSenderRecipient
    }
    pub fn clear_noSenderRecipient(&mut self) {
        self.noSenderRecipient = false;
    }

    // Param is passed by value, moved
    pub fn set_noSenderRecipient(&mut self, v: bool) {
        self.noSenderRecipient = v;
    }

    // bool noSign = 4;


    pub fn get_noSign(&self) -> bool {
        self.noSign
    }
    pub fn clear_noSign(&mut self) {
        self.noSign = false;
    }

    // Param is passed by value, moved
    pub fn set_noSign(&mut self, v: bool) {
        self.noSign = v;
    }
}

impl ::protobuf::Message for Config_Encrypt {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.recipients)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.noSenderRecipient = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.noSign = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.recipients {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sender);
        }
        if self.noSenderRecipient != false {
            my_size += 2;
        }
        if self.noSign != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.recipients {
            os.write_string(1, &v)?;
        };
        if !self.sender.is_empty() {
            os.write_string(2, &self.sender)?;
        }
        if self.noSenderRecipient != false {
            os.write_bool(3, self.noSenderRecipient)?;
        }
        if self.noSign != false {
            os.write_bool(4, self.noSign)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Config_Encrypt {
        Config_Encrypt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "recipients",
                |m: &Config_Encrypt| { &m.recipients },
                |m: &mut Config_Encrypt| { &mut m.recipients },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sender",
                |m: &Config_Encrypt| { &m.sender },
                |m: &mut Config_Encrypt| { &mut m.sender },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "noSenderRecipient",
                |m: &Config_Encrypt| { &m.noSenderRecipient },
                |m: &mut Config_Encrypt| { &mut m.noSenderRecipient },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "noSign",
                |m: &Config_Encrypt| { &m.noSign },
                |m: &mut Config_Encrypt| { &mut m.noSign },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Config_Encrypt>(
                "Config.Encrypt",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Config_Encrypt {
        static instance: ::protobuf::rt::LazyV2<Config_Encrypt> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Config_Encrypt::new)
    }
}

impl ::protobuf::Clear for Config_Encrypt {
    fn clear(&mut self) {
        self.recipients.clear();
        self.sender.clear();
        self.noSenderRecipient = false;
        self.noSign = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Config_Encrypt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Config_Encrypt {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Config_Sign {
    // message fields
    pub signer: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Config_Sign {
    fn default() -> &'a Config_Sign {
        <Config_Sign as ::protobuf::Message>::default_instance()
    }
}

impl Config_Sign {
    pub fn new() -> Config_Sign {
        ::std::default::Default::default()
    }

    // string signer = 1;


    pub fn get_signer(&self) -> &str {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::string::String) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::string::String {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signer, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Config_Sign {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.signer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.signer.is_empty() {
            os.write_string(1, &self.signer)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Config_Sign {
        Config_Sign::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signer",
                |m: &Config_Sign| { &m.signer },
                |m: &mut Config_Sign| { &mut m.signer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Config_Sign>(
                "Config.Sign",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Config_Sign {
        static instance: ::protobuf::rt::LazyV2<Config_Sign> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Config_Sign::new)
    }
}

impl ::protobuf::Clear for Config_Sign {
    fn clear(&mut self) {
        self.signer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Config_Sign {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Config_Sign {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigGetRequest {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigGetRequest {
    fn default() -> &'a ConfigGetRequest {
        <ConfigGetRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConfigGetRequest {
    pub fn new() -> ConfigGetRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ConfigGetRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigGetRequest {
        ConfigGetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ConfigGetRequest| { &m.name },
                |m: &mut ConfigGetRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigGetRequest>(
                "ConfigGetRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfigGetRequest {
        static instance: ::protobuf::rt::LazyV2<ConfigGetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigGetRequest::new)
    }
}

impl ::protobuf::Clear for ConfigGetRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigGetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigGetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigGetResponse {
    // message fields
    pub config: ::protobuf::SingularPtrField<Config>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigGetResponse {
    fn default() -> &'a ConfigGetResponse {
        <ConfigGetResponse as ::protobuf::Message>::default_instance()
    }
}

impl ConfigGetResponse {
    pub fn new() -> ConfigGetResponse {
        ::std::default::Default::default()
    }

    // .service.Config config = 1;


    pub fn get_config(&self) -> &Config {
        self.config.as_ref().unwrap_or_else(|| <Config as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: Config) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut Config {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> Config {
        self.config.take().unwrap_or_else(|| Config::new())
    }
}

impl ::protobuf::Message for ConfigGetResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigGetResponse {
        ConfigGetResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Config>>(
                "config",
                |m: &ConfigGetResponse| { &m.config },
                |m: &mut ConfigGetResponse| { &mut m.config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigGetResponse>(
                "ConfigGetResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfigGetResponse {
        static instance: ::protobuf::rt::LazyV2<ConfigGetResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigGetResponse::new)
    }
}

impl ::protobuf::Clear for ConfigGetResponse {
    fn clear(&mut self) {
        self.config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigGetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigGetResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigSetRequest {
    // message fields
    pub name: ::std::string::String,
    pub config: ::protobuf::SingularPtrField<Config>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigSetRequest {
    fn default() -> &'a ConfigSetRequest {
        <ConfigSetRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConfigSetRequest {
    pub fn new() -> ConfigSetRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .service.Config config = 2;


    pub fn get_config(&self) -> &Config {
        self.config.as_ref().unwrap_or_else(|| <Config as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: Config) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut Config {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> Config {
        self.config.take().unwrap_or_else(|| Config::new())
    }
}

impl ::protobuf::Message for ConfigSetRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigSetRequest {
        ConfigSetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ConfigSetRequest| { &m.name },
                |m: &mut ConfigSetRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Config>>(
                "config",
                |m: &ConfigSetRequest| { &m.config },
                |m: &mut ConfigSetRequest| { &mut m.config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigSetRequest>(
                "ConfigSetRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfigSetRequest {
        static instance: ::protobuf::rt::LazyV2<ConfigSetRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigSetRequest::new)
    }
}

impl ::protobuf::Clear for ConfigSetRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigSetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigSetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigSetResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigSetResponse {
    fn default() -> &'a ConfigSetResponse {
        <ConfigSetResponse as ::protobuf::Message>::default_instance()
    }
}

impl ConfigSetResponse {
    pub fn new() -> ConfigSetResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ConfigSetResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigSetResponse {
        ConfigSetResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigSetResponse>(
                "ConfigSetResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfigSetResponse {
        static instance: ::protobuf::rt::LazyV2<ConfigSetResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigSetResponse::new)
    }
}

impl ::protobuf::Clear for ConfigSetResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigSetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigSetResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WormholeInput {
    // message fields
    pub sender: ::std::string::String,
    pub recipient: ::std::string::String,
    pub invite: ::std::string::String,
    pub id: ::std::string::String,
    pub text: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WormholeInput {
    fn default() -> &'a WormholeInput {
        <WormholeInput as ::protobuf::Message>::default_instance()
    }
}

impl WormholeInput {
    pub fn new() -> WormholeInput {
        ::std::default::Default::default()
    }

    // string sender = 1;


    pub fn get_sender(&self) -> &str {
        &self.sender
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: ::std::string::String) {
        self.sender = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut ::std::string::String {
        &mut self.sender
    }

    // Take field
    pub fn take_sender(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sender, ::std::string::String::new())
    }

    // string recipient = 2;


    pub fn get_recipient(&self) -> &str {
        &self.recipient
    }
    pub fn clear_recipient(&mut self) {
        self.recipient.clear();
    }

    // Param is passed by value, moved
    pub fn set_recipient(&mut self, v: ::std::string::String) {
        self.recipient = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recipient(&mut self) -> &mut ::std::string::String {
        &mut self.recipient
    }

    // Take field
    pub fn take_recipient(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.recipient, ::std::string::String::new())
    }

    // string invite = 3;


    pub fn get_invite(&self) -> &str {
        &self.invite
    }
    pub fn clear_invite(&mut self) {
        self.invite.clear();
    }

    // Param is passed by value, moved
    pub fn set_invite(&mut self, v: ::std::string::String) {
        self.invite = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite(&mut self) -> &mut ::std::string::String {
        &mut self.invite
    }

    // Take field
    pub fn take_invite(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.invite, ::std::string::String::new())
    }

    // string id = 10;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string text = 11;


    pub fn get_text(&self) -> &str {
        &self.text
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.text, ::std::string::String::new())
    }
}

impl ::protobuf::Message for WormholeInput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sender)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.recipient)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.invite)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if !self.recipient.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.recipient);
        }
        if !self.invite.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.invite);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.id);
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if !self.recipient.is_empty() {
            os.write_string(2, &self.recipient)?;
        }
        if !self.invite.is_empty() {
            os.write_string(3, &self.invite)?;
        }
        if !self.id.is_empty() {
            os.write_string(10, &self.id)?;
        }
        if !self.text.is_empty() {
            os.write_string(11, &self.text)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WormholeInput {
        WormholeInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sender",
                |m: &WormholeInput| { &m.sender },
                |m: &mut WormholeInput| { &mut m.sender },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "recipient",
                |m: &WormholeInput| { &m.recipient },
                |m: &mut WormholeInput| { &mut m.recipient },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "invite",
                |m: &WormholeInput| { &m.invite },
                |m: &mut WormholeInput| { &mut m.invite },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &WormholeInput| { &m.id },
                |m: &mut WormholeInput| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &WormholeInput| { &m.text },
                |m: &mut WormholeInput| { &mut m.text },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WormholeInput>(
                "WormholeInput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WormholeInput {
        static instance: ::protobuf::rt::LazyV2<WormholeInput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WormholeInput::new)
    }
}

impl ::protobuf::Clear for WormholeInput {
    fn clear(&mut self) {
        self.sender.clear();
        self.recipient.clear();
        self.invite.clear();
        self.id.clear();
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WormholeInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WormholeInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WormholeMessage {
    // message fields
    pub id: ::std::string::String,
    pub sender: ::protobuf::SingularPtrField<Key>,
    pub recipient: ::protobuf::SingularPtrField<Key>,
    pub status: WormholeMessageStatus,
    pub text: ::std::string::String,
    pub createdAt: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WormholeMessage {
    fn default() -> &'a WormholeMessage {
        <WormholeMessage as ::protobuf::Message>::default_instance()
    }
}

impl WormholeMessage {
    pub fn new() -> WormholeMessage {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // .service.Key sender = 2;


    pub fn get_sender(&self) -> &Key {
        self.sender.as_ref().unwrap_or_else(|| <Key as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sender(&mut self) {
        self.sender.clear();
    }

    pub fn has_sender(&self) -> bool {
        self.sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender(&mut self, v: Key) {
        self.sender = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sender(&mut self) -> &mut Key {
        if self.sender.is_none() {
            self.sender.set_default();
        }
        self.sender.as_mut().unwrap()
    }

    // Take field
    pub fn take_sender(&mut self) -> Key {
        self.sender.take().unwrap_or_else(|| Key::new())
    }

    // .service.Key recipient = 3;


    pub fn get_recipient(&self) -> &Key {
        self.recipient.as_ref().unwrap_or_else(|| <Key as ::protobuf::Message>::default_instance())
    }
    pub fn clear_recipient(&mut self) {
        self.recipient.clear();
    }

    pub fn has_recipient(&self) -> bool {
        self.recipient.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient(&mut self, v: Key) {
        self.recipient = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recipient(&mut self) -> &mut Key {
        if self.recipient.is_none() {
            self.recipient.set_default();
        }
        self.recipient.as_mut().unwrap()
    }

    // Take field
    pub fn take_recipient(&mut self) -> Key {
        self.recipient.take().unwrap_or_else(|| Key::new())
    }

    // .service.WormholeMessageStatus status = 5;


    pub fn get_status(&self) -> WormholeMessageStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = WormholeMessageStatus::WORMHOLE_MESSAGE_SENT;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: WormholeMessageStatus) {
        self.status = v;
    }

    // string text = 10;


    pub fn get_text(&self) -> &str {
        &self.text
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.text, ::std::string::String::new())
    }

    // int64 createdAt = 21;


    pub fn get_createdAt(&self) -> i64 {
        self.createdAt
    }
    pub fn clear_createdAt(&mut self) {
        self.createdAt = 0;
    }

    // Param is passed by value, moved
    pub fn set_createdAt(&mut self, v: i64) {
        self.createdAt = v;
    }
}

impl ::protobuf::Message for WormholeMessage {
    fn is_initialized(&self) -> bool {
        for v in &self.sender {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.recipient {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sender)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.recipient)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 5, &mut self.unknown_fields)?
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.text)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.createdAt = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let Some(ref v) = self.sender.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.recipient.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.status != WormholeMessageStatus::WORMHOLE_MESSAGE_SENT {
            my_size += ::protobuf::rt::enum_size(5, self.status);
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.text);
        }
        if self.createdAt != 0 {
            my_size += ::protobuf::rt::value_size(21, self.createdAt, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let Some(ref v) = self.sender.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.recipient.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.status != WormholeMessageStatus::WORMHOLE_MESSAGE_SENT {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if !self.text.is_empty() {
            os.write_string(10, &self.text)?;
        }
        if self.createdAt != 0 {
            os.write_int64(21, self.createdAt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WormholeMessage {
        WormholeMessage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &WormholeMessage| { &m.id },
                |m: &mut WormholeMessage| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                "sender",
                |m: &WormholeMessage| { &m.sender },
                |m: &mut WormholeMessage| { &mut m.sender },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                "recipient",
                |m: &WormholeMessage| { &m.recipient },
                |m: &mut WormholeMessage| { &mut m.recipient },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<WormholeMessageStatus>>(
                "status",
                |m: &WormholeMessage| { &m.status },
                |m: &mut WormholeMessage| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "text",
                |m: &WormholeMessage| { &m.text },
                |m: &mut WormholeMessage| { &mut m.text },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "createdAt",
                |m: &WormholeMessage| { &m.createdAt },
                |m: &mut WormholeMessage| { &mut m.createdAt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WormholeMessage>(
                "WormholeMessage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WormholeMessage {
        static instance: ::protobuf::rt::LazyV2<WormholeMessage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WormholeMessage::new)
    }
}

impl ::protobuf::Clear for WormholeMessage {
    fn clear(&mut self) {
        self.id.clear();
        self.sender.clear();
        self.recipient.clear();
        self.status = WormholeMessageStatus::WORMHOLE_MESSAGE_SENT;
        self.text.clear();
        self.createdAt = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WormholeMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WormholeMessage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WormholeOutput {
    // message fields
    pub message: ::protobuf::SingularPtrField<WormholeMessage>,
    pub status: WormholeStatus,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WormholeOutput {
    fn default() -> &'a WormholeOutput {
        <WormholeOutput as ::protobuf::Message>::default_instance()
    }
}

impl WormholeOutput {
    pub fn new() -> WormholeOutput {
        ::std::default::Default::default()
    }

    // .service.WormholeMessage message = 1;


    pub fn get_message(&self) -> &WormholeMessage {
        self.message.as_ref().unwrap_or_else(|| <WormholeMessage as ::protobuf::Message>::default_instance())
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: WormholeMessage) {
        self.message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut WormholeMessage {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> WormholeMessage {
        self.message.take().unwrap_or_else(|| WormholeMessage::new())
    }

    // .service.WormholeStatus status = 2;


    pub fn get_status(&self) -> WormholeStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = WormholeStatus::WORMHOLE_DEFAULT;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: WormholeStatus) {
        self.status = v;
    }
}

impl ::protobuf::Message for WormholeOutput {
    fn is_initialized(&self) -> bool {
        for v in &self.message {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.message)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.status != WormholeStatus::WORMHOLE_DEFAULT {
            my_size += ::protobuf::rt::enum_size(2, self.status);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.status != WormholeStatus::WORMHOLE_DEFAULT {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WormholeOutput {
        WormholeOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WormholeMessage>>(
                "message",
                |m: &WormholeOutput| { &m.message },
                |m: &mut WormholeOutput| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<WormholeStatus>>(
                "status",
                |m: &WormholeOutput| { &m.status },
                |m: &mut WormholeOutput| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WormholeOutput>(
                "WormholeOutput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WormholeOutput {
        static instance: ::protobuf::rt::LazyV2<WormholeOutput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WormholeOutput::new)
    }
}

impl ::protobuf::Clear for WormholeOutput {
    fn clear(&mut self) {
        self.message.clear();
        self.status = WormholeStatus::WORMHOLE_DEFAULT;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WormholeOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WormholeOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum EncryptMode {
    DEFAULT_ENCRYPT = 0,
    SALTPACK_ENCRYPT = 1,
    SALTPACK_SIGNCRYPT = 3,
}

impl ::protobuf::ProtobufEnum for EncryptMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EncryptMode> {
        match value {
            0 => ::std::option::Option::Some(EncryptMode::DEFAULT_ENCRYPT),
            1 => ::std::option::Option::Some(EncryptMode::SALTPACK_ENCRYPT),
            3 => ::std::option::Option::Some(EncryptMode::SALTPACK_SIGNCRYPT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EncryptMode] = &[
            EncryptMode::DEFAULT_ENCRYPT,
            EncryptMode::SALTPACK_ENCRYPT,
            EncryptMode::SALTPACK_SIGNCRYPT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EncryptMode>("EncryptMode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for EncryptMode {
}

impl ::std::default::Default for EncryptMode {
    fn default() -> Self {
        EncryptMode::DEFAULT_ENCRYPT
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AuthStatus {
    AUTH_UNKNOWN = 0,
    AUTH_SETUP_NEEDED = 1,
    AUTH_UNLOCKED = 2,
    AUTH_LOCKED = 3,
}

impl ::protobuf::ProtobufEnum for AuthStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuthStatus> {
        match value {
            0 => ::std::option::Option::Some(AuthStatus::AUTH_UNKNOWN),
            1 => ::std::option::Option::Some(AuthStatus::AUTH_SETUP_NEEDED),
            2 => ::std::option::Option::Some(AuthStatus::AUTH_UNLOCKED),
            3 => ::std::option::Option::Some(AuthStatus::AUTH_LOCKED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AuthStatus] = &[
            AuthStatus::AUTH_UNKNOWN,
            AuthStatus::AUTH_SETUP_NEEDED,
            AuthStatus::AUTH_UNLOCKED,
            AuthStatus::AUTH_LOCKED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AuthStatus>("AuthStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AuthStatus {
}

impl ::std::default::Default for AuthStatus {
    fn default() -> Self {
        AuthStatus::AUTH_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum AuthType {
    UNKNOWN_AUTH = 0,
    PASSWORD_AUTH = 10,
    PAPER_KEY_AUTH = 11,
    FIDO2_HMAC_SECRET_AUTH = 20,
}

impl ::protobuf::ProtobufEnum for AuthType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AuthType> {
        match value {
            0 => ::std::option::Option::Some(AuthType::UNKNOWN_AUTH),
            10 => ::std::option::Option::Some(AuthType::PASSWORD_AUTH),
            11 => ::std::option::Option::Some(AuthType::PAPER_KEY_AUTH),
            20 => ::std::option::Option::Some(AuthType::FIDO2_HMAC_SECRET_AUTH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [AuthType] = &[
            AuthType::UNKNOWN_AUTH,
            AuthType::PASSWORD_AUTH,
            AuthType::PAPER_KEY_AUTH,
            AuthType::FIDO2_HMAC_SECRET_AUTH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<AuthType>("AuthType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for AuthType {
}

impl ::std::default::Default for AuthType {
    fn default() -> Self {
        AuthType::UNKNOWN_AUTH
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ExportType {
    DEFAULT_EXPORT_TYPE = 0,
    SSH_EXPORT_TYPE = 1,
}

impl ::protobuf::ProtobufEnum for ExportType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ExportType> {
        match value {
            0 => ::std::option::Option::Some(ExportType::DEFAULT_EXPORT_TYPE),
            1 => ::std::option::Option::Some(ExportType::SSH_EXPORT_TYPE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ExportType] = &[
            ExportType::DEFAULT_EXPORT_TYPE,
            ExportType::SSH_EXPORT_TYPE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ExportType>("ExportType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ExportType {
}

impl ::std::default::Default for ExportType {
    fn default() -> Self {
        ExportType::DEFAULT_EXPORT_TYPE
    }
}

impl ::protobuf::reflect::ProtobufValue for ExportType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SortDirection {
    ASC = 0,
    DESC = 1,
}

impl ::protobuf::ProtobufEnum for SortDirection {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SortDirection> {
        match value {
            0 => ::std::option::Option::Some(SortDirection::ASC),
            1 => ::std::option::Option::Some(SortDirection::DESC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SortDirection] = &[
            SortDirection::ASC,
            SortDirection::DESC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SortDirection>("SortDirection", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SortDirection {
}

impl ::std::default::Default for SortDirection {
    fn default() -> Self {
        SortDirection::ASC
    }
}

impl ::protobuf::reflect::ProtobufValue for SortDirection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SecretType {
    UNKNOWN_SECRET_TYPE = 0,
    PASSWORD_SECRET = 10,
    CONTACT_SECRET = 11,
    CARD_SECRET = 12,
    NOTE_SECRET = 13,
}

impl ::protobuf::ProtobufEnum for SecretType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SecretType> {
        match value {
            0 => ::std::option::Option::Some(SecretType::UNKNOWN_SECRET_TYPE),
            10 => ::std::option::Option::Some(SecretType::PASSWORD_SECRET),
            11 => ::std::option::Option::Some(SecretType::CONTACT_SECRET),
            12 => ::std::option::Option::Some(SecretType::CARD_SECRET),
            13 => ::std::option::Option::Some(SecretType::NOTE_SECRET),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SecretType] = &[
            SecretType::UNKNOWN_SECRET_TYPE,
            SecretType::PASSWORD_SECRET,
            SecretType::CONTACT_SECRET,
            SecretType::CARD_SECRET,
            SecretType::NOTE_SECRET,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SecretType>("SecretType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SecretType {
}

impl ::std::default::Default for SecretType {
    fn default() -> Self {
        SecretType::UNKNOWN_SECRET_TYPE
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Encoding {
    HEX = 0,
    BASE62 = 1,
    BASE58 = 2,
    BASE32 = 3,
    BASE16 = 4,
    BASE64 = 5,
    SALTPACK = 6,
    BIP39 = 7,
}

impl ::protobuf::ProtobufEnum for Encoding {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Encoding> {
        match value {
            0 => ::std::option::Option::Some(Encoding::HEX),
            1 => ::std::option::Option::Some(Encoding::BASE62),
            2 => ::std::option::Option::Some(Encoding::BASE58),
            3 => ::std::option::Option::Some(Encoding::BASE32),
            4 => ::std::option::Option::Some(Encoding::BASE16),
            5 => ::std::option::Option::Some(Encoding::BASE64),
            6 => ::std::option::Option::Some(Encoding::SALTPACK),
            7 => ::std::option::Option::Some(Encoding::BIP39),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Encoding] = &[
            Encoding::HEX,
            Encoding::BASE62,
            Encoding::BASE58,
            Encoding::BASE32,
            Encoding::BASE16,
            Encoding::BASE64,
            Encoding::SALTPACK,
            Encoding::BIP39,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Encoding>("Encoding", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Encoding {
}

impl ::std::default::Default for Encoding {
    fn default() -> Self {
        Encoding::HEX
    }
}

impl ::protobuf::reflect::ProtobufValue for Encoding {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum UserStatus {
    USER_UNKNOWN = 0,
    USER_OK = 1,
    USER_RESOURCE_NOT_FOUND = 20,
    USER_CONTENT_NOT_FOUND = 30,
    USER_CONTENT_INVALID = 31,
    USER_CONN_FAILURE = 40,
    USER_FAILURE = 50,
}

impl ::protobuf::ProtobufEnum for UserStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UserStatus> {
        match value {
            0 => ::std::option::Option::Some(UserStatus::USER_UNKNOWN),
            1 => ::std::option::Option::Some(UserStatus::USER_OK),
            20 => ::std::option::Option::Some(UserStatus::USER_RESOURCE_NOT_FOUND),
            30 => ::std::option::Option::Some(UserStatus::USER_CONTENT_NOT_FOUND),
            31 => ::std::option::Option::Some(UserStatus::USER_CONTENT_INVALID),
            40 => ::std::option::Option::Some(UserStatus::USER_CONN_FAILURE),
            50 => ::std::option::Option::Some(UserStatus::USER_FAILURE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UserStatus] = &[
            UserStatus::USER_UNKNOWN,
            UserStatus::USER_OK,
            UserStatus::USER_RESOURCE_NOT_FOUND,
            UserStatus::USER_CONTENT_NOT_FOUND,
            UserStatus::USER_CONTENT_INVALID,
            UserStatus::USER_CONN_FAILURE,
            UserStatus::USER_FAILURE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<UserStatus>("UserStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for UserStatus {
}

impl ::std::default::Default for UserStatus {
    fn default() -> Self {
        UserStatus::USER_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for UserStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MessageStatus {
    MESSAGE_SENT = 0,
    MESSAGE_PENDING = 1,
    MESSAGE_ERROR = 2,
}

impl ::protobuf::ProtobufEnum for MessageStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MessageStatus> {
        match value {
            0 => ::std::option::Option::Some(MessageStatus::MESSAGE_SENT),
            1 => ::std::option::Option::Some(MessageStatus::MESSAGE_PENDING),
            2 => ::std::option::Option::Some(MessageStatus::MESSAGE_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MessageStatus] = &[
            MessageStatus::MESSAGE_SENT,
            MessageStatus::MESSAGE_PENDING,
            MessageStatus::MESSAGE_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<MessageStatus>("MessageStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for MessageStatus {
}

impl ::std::default::Default for MessageStatus {
    fn default() -> Self {
        MessageStatus::MESSAGE_SENT
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum WormholeStatus {
    WORMHOLE_DEFAULT = 0,
    WORMHOLE_STARTING = 10,
    WORMHOLE_OFFERING = 20,
    WORMHOLE_ANSWERING = 21,
    WORMHOLE_HANDSHAKE = 40,
    WORMHOLE_CONNECTED = 100,
    WORMHOLE_CLOSED = 200,
}

impl ::protobuf::ProtobufEnum for WormholeStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WormholeStatus> {
        match value {
            0 => ::std::option::Option::Some(WormholeStatus::WORMHOLE_DEFAULT),
            10 => ::std::option::Option::Some(WormholeStatus::WORMHOLE_STARTING),
            20 => ::std::option::Option::Some(WormholeStatus::WORMHOLE_OFFERING),
            21 => ::std::option::Option::Some(WormholeStatus::WORMHOLE_ANSWERING),
            40 => ::std::option::Option::Some(WormholeStatus::WORMHOLE_HANDSHAKE),
            100 => ::std::option::Option::Some(WormholeStatus::WORMHOLE_CONNECTED),
            200 => ::std::option::Option::Some(WormholeStatus::WORMHOLE_CLOSED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [WormholeStatus] = &[
            WormholeStatus::WORMHOLE_DEFAULT,
            WormholeStatus::WORMHOLE_STARTING,
            WormholeStatus::WORMHOLE_OFFERING,
            WormholeStatus::WORMHOLE_ANSWERING,
            WormholeStatus::WORMHOLE_HANDSHAKE,
            WormholeStatus::WORMHOLE_CONNECTED,
            WormholeStatus::WORMHOLE_CLOSED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<WormholeStatus>("WormholeStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for WormholeStatus {
}

impl ::std::default::Default for WormholeStatus {
    fn default() -> Self {
        WormholeStatus::WORMHOLE_DEFAULT
    }
}

impl ::protobuf::reflect::ProtobufValue for WormholeStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum WormholeMessageStatus {
    WORMHOLE_MESSAGE_SENT = 0,
    WORMHOLE_MESSAGE_PENDING = 1,
    WORMHOLE_MESSAGE_ACK = 2,
}

impl ::protobuf::ProtobufEnum for WormholeMessageStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<WormholeMessageStatus> {
        match value {
            0 => ::std::option::Option::Some(WormholeMessageStatus::WORMHOLE_MESSAGE_SENT),
            1 => ::std::option::Option::Some(WormholeMessageStatus::WORMHOLE_MESSAGE_PENDING),
            2 => ::std::option::Option::Some(WormholeMessageStatus::WORMHOLE_MESSAGE_ACK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [WormholeMessageStatus] = &[
            WormholeMessageStatus::WORMHOLE_MESSAGE_SENT,
            WormholeMessageStatus::WORMHOLE_MESSAGE_PENDING,
            WormholeMessageStatus::WORMHOLE_MESSAGE_ACK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<WormholeMessageStatus>("WormholeMessageStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for WormholeMessageStatus {
}

impl ::std::default::Default for WormholeMessageStatus {
    fn default() -> Self {
        WormholeMessageStatus::WORMHOLE_MESSAGE_SENT
    }
}

impl ::protobuf::reflect::ProtobufValue for WormholeMessageStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11service/rpc.proto\x12\x07service\x1a\x0epatch/go.proto\"o\n\x0bSig\
    nRequest\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\x12\x16\n\x06si\
    gner\x18\x05\x20\x01(\tR\x06signer\x12\x18\n\x07armored\x18\n\x20\x01(\
    \x08R\x07armored\x12\x1a\n\x08detached\x18\x0b\x20\x01(\x08R\x08detached\
    \"?\n\x0cSignResponse\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\
    \x12\x1b\n\x03kid\x18\x02\x20\x01(\tR\x03kidB\t\xca\xb5\x03\x05\n\x03KID\
    \"\x7f\n\rSignFileInput\x12\x0e\n\x02in\x18\x01\x20\x01(\tR\x02in\x12\
    \x10\n\x03out\x18\x02\x20\x01(\tR\x03out\x12\x16\n\x06signer\x18\x05\x20\
    \x01(\tR\x06signer\x12\x18\n\x07armored\x18\n\x20\x01(\x08R\x07armored\
    \x12\x1a\n\x08detached\x18\x0b\x20\x01(\x08R\x08detached\"k\n\x0eSignFil\
    eOutput\x12\x1b\n\x03kid\x18\x01\x20\x01(\tR\x03kidB\t\xca\xb5\x03\x05\n\
    \x03KID\x12\x10\n\x03out\x18\x02\x20\x01(\tR\x03out\x12\x14\n\x05bytes\
    \x18\n\x20\x01(\x05R\x05bytes\x12\x14\n\x05total\x18\x0b\x20\x01(\x05R\
    \x05total\"#\n\rVerifyRequest\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\
    \x04data\"J\n\x0eVerifyResponse\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\
    \x04data\x12$\n\x06signer\x18\x02\x20\x01(\x0b2\x0c.service.KeyR\x06sign\
    er\"=\n\x15VerifyDetachedRequest\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\
    \x04data\x12\x10\n\x03sig\x18\x02\x20\x01(\x0cR\x03sig\">\n\x16VerifyDet\
    achedResponse\x12$\n\x06signer\x18\x01\x20\x01(\x0b2\x0c.service.KeyR\
    \x06signer\"!\n\x0bVerifyInput\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\
    \x04data\"H\n\x0cVerifyOutput\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\
    \x04data\x12$\n\x06signer\x18\x02\x20\x01(\x0b2\x0c.service.KeyR\x06sign\
    er\"3\n\x0fVerifyFileInput\x12\x0e\n\x02in\x18\x01\x20\x01(\tR\x02in\x12\
    \x10\n\x03out\x18\x02\x20\x01(\tR\x03out\"J\n\x10VerifyFileOutput\x12$\n\
    \x06signer\x18\x01\x20\x01(\x0b2\x0c.service.KeyR\x06signer\x12\x10\n\
    \x03out\x18\x02\x20\x01(\tR\x03out\";\n\x17VerifyDetachedFileInput\x12\
    \x0e\n\x02in\x18\x01\x20\x01(\tR\x02in\x12\x10\n\x03sig\x18\x02\x20\x01(\
    \x0cR\x03sig\";\n\x13VerifyDetachedInput\x12\x12\n\x04data\x18\x01\x20\
    \x01(\x0cR\x04data\x12\x10\n\x03sig\x18\x02\x20\x01(\x0cR\x03sig\"\xbe\
    \x01\n\tStatement\x12\x10\n\x03sig\x18\x01\x20\x01(\x0cR\x03sig\x12\x12\
    \n\x04data\x18\x02\x20\x01(\x0cR\x04data\x12\x1b\n\x03kid\x18\x03\x20\
    \x01(\tR\x03kidB\t\xca\xb5\x03\x05\n\x03KID\x12\x10\n\x03seq\x18\x04\x20\
    \x01(\x05R\x03seq\x12\x12\n\x04prev\x18\x05\x20\x01(\x0cR\x04prev\x12\
    \x16\n\x06revoke\x18\x06\x20\x01(\x05R\x06revoke\x12\x1c\n\ttimestamp\
    \x18\x07\x20\x01(\x03R\ttimestamp\x12\x12\n\x04type\x18\x08\x20\x01(\tR\
    \x04type\".\n\x0fSigchainRequest\x12\x1b\n\x03kid\x18\x01\x20\x01(\tR\
    \x03kidB\t\xca\xb5\x03\x05\n\x03KID\"f\n\x10SigchainResponse\x12\x1e\n\
    \x03key\x18\x01\x20\x01(\x0b2\x0c.service.KeyR\x03key\x122\n\nstatements\
    \x18\x02\x20\x03(\x0b2\x12.service.StatementR\nstatements\"A\n\x10Statem\
    entRequest\x12\x1b\n\x03kid\x18\x01\x20\x01(\tR\x03kidB\t\xca\xb5\x03\
    \x05\n\x03KID\x12\x10\n\x03seq\x18\x02\x20\x01(\x05R\x03seq\"E\n\x11Stat\
    ementResponse\x120\n\tstatement\x18\x01\x20\x01(\x0b2\x12.service.Statem\
    entR\tstatement\"_\n\x16StatementCreateRequest\x12\x12\n\x04data\x18\x01\
    \x20\x01(\x0cR\x04data\x12\x1b\n\x03kid\x18\x02\x20\x01(\tR\x03kidB\t\
    \xca\xb5\x03\x05\n\x03KID\x12\x14\n\x05local\x18\x05\x20\x01(\x08R\x05lo\
    cal\"K\n\x17StatementCreateResponse\x120\n\tstatement\x18\x01\x20\x01(\
    \x0b2\x12.service.StatementR\tstatement\"]\n\x16StatementRevokeRequest\
    \x12\x10\n\x03seq\x18\x01\x20\x01(\x05R\x03seq\x12\x1b\n\x03kid\x18\x02\
    \x20\x01(\tR\x03kidB\t\xca\xb5\x03\x05\n\x03KID\x12\x14\n\x05local\x18\
    \x05\x20\x01(\x08R\x05local\"K\n\x17StatementRevokeResponse\x120\n\tstat\
    ement\x18\x01\x20\x01(\x0b2\x12.service.StatementR\tstatement\"\x8f\x01\
    \n\tSignInput\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\x12\x0e\n\
    \x02in\x18\x02\x20\x01(\tR\x02in\x12\x10\n\x03out\x18\x03\x20\x01(\tR\
    \x03out\x12\x16\n\x06signer\x18\x05\x20\x01(\tR\x06signer\x12\x18\n\x07a\
    rmored\x18\n\x20\x01(\x08R\x07armored\x12\x1a\n\x08detached\x18\x0b\x20\
    \x01(\x08R\x08detached\"=\n\nSignOutput\x12\x12\n\x04data\x18\x01\x20\
    \x01(\x0cR\x04data\x12\x1b\n\x03kid\x18\x02\x20\x01(\tR\x03kidB\t\xca\
    \xb5\x03\x05\n\x03KID\"\x9a\x01\n\x0eEncryptOptions\x12\x18\n\x07armored\
    \x18\x01\x20\x01(\x08R\x07armored\x12(\n\x04mode\x18\x02\x20\x01(\x0e2\
    \x14.service.EncryptModeR\x04mode\x12,\n\x11noSenderRecipient\x18\x03\
    \x20\x01(\x08R\x11noSenderRecipient\x12\x16\n\x06noSign\x18\x04\x20\x01(\
    \x08R\x06noSign\"\x8f\x01\n\x0eEncryptRequest\x12\x12\n\x04data\x18\x01\
    \x20\x01(\x0cR\x04data\x12\x1e\n\nrecipients\x18\x03\x20\x03(\tR\nrecipi\
    ents\x12\x16\n\x06sender\x18\x04\x20\x01(\tR\x06sender\x121\n\x07options\
    \x18\n\x20\x01(\x0b2\x17.service.EncryptOptionsR\x07options\"9\n\x0fEncr\
    yptResponse\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\x12\x12\n\
    \x04info\x18\x02\x20\x01(\tR\x04info\"\x9f\x01\n\x10EncryptFileInput\x12\
    \x0e\n\x02in\x18\x01\x20\x01(\tR\x02in\x12\x10\n\x03out\x18\x02\x20\x01(\
    \tR\x03out\x12\x1e\n\nrecipients\x18\x03\x20\x03(\tR\nrecipients\x12\x16\
    \n\x06sender\x18\x04\x20\x01(\tR\x06sender\x121\n\x07options\x18\n\x20\
    \x01(\x0b2\x17.service.EncryptOptionsR\x07options\"Q\n\x11EncryptFileOut\
    put\x12\x10\n\x03out\x18\x02\x20\x01(\tR\x03out\x12\x14\n\x05bytes\x18\n\
    \x20\x01(\x05R\x05bytes\x12\x14\n\x05total\x18\x0b\x20\x01(\x05R\x05tota\
    l\"\x8d\x01\n\x0cEncryptInput\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\
    \x04data\x12\x1e\n\nrecipients\x18\x03\x20\x03(\tR\nrecipients\x12\x16\n\
    \x06sender\x18\x04\x20\x01(\tR\x06sender\x121\n\x07options\x18\n\x20\x01\
    (\x0b2\x17.service.EncryptOptionsR\x07options\"#\n\rEncryptOutput\x12\
    \x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\"$\n\x0eDecryptRequest\x12\
    \x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\"u\n\x0fDecryptResponse\x12\
    \x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\x12$\n\x06sender\x18\x02\
    \x20\x01(\x0b2\x0c.service.KeyR\x06sender\x12(\n\x04mode\x18\x05\x20\x01\
    (\x0e2\x14.service.EncryptModeR\x04mode\"4\n\x10DecryptFileInput\x12\x0e\
    \n\x02in\x18\x01\x20\x01(\tR\x02in\x12\x10\n\x03out\x18\x02\x20\x01(\tR\
    \x03out\"\xa1\x01\n\x11DecryptFileOutput\x12$\n\x06sender\x18\x01\x20\
    \x01(\x0b2\x0c.service.KeyR\x06sender\x12\x10\n\x03out\x18\x02\x20\x01(\
    \tR\x03out\x12\x14\n\x05bytes\x18\n\x20\x01(\x05R\x05bytes\x12\x14\n\x05\
    total\x18\x0b\x20\x01(\x05R\x05total\x12(\n\x04mode\x18\x05\x20\x01(\x0e\
    2\x14.service.EncryptModeR\x04mode\"\"\n\x0cDecryptInput\x12\x12\n\x04da\
    ta\x18\x01\x20\x01(\x0cR\x04data\"s\n\rDecryptOutput\x12\x12\n\x04data\
    \x18\x01\x20\x01(\x0cR\x04data\x12$\n\x06sender\x18\x02\x20\x01(\x0b2\
    \x0c.service.KeyR\x06sender\x12(\n\x04mode\x18\x05\x20\x01(\x0e2\x14.ser\
    vice.EncryptModeR\x04mode\"\x16\n\x14RuntimeStatusRequest\"\xc9\x01\n\
    \x15RuntimeStatusResponse\x12\x18\n\x07version\x18\x01\x20\x01(\tR\x07ve\
    rsion\x12\x18\n\x07appName\x18\x02\x20\x01(\tR\x07appName\x12\x10\n\x03e\
    xe\x18\x04\x20\x01(\tR\x03exe\x123\n\nauthStatus\x18\x05\x20\x01(\x0e2\
    \x13.service.AuthStatusR\nauthStatus\x12\x12\n\x04sync\x18\x06\x20\x01(\
    \x08R\x04sync\x12!\n\x05fido2\x18\x14\x20\x01(\x08R\x05fido2B\x0b\xca\
    \xb5\x03\x07\n\x05FIDO2\"i\n\x10AuthSetupRequest\x12\x16\n\x06secret\x18\
    \x01\x20\x01(\tR\x06secret\x12%\n\x04type\x18\x02\x20\x01(\x0e2\x11.serv\
    ice.AuthTypeR\x04type\x12\x16\n\x06device\x18\x05\x20\x01(\tR\x06device\
    \"\x13\n\x11AuthSetupResponse\"*\n\x10AuthVaultRequest\x12\x16\n\x06phra\
    se\x18\x01\x20\x01(\tR\x06phrase\"\x13\n\x11AuthVaultResponse\"j\n\x11Au\
    thUnlockRequest\x12\x16\n\x06secret\x18\x01\x20\x01(\tR\x06secret\x12%\n\
    \x04type\x18\x02\x20\x01(\x0e2\x11.service.AuthTypeR\x04type\x12\x16\n\
    \x06client\x18\x06\x20\x01(\tR\x06client\"2\n\x12AuthUnlockResponse\x12\
    \x1c\n\tauthToken\x18\x01\x20\x01(\tR\tauthToken\"\x89\x01\n\x14AuthProv\
    isionRequest\x12\x16\n\x06secret\x18\x01\x20\x01(\tR\x06secret\x12%\n\
    \x04type\x18\x02\x20\x01(\x0e2\x11.service.AuthTypeR\x04type\x12\x16\n\
    \x06device\x18\x05\x20\x01(\tR\x06device\x12\x1a\n\x08generate\x18\x07\
    \x20\x01(\x08R\x08generate\"M\n\x15AuthProvisionResponse\x124\n\tprovisi\
    on\x18\x01\x20\x01(\x0b2\x16.service.AuthProvisionR\tprovision\"2\n\x16A\
    uthDeprovisionRequest\x12\x18\n\x02id\x18\x01\x20\x01(\tR\x02idB\x08\xca\
    \xb5\x03\x04\n\x02ID\"\x19\n\x17AuthDeprovisionResponse\"?\n\x19AuthPass\
    wordChangeRequest\x12\x10\n\x03old\x18\x01\x20\x01(\tR\x03old\x12\x10\n\
    \x03new\x18\x02\x20\x01(\tR\x03new\"\x1c\n\x1aAuthPasswordChangeResponse\
    \"\xaa\x01\n\rAuthProvision\x12\x18\n\x02id\x18\x01\x20\x01(\tR\x02idB\
    \x08\xca\xb5\x03\x04\n\x02ID\x12%\n\x04type\x18\x02\x20\x01(\x0e2\x11.se\
    rvice.AuthTypeR\x04type\x12\x1c\n\tcreatedAt\x18\x03\x20\x01(\x03R\tcrea\
    tedAt\x12$\n\x06aaguid\x18d\x20\x01(\tR\x06aaguidB\x0c\xca\xb5\x03\x08\n\
    \x06AAGUID\x12\x14\n\x05noPin\x18e\x20\x01(\x08R\x05noPin\"\x17\n\x15Aut\
    hProvisionsRequest\"P\n\x16AuthProvisionsResponse\x126\n\nprovisions\x18\
    \x01\x20\x03(\x0b2\x16.service.AuthProvisionR\nprovisions\"\x11\n\x0fAut\
    hLockRequest\"\x12\n\x10AuthLockResponse\",\n\x10AuthResetRequest\x12\
    \x18\n\x07appName\x18\x01\x20\x01(\tR\x07appName\"\x13\n\x11AuthResetRes\
    ponse\"R\n\x12AuthRecoverRequest\x12\x1a\n\x08paperKey\x18\x01\x20\x01(\
    \tR\x08paperKey\x12\x20\n\x0bnewPassword\x18\x02\x20\x01(\tR\x0bnewPassw\
    ord\"3\n\x13AuthRecoverResponse\x12\x1c\n\tauthToken\x18\x01\x20\x01(\tR\
    \tauthToken\"(\n\x12KeyGenerateRequest\x12\x12\n\x04type\x18\x01\x20\x01\
    (\tR\x04type\"2\n\x13KeyGenerateResponse\x12\x1b\n\x03kid\x18\x01\x20\
    \x01(\tR\x03kidB\t\xca\xb5\x03\x05\n\x03KID\"K\n\x12UserServiceRequest\
    \x12\x1b\n\x03kid\x18\x01\x20\x01(\tR\x03kidB\t\xca\xb5\x03\x05\n\x03KID\
    \x12\x18\n\x07service\x18\x02\x20\x01(\tR\x07service\"/\n\x13UserService\
    Response\x12\x18\n\x07service\x18\x01\x20\x01(\tR\x07service\"\\\n\x0fUs\
    erSignRequest\x12\x1b\n\x03kid\x18\x01\x20\x01(\tR\x03kidB\t\xca\xb5\x03\
    \x05\n\x03KID\x12\x18\n\x07service\x18\x02\x20\x01(\tR\x07service\x12\
    \x12\n\x04name\x18\x03\x20\x01(\tR\x04name\"@\n\x10UserSignResponse\x12\
    \x18\n\x07message\x18\x01\x20\x01(\tR\x07message\x12\x12\n\x04name\x18\
    \x02\x20\x01(\tR\x04name\"\x8e\x01\n\x0eUserAddRequest\x12\x1b\n\x03kid\
    \x18\x01\x20\x01(\tR\x03kidB\t\xca\xb5\x03\x05\n\x03KID\x12\x18\n\x07ser\
    vice\x18\x02\x20\x01(\tR\x07service\x12\x12\n\x04name\x18\x03\x20\x01(\t\
    R\x04name\x12\x1b\n\x03url\x18\x04\x20\x01(\tR\x03urlB\t\xca\xb5\x03\x05\
    \n\x03URL\x12\x14\n\x05local\x18\x05\x20\x01(\x08R\x05local\"f\n\x0fUser\
    AddResponse\x12!\n\x04user\x18\x01\x20\x01(\x0b2\r.service.UserR\x04user\
    \x120\n\tstatement\x18\x02\x20\x01(\x0b2\x12.service.StatementR\tstateme\
    nt\"\xac\x01\n\x10KeyExportRequest\x12\x1b\n\x03kid\x18\x01\x20\x01(\tR\
    \x03kidB\t\xca\xb5\x03\x05\n\x03KID\x12\x1a\n\x08password\x18\x02\x20\
    \x01(\tR\x08password\x12'\n\x04type\x18\x03\x20\x01(\x0e2\x13.service.Ex\
    portTypeR\x04type\x12\x16\n\x06public\x18\x04\x20\x01(\x08R\x06public\
    \x12\x1e\n\nnoPassword\x18\x05\x20\x01(\x08R\nnoPassword\"+\n\x11KeyExpo\
    rtResponse\x12\x16\n\x06export\x18\x01\x20\x01(\x0cR\x06export\"V\n\x10K\
    eyImportRequest\x12\x0e\n\x02in\x18\x01\x20\x01(\x0cR\x02in\x12\x1a\n\
    \x08password\x18\x02\x20\x01(\tR\x08password\x12\x16\n\x06update\x18\x03\
    \x20\x01(\x08R\x06update\"0\n\x11KeyImportResponse\x12\x1b\n\x03kid\x18\
    \x01\x20\x01(\tR\x03kidB\t\xca\xb5\x03\x05\n\x03KID\"/\n\x10KeyRemoveReq\
    uest\x12\x1b\n\x03kid\x18\x01\x20\x01(\tR\x03kidB\t\xca\xb5\x03\x05\n\
    \x03KID\"\x13\n\x11KeyRemoveResponse\"\xe0\x01\n\x03Key\x12\x18\n\x02id\
    \x18\x01\x20\x01(\tR\x02idB\x08\xca\xb5\x03\x04\n\x02ID\x12\x12\n\x04typ\
    e\x18\x03\x20\x01(\tR\x04type\x12\x1c\n\tisPrivate\x18\x04\x20\x01(\x08R\
    \tisPrivate\x12!\n\x04user\x18\x06\x20\x01(\x0b2\r.service.UserR\x04user\
    \x12\x14\n\x05saved\x18\n\x20\x01(\x08R\x05saved\x12&\n\x0esigchainLengt\
    h\x18(\x20\x01(\x05R\x0esigchainLength\x12,\n\x11sigchainUpdatedAt\x18)\
    \x20\x01(\x03R\x11sigchainUpdatedAt\"N\n\nKeyRequest\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x16\n\x06search\x18\x04\x20\x01(\x08R\
    \x06search\x12\x16\n\x06update\x18\x05\x20\x01(\x08R\x06update\"-\n\x0bK\
    eyResponse\x12\x1e\n\x03key\x18\x01\x20\x01(\x0b2\x0c.service.KeyR\x03ke\
    y\"\x95\x01\n\x0bKeysRequest\x12\x14\n\x05query\x18\x01\x20\x01(\tR\x05q\
    uery\x12\x14\n\x05types\x18\x02\x20\x03(\tR\x05types\x12\x1c\n\tsortFiel\
    d\x18\n\x20\x01(\tR\tsortField\x12<\n\rsortDirection\x18\x0b\x20\x01(\
    \x0e2\x16.service.SortDirectionR\rsortDirection\"\x8c\x01\n\x0cKeysRespo\
    nse\x12\x20\n\x04keys\x18\x01\x20\x03(\x0b2\x0c.service.KeyR\x04keys\x12\
    \x1c\n\tsortField\x18\n\x20\x01(\tR\tsortField\x12<\n\rsortDirection\x18\
    \x0b\x20\x01(\x0e2\x16.service.SortDirectionR\rsortDirection\"\x86\x02\n\
    \x06Secret\x12\x18\n\x02id\x18\x01\x20\x01(\tR\x02idB\x08\xca\xb5\x03\
    \x04\n\x02ID\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12'\n\x04typ\
    e\x18\x03\x20\x01(\x0e2\x13.service.SecretTypeR\x04type\x12\x1a\n\x08use\
    rname\x18\n\x20\x01(\tR\x08username\x12\x1a\n\x08password\x18\x0b\x20\
    \x01(\tR\x08password\x12\x1b\n\x03url\x18\x14\x20\x01(\tR\x03urlB\t\xca\
    \xb5\x03\x05\n\x03URL\x12\x14\n\x05notes\x18\x1e\x20\x01(\tR\x05notes\
    \x12\x1c\n\tcreatedAt\x18d\x20\x01(\x03R\tcreatedAt\x12\x1c\n\tupdatedAt\
    \x18e\x20\x01(\x03R\tupdatedAt\")\n\rSecretRequest\x12\x18\n\x02id\x18\
    \x01\x20\x01(\tR\x02idB\x08\xca\xb5\x03\x04\n\x02ID\"9\n\x0eSecretRespon\
    se\x12'\n\x06secret\x18\x01\x20\x01(\x0b2\x0f.service.SecretR\x06secret\
    \"<\n\x11SecretSaveRequest\x12'\n\x06secret\x18\x01\x20\x01(\x0b2\x0f.se\
    rvice.SecretR\x06secret\"=\n\x12SecretSaveResponse\x12'\n\x06secret\x18\
    \x01\x20\x01(\x0b2\x0f.service.SecretR\x06secret\"/\n\x13SecretRemoveReq\
    uest\x12\x18\n\x02id\x18\x01\x20\x01(\tR\x02idB\x08\xca\xb5\x03\x04\n\
    \x02ID\"\x16\n\x14SecretRemoveResponse\"\x82\x01\n\x0eSecretsRequest\x12\
    \x14\n\x05query\x18\x01\x20\x01(\tR\x05query\x12\x1c\n\tsortField\x18\n\
    \x20\x01(\tR\tsortField\x12<\n\rsortDirection\x18\x0b\x20\x01(\x0e2\x16.\
    service.SortDirectionR\rsortDirection\"\x98\x01\n\x0fSecretsResponse\x12\
    )\n\x07secrets\x18\x01\x20\x03(\x0b2\x0f.service.SecretR\x07secrets\x12\
    \x1c\n\tsortField\x18\n\x20\x01(\tR\tsortField\x12<\n\rsortDirection\x18\
    \x0b\x20\x01(\x0e2\x16.service.SortDirectionR\rsortDirection\"\x94\x01\n\
    \x0bRandRequest\x12\x1a\n\x08numBytes\x18\x01\x20\x01(\x05R\x08numBytes\
    \x12-\n\x08encoding\x18\x02\x20\x01(\x0e2\x11.service.EncodingR\x08encod\
    ing\x12\x1c\n\tnoPadding\x18\n\x20\x01(\x08R\tnoPadding\x12\x1c\n\tlower\
    case\x18\x0b\x20\x01(\x08R\tlowercase\"\"\n\x0cRandResponse\x12\x12\n\
    \x04data\x18\x01\x20\x01(\tR\x04data\"-\n\x13RandPasswordRequest\x12\x16\
    \n\x06length\x18\x01\x20\x01(\x05R\x06length\"2\n\x14RandPasswordRespons\
    e\x12\x1a\n\x08password\x18\x01\x20\x01(\tR\x08password\"\x1f\n\x0bPullR\
    equest\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\".\n\x0cPullResponse\
    \x12\x1e\n\x04kids\x18\x01\x20\x03(\tR\x04kidsB\n\xca\xb5\x03\x06\n\x04K\
    IDs\"A\n\x0bPushRequest\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x20\n\x0bremoteCheck\x18\x02\x20\x01(\x08R\x0bremoteCheck\"K\n\x0cPushR\
    esponse\x12\x1b\n\x03kid\x18\x01\x20\x01(\tR\x03kidB\t\xca\xb5\x03\x05\n\
    \x03KID\x12\x1e\n\x04urls\x18\x02\x20\x03(\tR\x04urlsB\n\xca\xb5\x03\x06\
    \n\x04URLs\"\x20\n\nCollection\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04\
    path\"F\n\x12CollectionsRequest\x12\x16\n\x06parent\x18\x01\x20\x01(\tR\
    \x06parent\x12\x18\n\x02db\x18\x05\x20\x01(\tR\x02dbB\x08\xca\xb5\x03\
    \x04\n\x02DB\"L\n\x13CollectionsResponse\x125\n\x0bcollections\x18\x01\
    \x20\x03(\x0b2\x13.service.CollectionR\x0bcollections\"p\n\x08Document\
    \x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value\x12\x1c\n\tcreatedAt\x18\n\x20\x01(\x03R\tcrea\
    tedAt\x12\x1c\n\tupdatedAt\x18\x0b\x20\x01(\x03R\tupdatedAt\"D\n\x10Docu\
    mentsRequest\x12\x16\n\x06prefix\x18\x01\x20\x01(\tR\x06prefix\x12\x18\n\
    \x02db\x18\x05\x20\x01(\tR\x02dbB\x08\xca\xb5\x03\x04\n\x02DB\"D\n\x11Do\
    cumentsResponse\x12/\n\tdocuments\x18\x01\x20\x03(\x0b2\x11.service.Docu\
    mentR\tdocuments\"E\n\x15DocumentDeleteRequest\x12\x12\n\x04path\x18\x01\
    \x20\x01(\tR\x04path\x12\x18\n\x02db\x18\x05\x20\x01(\tR\x02dbB\x08\xca\
    \xb5\x03\x04\n\x02DB\"\x18\n\x16DocumentDeleteResponse\"\xb1\x02\n\x04Us\
    er\x12\x18\n\x02id\x18\x01\x20\x01(\tR\x02idB\x08\xca\xb5\x03\x04\n\x02I\
    D\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x1b\n\x03kid\x18\x03\
    \x20\x01(\tR\x03kidB\t\xca\xb5\x03\x05\n\x03KID\x12\x10\n\x03seq\x18\x04\
    \x20\x01(\x05R\x03seq\x12\x18\n\x07service\x18\x05\x20\x01(\tR\x07servic\
    e\x12\x1b\n\x03url\x18\x06\x20\x01(\tR\x03urlB\t\xca\xb5\x03\x05\n\x03UR\
    L\x12+\n\x06status\x18\n\x20\x01(\x0e2\x13.service.UserStatusR\x06status\
    \x12\x1e\n\nverifiedAt\x18\x0b\x20\x01(\x03R\nverifiedAt\x12\x1c\n\ttime\
    stamp\x18\x0c\x20\x01(\x03R\ttimestamp\x12\x18\n\x07proxied\x18\r\x20\
    \x01(\x08R\x07proxied\x12\x10\n\x03err\x18\x14\x20\x01(\tR\x03err\"@\n\
    \x0bUserRequest\x12\x1b\n\x03kid\x18\x01\x20\x01(\tR\x03kidB\t\xca\xb5\
    \x03\x05\n\x03KID\x12\x14\n\x05local\x18\x04\x20\x01(\x08R\x05local\"1\n\
    \x0cUserResponse\x12!\n\x04user\x18\x01\x20\x01(\x0b2\r.service.UserR\
    \x04user\"U\n\x11UserSearchRequest\x12\x14\n\x05query\x18\x01\x20\x01(\t\
    R\x05query\x12\x14\n\x05limit\x18\x03\x20\x01(\x05R\x05limit\x12\x14\n\
    \x05local\x18\x04\x20\x01(\x08R\x05local\"9\n\x12UserSearchResponse\x12#\
    \n\x05users\x18\x01\x20\x03(\x0b2\r.service.UserR\x05users\"%\n\rSearchR\
    equest\x12\x14\n\x05query\x18\x01\x20\x01(\tR\x05query\"2\n\x0eSearchRes\
    ponse\x12\x20\n\x04keys\x18\x01\x20\x03(\x0b2\x0c.service.KeyR\x04keys\"\
    \x12\n\x10VaultSyncRequest\"\x13\n\x11VaultSyncResponse\"\x14\n\x12Vault\
    UnsyncRequest\"\x15\n\x13VaultUnsyncResponse\"\x12\n\x10VaultAuthRequest\
    \"+\n\x11VaultAuthResponse\x12\x16\n\x06phrase\x18\x01\x20\x01(\tR\x06ph\
    rase\"\x14\n\x12VaultStatusRequest\"N\n\x13VaultStatusResponse\x12\x1b\n\
    \x03kid\x18\x01\x20\x01(\tR\x03kidB\t\xca\xb5\x03\x05\n\x03KID\x12\x1a\n\
    \x08syncedAt\x18\x02\x20\x01(\x03R\x08syncedAt\"\x14\n\x12VaultUpdateReq\
    uest\"\x15\n\x13VaultUpdateResponse\"\xab\x01\n\x07Message\x12\x18\n\x02\
    id\x18\x01\x20\x01(\tR\x02idB\x08\xca\xb5\x03\x04\n\x02ID\x12$\n\x06send\
    er\x18\x02\x20\x01(\x0b2\x0c.service.KeyR\x06sender\x12\x12\n\x04text\
    \x18\n\x20\x03(\tR\x04text\x12.\n\x06status\x18\x14\x20\x01(\x0e2\x16.se\
    rvice.MessageStatusR\x06status\x12\x1c\n\tcreatedAt\x18\x1f\x20\x01(\x03\
    R\tcreatedAt\"]\n\x15MessagePrepareRequest\x12\x16\n\x06sender\x18\x01\
    \x20\x01(\tR\x06sender\x12\x18\n\x07channel\x18\x02\x20\x01(\tR\x07chann\
    el\x12\x12\n\x04text\x18\x0b\x20\x01(\tR\x04text\"D\n\x16MessagePrepareR\
    esponse\x12*\n\x07message\x18\x01\x20\x01(\x0b2\x10.service.MessageR\x07\
    message\"v\n\x14MessageCreateRequest\x12\x16\n\x06sender\x18\x01\x20\x01\
    (\tR\x06sender\x12\x18\n\x07channel\x18\x02\x20\x01(\tR\x07channel\x12\
    \x18\n\x02id\x18\n\x20\x01(\tR\x02idB\x08\xca\xb5\x03\x04\n\x02ID\x12\
    \x12\n\x04text\x18\x0b\x20\x01(\tR\x04text\"C\n\x15MessageCreateResponse\
    \x12*\n\x07message\x18\x01\x20\x01(\x0b2\x10.service.MessageR\x07message\
    \"C\n\x0fMessagesRequest\x12\x18\n\x07channel\x18\x01\x20\x01(\tR\x07cha\
    nnel\x12\x16\n\x06update\x18\x05\x20\x01(\x08R\x06update\"@\n\x10Message\
    sResponse\x12,\n\x08messages\x18\x01\x20\x03(\x0b2\x10.service.MessageR\
    \x08messages\"6\n\x0cRelayRequest\x12\x12\n\x04keys\x18\x01\x20\x03(\tR\
    \x04keys\x12\x12\n\x04user\x18\x02\x20\x01(\tR\x04user\"Q\n\x0bRelayOutp\
    ut\x12\x18\n\x07channel\x18\x01\x20\x01(\tR\x07channel\x12\x12\n\x04user\
    \x18\x02\x20\x01(\tR\x04user\x12\x14\n\x05index\x18\x03\x20\x01(\x03R\
    \x05index\"\xa3\x01\n\x07Channel\x12\x18\n\x02id\x18\x01\x20\x01(\tR\x02\
    idB\x08\xca\xb5\x03\x04\n\x02ID\x12\x12\n\x04name\x18\x02\x20\x01(\tR\
    \x04name\x12\x18\n\x07snippet\x18\x03\x20\x01(\tR\x07snippet\x12\x1c\n\t\
    updatedAt\x18\x04\x20\x01(\x03R\tupdatedAt\x12\x14\n\x05index\x18\x05\
    \x20\x01(\x03R\x05index\x12\x1c\n\treadIndex\x18\n\x20\x01(\x03R\treadIn\
    dex\"%\n\x0fChannelsRequest\x12\x12\n\x04user\x18\x01\x20\x01(\tR\x04use\
    r\"@\n\x10ChannelsResponse\x12,\n\x08channels\x18\x01\x20\x03(\x0b2\x10.\
    service.ChannelR\x08channels\">\n\x14ChannelCreateRequest\x12\x12\n\x04n\
    ame\x18\x01\x20\x01(\tR\x04name\x12\x12\n\x04user\x18\x02\x20\x01(\tR\
    \x04user\"C\n\x15ChannelCreateResponse\x12*\n\x07channel\x18\x01\x20\x01\
    (\x0b2\x10.service.ChannelR\x07channel\"/\n\x13ChannelLeaveRequest\x12\
    \x18\n\x07channel\x18\x01\x20\x01(\tR\x07channel\"\x16\n\x14ChannelLeave\
    Response\"D\n\x12ChannelReadRequest\x12\x18\n\x07channel\x18\x01\x20\x01\
    (\tR\x07channel\x12\x14\n\x05index\x18\x02\x20\x01(\x03R\x05index\"\x15\
    \n\x13ChannelReadResponse\"h\n\x14ChannelInviteRequest\x12\x18\n\x07chan\
    nel\x18\x01\x20\x01(\tR\x07channel\x12\x1e\n\nrecipients\x18\x02\x20\x03\
    (\tR\nrecipients\x12\x16\n\x06sender\x18\x03\x20\x01(\tR\x06sender\"C\n\
    \x15ChannelInviteResponse\x12*\n\x07message\x18\x01\x20\x01(\x0b2\x10.se\
    rvice.MessageR\x07message\">\n\x06Follow\x12\x1c\n\trecipient\x18\x01\
    \x20\x01(\tR\trecipient\x12\x16\n\x06sender\x18\x02\x20\x01(\tR\x06sende\
    r\"E\n\rFollowRequest\x12\x1c\n\trecipient\x18\x01\x20\x01(\tR\trecipien\
    t\x12\x16\n\x06sender\x18\x02\x20\x01(\tR\x06sender\"9\n\x0eFollowRespon\
    se\x12'\n\x06follow\x18\x01\x20\x01(\x0b2\x0f.service.FollowR\x06follow\
    \"F\n\x0eFollowsRequest\x12\x1c\n\trecipient\x18\x01\x20\x01(\tR\trecipi\
    ent\x12\x16\n\x06update\x18\x02\x20\x01(\x08R\x06update\"<\n\x0fFollowsR\
    esponse\x12)\n\x07follows\x18\x01\x20\x03(\x0b2\x0f.service.FollowR\x07f\
    ollows\"b\n\x13AdminSignURLRequest\x12\x16\n\x06signer\x18\x01\x20\x01(\
    \tR\x06signer\x12\x16\n\x06method\x18\x02\x20\x01(\tR\x06method\x12\x1b\
    \n\x03url\x18\x03\x20\x01(\tR\x03urlB\t\xca\xb5\x03\x05\n\x03URL\"g\n\
    \x14AdminSignURLResponse\x12\x12\n\x04auth\x18\x01\x20\x01(\tR\x04auth\
    \x12\x1b\n\x03url\x18\x02\x20\x01(\tR\x03urlB\t\xca\xb5\x03\x05\n\x03URL\
    \x12\x1e\n\x04curl\x18\x03\x20\x01(\tR\x04curlB\n\xca\xb5\x03\x06\n\x04C\
    URL\"A\n\x11AdminCheckRequest\x12\x16\n\x06signer\x18\x01\x20\x01(\tR\
    \x06signer\x12\x14\n\x05check\x18\x02\x20\x01(\tR\x05check\"\x14\n\x12Ad\
    minCheckResponse\"\x97\x03\n\x06Config\x12%\n\x03app\x18\x01\x20\x01(\
    \x0b2\x13.service.Config.AppR\x03app\x121\n\x07encrypt\x18\n\x20\x01(\
    \x0b2\x17.service.Config.EncryptR\x07encrypt\x12(\n\x04sign\x18\x0b\x20\
    \x01(\x0b2\x14.service.Config.SignR\x04sign\x1a_\n\x03App\x12\x1a\n\x08l\
    ocation\x18\x01\x20\x01(\tR\x08location\x12\x18\n\x07history\x18\x02\x20\
    \x03(\tR\x07history\x12\"\n\x0cnavMinimized\x18d\x20\x01(\x08R\x0cnavMin\
    imized\x1a\x87\x01\n\x07Encrypt\x12\x1e\n\nrecipients\x18\x01\x20\x03(\t\
    R\nrecipients\x12\x16\n\x06sender\x18\x02\x20\x01(\tR\x06sender\x12,\n\
    \x11noSenderRecipient\x18\x03\x20\x01(\x08R\x11noSenderRecipient\x12\x16\
    \n\x06noSign\x18\x04\x20\x01(\x08R\x06noSign\x1a\x1e\n\x04Sign\x12\x16\n\
    \x06signer\x18\x01\x20\x01(\tR\x06signer\"&\n\x10ConfigGetRequest\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"<\n\x11ConfigGetResponse\x12\
    '\n\x06config\x18\x01\x20\x01(\x0b2\x0f.service.ConfigR\x06config\"O\n\
    \x10ConfigSetRequest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12'\
    \n\x06config\x18\x02\x20\x01(\x0b2\x0f.service.ConfigR\x06config\"\x13\n\
    \x11ConfigSetResponse\"\x8b\x01\n\rWormholeInput\x12\x16\n\x06sender\x18\
    \x01\x20\x01(\tR\x06sender\x12\x1c\n\trecipient\x18\x02\x20\x01(\tR\trec\
    ipient\x12\x16\n\x06invite\x18\x03\x20\x01(\tR\x06invite\x12\x18\n\x02id\
    \x18\n\x20\x01(\tR\x02idB\x08\xca\xb5\x03\x04\n\x02ID\x12\x12\n\x04text\
    \x18\x0b\x20\x01(\tR\x04text\"\xe7\x01\n\x0fWormholeMessage\x12\x18\n\
    \x02id\x18\x01\x20\x01(\tR\x02idB\x08\xca\xb5\x03\x04\n\x02ID\x12$\n\x06\
    sender\x18\x02\x20\x01(\x0b2\x0c.service.KeyR\x06sender\x12*\n\trecipien\
    t\x18\x03\x20\x01(\x0b2\x0c.service.KeyR\trecipient\x126\n\x06status\x18\
    \x05\x20\x01(\x0e2\x1e.service.WormholeMessageStatusR\x06status\x12\x12\
    \n\x04text\x18\n\x20\x01(\tR\x04text\x12\x1c\n\tcreatedAt\x18\x15\x20\
    \x01(\x03R\tcreatedAt\"u\n\x0eWormholeOutput\x122\n\x07message\x18\x01\
    \x20\x01(\x0b2\x18.service.WormholeMessageR\x07message\x12/\n\x06status\
    \x18\x02\x20\x01(\x0e2\x17.service.WormholeStatusR\x06status*\xa9\x01\n\
    \x0bEncryptMode\x12)\n\x0fDEFAULT_ENCRYPT\x10\0\x1a\x14\xca\xb5\x03\x10\
    \n\x0eDefaultEncrypt\x12+\n\x10SALTPACK_ENCRYPT\x10\x01\x1a\x15\xca\xb5\
    \x03\x11\n\x0fSaltpackEncrypt\x12/\n\x12SALTPACK_SIGNCRYPT\x10\x03\x1a\
    \x17\xca\xb5\x03\x13\n\x11SaltpackSigncrypt\x1a\x11\xca\xb5\x03\r\n\x0bE\
    ncryptMode*\xbb\x01\n\nAuthStatus\x12#\n\x0cAUTH_UNKNOWN\x10\0\x1a\x11\
    \xca\xb5\x03\r\n\x0bAuthUnknown\x12,\n\x11AUTH_SETUP_NEEDED\x10\x01\x1a\
    \x15\xca\xb5\x03\x11\n\x0fAuthSetupNeeded\x12%\n\rAUTH_UNLOCKED\x10\x02\
    \x1a\x12\xca\xb5\x03\x0e\n\x0cAuthUnlocked\x12!\n\x0bAUTH_LOCKED\x10\x03\
    \x1a\x10\xca\xb5\x03\x0c\n\nAuthLocked\x1a\x10\xca\xb5\x03\x0c\n\nAuthSt\
    atus*\xc5\x01\n\x08AuthType\x12#\n\x0cUNKNOWN_AUTH\x10\0\x1a\x11\xca\xb5\
    \x03\r\n\x0bUnknownAuth\x12%\n\rPASSWORD_AUTH\x10\n\x1a\x12\xca\xb5\x03\
    \x0e\n\x0cPasswordAuth\x12&\n\x0ePAPER_KEY_AUTH\x10\x0b\x1a\x12\xca\xb5\
    \x03\x0e\n\x0cPaperKeyAuth\x125\n\x16FIDO2_HMAC_SECRET_AUTH\x10\x14\x1a\
    \x19\xca\xb5\x03\x15\n\x13FIDO2HMACSecretAuth\x1a\x0e\xca\xb5\x03\n\n\
    \x08AuthType*r\n\nExportType\x12,\n\x13DEFAULT_EXPORT_TYPE\x10\0\x1a\x13\
    \xca\xb5\x03\x0f\n\rDefaultExport\x12$\n\x0fSSH_EXPORT_TYPE\x10\x01\x1a\
    \x0f\xca\xb5\x03\x0b\n\tSSHExport\x1a\x10\xca\xb5\x03\x0c\n\nExportType*\
    V\n\rSortDirection\x12\x16\n\x03ASC\x10\0\x1a\r\xca\xb5\x03\t\n\x07SortA\
    sc\x12\x18\n\x04DESC\x10\x01\x1a\x0e\xca\xb5\x03\n\n\x08SortDesc\x1a\x13\
    \xca\xb5\x03\x0f\n\rSortDirection*\xe6\x01\n\nSecretType\x12,\n\x13UNKNO\
    WN_SECRET_TYPE\x10\0\x1a\x13\xca\xb5\x03\x0f\n\rUnknownSecret\x12)\n\x0f\
    PASSWORD_SECRET\x10\n\x1a\x14\xca\xb5\x03\x10\n\x0ePasswordSecret\x12'\n\
    \x0eCONTACT_SECRET\x10\x0b\x1a\x13\xca\xb5\x03\x0f\n\rContactSecret\x12!\
    \n\x0bCARD_SECRET\x10\x0c\x1a\x10\xca\xb5\x03\x0c\n\nCardSecret\x12!\n\
    \x0bNOTE_SECRET\x10\r\x1a\x10\xca\xb5\x03\x0c\n\nNoteSecret\x1a\x10\xca\
    \xb5\x03\x0c\n\nSecretType*\xe6\x01\n\x08Encoding\x12\x12\n\x03HEX\x10\0\
    \x1a\t\xca\xb5\x03\x05\n\x03Hex\x12\x18\n\x06BASE62\x10\x01\x1a\x0c\xca\
    \xb5\x03\x08\n\x06Base62\x12\x18\n\x06BASE58\x10\x02\x1a\x0c\xca\xb5\x03\
    \x08\n\x06Base58\x12\x18\n\x06BASE32\x10\x03\x1a\x0c\xca\xb5\x03\x08\n\
    \x06Base32\x12\x18\n\x06BASE16\x10\x04\x1a\x0c\xca\xb5\x03\x08\n\x06Base\
    16\x12\x18\n\x06BASE64\x10\x05\x1a\x0c\xca\xb5\x03\x08\n\x06Base64\x12\
    \x1c\n\x08SALTPACK\x10\x06\x1a\x0e\xca\xb5\x03\n\n\x08Saltpack\x12\x16\n\
    \x05BIP39\x10\x07\x1a\x0b\xca\xb5\x03\x07\n\x05BIP39\x1a\x0e\xca\xb5\x03\
    \n\n\x08Encoding*\xff\x02\n\nUserStatus\x12)\n\x0cUSER_UNKNOWN\x10\0\x1a\
    \x17\xca\xb5\x03\x13\n\x11UserStatusUnknown\x12\x1f\n\x07USER_OK\x10\x01\
    \x1a\x12\xca\xb5\x03\x0e\n\x0cUserStatusOK\x12=\n\x17USER_RESOURCE_NOT_F\
    OUND\x10\x14\x1a\x20\xca\xb5\x03\x1c\n\x1aUserStatusResourceNotFound\x12\
    ;\n\x16USER_CONTENT_NOT_FOUND\x10\x1e\x1a\x1f\xca\xb5\x03\x1b\n\x19UserS\
    tatusContentNotFound\x128\n\x14USER_CONTENT_INVALID\x10\x1f\x1a\x1e\xca\
    \xb5\x03\x1a\n\x18UserStatusContentInvalid\x122\n\x11USER_CONN_FAILURE\
    \x10(\x1a\x1b\xca\xb5\x03\x17\n\x15UserStatusConnFailure\x12)\n\x0cUSER_\
    FAILURE\x102\x1a\x17\xca\xb5\x03\x13\n\x11UserStatusFailure\x1a\x10\xca\
    \xb5\x03\x0c\n\nUserStatus*\x9b\x01\n\rMessageStatus\x12#\n\x0cMESSAGE_S\
    ENT\x10\0\x1a\x11\xca\xb5\x03\r\n\x0bMessageSent\x12)\n\x0fMESSAGE_PENDI\
    NG\x10\x01\x1a\x14\xca\xb5\x03\x10\n\x0eMessagePending\x12%\n\rMESSAGE_E\
    RROR\x10\x02\x1a\x12\xca\xb5\x03\x0e\n\x0cMessageError\x1a\x13\xca\xb5\
    \x03\x0f\n\rMessageStatus*\xf0\x02\n\x0eWormholeStatus\x12+\n\x10WORMHOL\
    E_DEFAULT\x10\0\x1a\x15\xca\xb5\x03\x11\n\x0fWormholeDefault\x12-\n\x11W\
    ORMHOLE_STARTING\x10\n\x1a\x16\xca\xb5\x03\x12\n\x10WormholeStarting\x12\
    -\n\x11WORMHOLE_OFFERING\x10\x14\x1a\x16\xca\xb5\x03\x12\n\x10WormholeOf\
    fering\x12/\n\x12WORMHOLE_ANSWERING\x10\x15\x1a\x17\xca\xb5\x03\x13\n\
    \x11WormholeAnswering\x12/\n\x12WORMHOLE_HANDSHAKE\x10(\x1a\x17\xca\xb5\
    \x03\x13\n\x11WormholeHandshake\x12/\n\x12WORMHOLE_CONNECTED\x10d\x1a\
    \x17\xca\xb5\x03\x13\n\x11WormholeConnected\x12*\n\x0fWORMHOLE_CLOSED\
    \x10\xc8\x01\x1a\x14\xca\xb5\x03\x10\n\x0eWormholeClosed\x1a\x14\xca\xb5\
    \x03\x10\n\x0eWormholeStatus*\xda\x01\n\x15WormholeMessageStatus\x124\n\
    \x15WORMHOLE_MESSAGE_SENT\x10\0\x1a\x19\xca\xb5\x03\x15\n\x13WormholeMes\
    sageSent\x12:\n\x18WORMHOLE_MESSAGE_PENDING\x10\x01\x1a\x1c\xca\xb5\x03\
    \x18\n\x16WormholeMessagePending\x122\n\x14WORMHOLE_MESSAGE_ACK\x10\x02\
    \x1a\x18\xca\xb5\x03\x14\n\x12WormholeMessageAck\x1a\x1b\xca\xb5\x03\x17\
    \n\x15WormholeMessageStatus2\xca)\n\x03RPC\x12J\n\x0bKeyGenerate\x12\x1b\
    .service.KeyGenerateRequest\x1a\x1c.service.KeyGenerateResponse\"\0\x125\
    \n\x04Keys\x12\x14.service.KeysRequest\x1a\x15.service.KeysResponse\"\0\
    \x122\n\x03Key\x12\x13.service.KeyRequest\x1a\x14.service.KeyResponse\"\
    \0\x12D\n\tKeyImport\x12\x19.service.KeyImportRequest\x1a\x1a.service.Ke\
    yImportResponse\"\0\x12D\n\tKeyExport\x12\x19.service.KeyExportRequest\
    \x1a\x1a.service.KeyExportResponse\"\0\x12D\n\tKeyRemove\x12\x19.service\
    .KeyRemoveRequest\x1a\x1a.service.KeyRemoveResponse\"\0\x125\n\x04Sign\
    \x12\x14.service.SignRequest\x1a\x15.service.SignResponse\"\0\x12A\n\x08\
    SignFile\x12\x16.service.SignFileInput\x1a\x17.service.SignFileOutput\"\
    \0(\x010\x01\x12;\n\nSignStream\x12\x12.service.SignInput\x1a\x13.servic\
    e.SignOutput\"\0(\x010\x01\x12;\n\x06Verify\x12\x16.service.VerifyReques\
    t\x1a\x17.service.VerifyResponse\"\0\x12G\n\nVerifyFile\x12\x18.service.\
    VerifyFileInput\x1a\x19.service.VerifyFileOutput\"\0(\x010\x01\x12A\n\
    \x0cVerifyStream\x12\x14.service.VerifyInput\x1a\x15.service.VerifyOutpu\
    t\"\0(\x010\x01\x12S\n\x0eVerifyDetached\x12\x1e.service.VerifyDetachedR\
    equest\x1a\x1f.service.VerifyDetachedResponse\"\0\x12[\n\x12VerifyDetach\
    edFile\x12\x20.service.VerifyDetachedFileInput\x1a\x1f.service.VerifyDet\
    achedResponse\"\0(\x01\x12Y\n\x14VerifyDetachedStream\x12\x1c.service.Ve\
    rifyDetachedInput\x1a\x1f.service.VerifyDetachedResponse\"\0(\x01\x12>\n\
    \x07Encrypt\x12\x17.service.EncryptRequest\x1a\x18.service.EncryptRespon\
    se\"\0\x12D\n\rEncryptStream\x12\x15.service.EncryptInput\x1a\x16.servic\
    e.EncryptOutput\"\0(\x010\x01\x12J\n\x0bEncryptFile\x12\x19.service.Encr\
    yptFileInput\x1a\x1a.service.EncryptFileOutput\"\0(\x010\x01\x12>\n\x07D\
    ecrypt\x12\x17.service.DecryptRequest\x1a\x18.service.DecryptResponse\"\
    \0\x12D\n\rDecryptStream\x12\x15.service.DecryptInput\x1a\x16.service.De\
    cryptOutput\"\0(\x010\x01\x12J\n\x0bDecryptFile\x12\x19.service.DecryptF\
    ileInput\x1a\x1a.service.DecryptFileOutput\"\0(\x010\x01\x12A\n\x08Sigch\
    ain\x12\x18.service.SigchainRequest\x1a\x19.service.SigchainResponse\"\0\
    \x12D\n\tStatement\x12\x19.service.StatementRequest\x1a\x1a.service.Stat\
    ementResponse\"\0\x12V\n\x0fStatementCreate\x12\x1f.service.StatementCre\
    ateRequest\x1a\x20.service.StatementCreateResponse\"\0\x12V\n\x0fStateme\
    ntRevoke\x12\x1f.service.StatementRevokeRequest\x1a\x20.service.Statemen\
    tRevokeResponse\"\0\x125\n\x04User\x12\x14.service.UserRequest\x1a\x15.s\
    ervice.UserResponse\"\0\x12G\n\nUserSearch\x12\x1a.service.UserSearchReq\
    uest\x1a\x1b.service.UserSearchResponse\"\0\x12J\n\x0bUserService\x12\
    \x1b.service.UserServiceRequest\x1a\x1c.service.UserServiceResponse\"\0\
    \x12A\n\x08UserSign\x12\x18.service.UserSignRequest\x1a\x19.service.User\
    SignResponse\"\0\x12>\n\x07UserAdd\x12\x17.service.UserAddRequest\x1a\
    \x18.service.UserAddResponse\"\0\x12;\n\x06Search\x12\x16.service.Search\
    Request\x1a\x17.service.SearchResponse\"\0\x12;\n\x06Secret\x12\x16.serv\
    ice.SecretRequest\x1a\x17.service.SecretResponse\"\0\x12G\n\nSecretSave\
    \x12\x1a.service.SecretSaveRequest\x1a\x1b.service.SecretSaveResponse\"\
    \0\x12M\n\x0cSecretRemove\x12\x1c.service.SecretRemoveRequest\x1a\x1d.se\
    rvice.SecretRemoveResponse\"\0\x12>\n\x07Secrets\x12\x17.service.Secrets\
    Request\x1a\x18.service.SecretsResponse\"\0\x125\n\x04Pull\x12\x14.servi\
    ce.PullRequest\x1a\x15.service.PullResponse\"\0\x125\n\x04Push\x12\x14.s\
    ervice.PushRequest\x1a\x15.service.PushResponse\"\0\x12A\n\x08Wormhole\
    \x12\x16.service.WormholeInput\x1a\x17.service.WormholeOutput\"\0(\x010\
    \x01\x12D\n\tAuthSetup\x12\x19.service.AuthSetupRequest\x1a\x1a.service.\
    AuthSetupResponse\"\0\x12D\n\tAuthVault\x12\x19.service.AuthVaultRequest\
    \x1a\x1a.service.AuthVaultResponse\"\0\x12G\n\nAuthUnlock\x12\x1a.servic\
    e.AuthUnlockRequest\x1a\x1b.service.AuthUnlockResponse\"\0\x12A\n\x08Aut\
    hLock\x12\x18.service.AuthLockRequest\x1a\x19.service.AuthLockResponse\"\
    \0\x12D\n\tAuthReset\x12\x19.service.AuthResetRequest\x1a\x1a.service.Au\
    thResetResponse\"\0\x12J\n\x0bAuthRecover\x12\x1b.service.AuthRecoverReq\
    uest\x1a\x1c.service.AuthRecoverResponse\"\0\x12P\n\rRuntimeStatus\x12\
    \x1d.service.RuntimeStatusRequest\x1a\x1e.service.RuntimeStatusResponse\
    \"\0\x125\n\x04Rand\x12\x14.service.RandRequest\x1a\x15.service.RandResp\
    onse\"\0\x12M\n\x0cRandPassword\x12\x1c.service.RandPasswordRequest\x1a\
    \x1d.service.RandPasswordResponse\"\0\x12P\n\rAuthProvision\x12\x1d.serv\
    ice.AuthProvisionRequest\x1a\x1e.service.AuthProvisionResponse\"\0\x12V\
    \n\x0fAuthDeprovision\x12\x1f.service.AuthDeprovisionRequest\x1a\x20.ser\
    vice.AuthDeprovisionResponse\"\0\x12S\n\x0eAuthProvisions\x12\x1e.servic\
    e.AuthProvisionsRequest\x1a\x1f.service.AuthProvisionsResponse\"\0\x12_\
    \n\x12AuthPasswordChange\x12\".service.AuthPasswordChangeRequest\x1a#.se\
    rvice.AuthPasswordChangeResponse\"\0\x12D\n\tVaultAuth\x12\x19.service.V\
    aultAuthRequest\x1a\x1a.service.VaultAuthResponse\"\0\x12D\n\tVaultSync\
    \x12\x19.service.VaultSyncRequest\x1a\x1a.service.VaultSyncResponse\"\0\
    \x12J\n\x0bVaultUnsync\x12\x1b.service.VaultUnsyncRequest\x1a\x1c.servic\
    e.VaultUnsyncResponse\"\0\x12J\n\x0bVaultStatus\x12\x1b.service.VaultSta\
    tusRequest\x1a\x1c.service.VaultStatusResponse\"\0\x12J\n\x0bVaultUpdate\
    \x12\x1b.service.VaultUpdateRequest\x1a\x1c.service.VaultUpdateResponse\
    \"\0\x12J\n\x0bCollections\x12\x1b.service.CollectionsRequest\x1a\x1c.se\
    rvice.CollectionsResponse\"\0\x12D\n\tDocuments\x12\x19.service.Document\
    sRequest\x1a\x1a.service.DocumentsResponse\"\0\x12S\n\x0eDocumentDelete\
    \x12\x1e.service.DocumentDeleteRequest\x1a\x1f.service.DocumentDeleteRes\
    ponse\"\0\x12D\n\tConfigGet\x12\x19.service.ConfigGetRequest\x1a\x1a.ser\
    vice.ConfigGetResponse\"\0\x12D\n\tConfigSet\x12\x19.service.ConfigSetRe\
    quest\x1a\x1a.service.ConfigSetResponse\"\0\x12M\n\x0cAdminSignURL\x12\
    \x1c.service.AdminSignURLRequest\x1a\x1d.service.AdminSignURLResponse\"\
    \0\x12G\n\nAdminCheck\x12\x1a.service.AdminCheckRequest\x1a\x1b.service.\
    AdminCheckResponse\"\0\x12A\n\x08Channels\x12\x18.service.ChannelsReques\
    t\x1a\x19.service.ChannelsResponse\"\0\x12P\n\rChannelCreate\x12\x1d.ser\
    vice.ChannelCreateRequest\x1a\x1e.service.ChannelCreateResponse\"\0\x12P\
    \n\rChannelInvite\x12\x1d.service.ChannelInviteRequest\x1a\x1e.service.C\
    hannelInviteResponse\"\0\x12M\n\x0cChannelLeave\x12\x1c.service.ChannelL\
    eaveRequest\x1a\x1d.service.ChannelLeaveResponse\"\0\x12J\n\x0bChannelRe\
    ad\x12\x1b.service.ChannelReadRequest\x1a\x1c.service.ChannelReadRespons\
    e\"\0\x12;\n\x06Follow\x12\x16.service.FollowRequest\x1a\x17.service.Fol\
    lowResponse\"\0\x12>\n\x07Follows\x12\x17.service.FollowsRequest\x1a\x18\
    .service.FollowsResponse\"\0\x12S\n\x0eMessagePrepare\x12\x1e.service.Me\
    ssagePrepareRequest\x1a\x1f.service.MessagePrepareResponse\"\0\x12P\n\rM\
    essageCreate\x12\x1d.service.MessageCreateRequest\x1a\x1e.service.Messag\
    eCreateResponse\"\0\x12A\n\x08Messages\x12\x18.service.MessagesRequest\
    \x1a\x19.service.MessagesResponse\"\0\x128\n\x05Relay\x12\x15.service.Re\
    layRequest\x1a\x14.service.RelayOutput\"\00\x01B\x0bZ\t.;serviceb\x06pro\
    to3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
